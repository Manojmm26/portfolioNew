{
  "concepts": [
    {
      "id": "basic-types",
      "title": "Basic Types",
      "description": "TypeScript supports a rich set of basic data types, forming the foundation of type safety in your code. These include primitives like `number`, `string`, `boolean`, and special types like `null`, `undefined`, `void`, `any`, `unknown`, and `never`.",
      "difficulty": "beginner",
      "category": "fundamentals",
      "explanation": "TypeScript's basic types are essential for defining the kind of data a variable can hold. Unlike JavaScript, TypeScript allows you to explicitly declare the type of a variable, enabling compile-time type checking and improving code reliability. Understanding these types is crucial for writing robust and maintainable TypeScript code. `any` and `unknown` are escape hatches for dynamic content, while `void` and `never` are used in function contexts to denote no return value or functions that never return, respectively.",
      "example": "let age: number = 30; // Number type for numeric values\nlet name: string = \"Alice\"; // String type for textual data\nlet isStudent: boolean = true; // Boolean type for true/false values\nlet nothing: null = null; // Null type, representing an intentional absence of a value\nlet missing: undefined = undefined; // Undefined type, indicating a variable has not been assigned a value\n\nfunction greet(): void { // Void type for functions that do not return a value\n  console.log(\"Hello!\");\n}\n\nlet flexible: any = 4; // Any type, disables type checking (use sparingly)\nflexible = \"string\";\n\nlet maybe: unknown = 5; // Unknown type, type-safe counterpart to 'any'. Requires type assertion or narrowing before use.\nif (typeof maybe === 'number') {\n  let safeNumber = maybe + 10; // Type narrowed to number within the if block\n}\n\nfunction error(message: string): never { // Never type for functions that always throw an error or never return\n  throw new Error(message);\n}",
      "keyPoints": [
        "`number`, `string`, and `boolean` are primitive types for common data values.",
        "`null` and `undefined` represent intentional absence of value and uninitialized variables, respectively.",
        "`void` is used for functions that do not return a value.",
        "`any` bypasses type checking and should be used cautiously.",
        "`unknown` is a type-safe alternative to `any`, requiring type narrowing or assertion.",
        "`never` represents values that never occur, often used for functions that throw errors or infinite loops.",
        "Type annotations (`variable: type`) are fundamental for type declarations in TypeScript."
      ],
      "quiz": [
        {
          "question": "Which of the following TypeScript types is used to explicitly disable type checking?",
          "options": ["void", "unknown", "any", "never"],
          "correctAnswer": 2,
          "explanation": "The `any` type in TypeScript turns off type checking for variables and expressions, allowing for flexibility but sacrificing type safety. It should be used sparingly when dealing with dynamically typed JavaScript code or external libraries without type declarations."
        },
        {
          "question": "What is the purpose of the `void` type in TypeScript?",
          "options": ["To indicate a variable has no value.", "To define a function that returns null.", "To specify that a function does not return any value.", "To represent an unknown type."],
          "correctAnswer": 2,
          "explanation": "The `void` type is primarily used to denote functions that do not return a value. Functions that perform actions but don't produce a result are typically typed as `void`."
        },
        {
          "question": "Which type is considered a safer alternative to `any` when dealing with values of unknown type?",
          "options": ["null", "undefined", "unknown", "never"],
          "correctAnswer": 2,
          "explanation": "The `unknown` type is designed for situations where you don't know the type of a value. Unlike `any`, it forces you to perform type narrowing or assertion before you can operate on values of `unknown` type, making your code safer."
        }
      ]
    },
    {
      "id": "interfaces",
      "title": "Interfaces",
      "description": "Interfaces in TypeScript are powerful tools for defining contracts that specify the structure of objects. They describe the shape an object should have, including the names and types of its properties, and can also define method signatures.",
      "difficulty": "beginner",
      "category": "fundamentals",
      "explanation": "Interfaces allow you to enforce a specific structure on objects, ensuring that they have the properties and methods you expect. They are a cornerstone of structural typing in TypeScript, focusing on the shape of the object rather than its class. Interfaces enhance code readability and maintainability by clearly defining object structures and enabling compile-time checks for type compatibility. They can be extended, implemented by classes, and used to describe function types and indexable types.",
      "example": "// Defining an interface for a point in 2D space\ninterface Point {\n  x: number;\n  y: number;\n  label?: string; // Optional property\n  describe(): string; // Method signature\n}\n\nlet point1: Point = {\n  x: 10,\n  y: 20,\n  describe: function() {\n    return `Point at (${this.x}, ${this.y})`;\n  }\n};\n\nlet point2: Point = {\n  x: 5,\n  y: 8,\n  label: \"Origin\",\n  describe: () => `Point is labeled: ${point2.label} at (${point2.x}, ${point2.y})` // Arrow function example\n};\n\ninterface Movable {\n  move(distance: number): void;\n}\n\n// Interface extension\ninterface Circle extends Point, Movable {\n  radius: number;\n}\n\nlet circle: Circle = {\n  x: 0,\n  y: 0,\n  radius: 5,\n  describe: () => `Circle with radius ${circle.radius} at (${circle.x}, ${circle.y})`,\n  move: (distance) => console.log(`Circle moved ${distance} units`)\n};",
      "keyPoints": [
        "Interfaces define the structure of objects, specifying required and optional properties and their types.",
        "They can include method signatures, defining the name, parameters, and return type of methods.",
        "Interfaces support optional properties using `?` and readonly properties using `readonly` keyword.",
        "Interfaces can extend other interfaces, inheriting and adding to their structure.",
        "Classes can implement interfaces, ensuring they conform to the interface's contract.",
        "Interfaces are purely type-level constructs; they do not exist at runtime in JavaScript.",
        "They promote code reusability, maintainability, and type safety by enforcing object shapes."
      ],
      "quiz": [
        {
          "question": "Which keyword is used to define optional properties within a TypeScript interface?",
          "options": ["optional", "?", "maybe", "default"],
          "correctAnswer": 1,
          "explanation": "The `?` symbol after a property name in an interface indicates that the property is optional. Objects implementing the interface are not required to have this property."
        },
        {
          "question": "Can a TypeScript interface define the implementation of methods?",
          "options": ["Yes, always", "No, never", "Only for static methods", "Only for private methods"],
          "correctAnswer": 1,
          "explanation": "Interfaces in TypeScript only define method signatures (the method name, parameters, and return type) but do not include the actual implementation or method body. The implementation is provided by classes or objects that implement the interface."
        },
        {
          "question": "What is the primary benefit of using interfaces over type aliases for defining object structures?",
          "options": ["Interfaces can be instantiated.", "Interfaces support union and intersection types.", "Interfaces can be implemented by classes and extended by other interfaces.", "Type aliases provide better performance."],
          "correctAnswer": 2,
          "explanation": "While type aliases can define object shapes, interfaces have the added capabilities of being implemented by classes and extended by other interfaces, which are crucial for object-oriented programming and creating reusable, composable type contracts."
        }
      ]
    },
    {
      "id": "classes",
      "title": "Classes",
      "description": "TypeScript classes are blueprints for creating objects that encapsulate data (properties) and behavior (methods). They provide a way to structure code in an object-oriented manner, supporting inheritance, encapsulation, and polymorphism.",
      "difficulty": "beginner",
      "category": "fundamentals",
      "explanation": "Classes in TypeScript are similar to classes in other object-oriented languages. They provide a familiar syntax for defining objects and their interactions. TypeScript enhances JavaScript classes with features like access modifiers (public, private, protected), constructors, inheritance using `extends`, and static members. Classes are fundamental for building complex applications by organizing code into reusable and manageable units. They allow for creating instances of objects with specific properties and methods, and support object-oriented principles for better code organization and maintainability.",
      "example": "// Defining a class 'Vehicle'\nclass Vehicle {\n  // Public property (default access modifier)\n  color: string;\n  // Protected property (accessible within the class and its subclasses)\n  protected engineType: string = \"Generic\";\n  // Private property (accessible only within the class)\n  private modelYear: number;\n  // Static property (associated with the class itself, not instances)\n  static numberOfVehicles: number = 0;\n\n  constructor(color: string, modelYear: number) {\n    this.color = color;\n    this.modelYear = modelYear;\n    Vehicle.numberOfVehicles++;\n  }\n\n  // Public method\n  startEngine(): void {\n    console.log(\"Engine started. Type: \" + this.engineType);\n  }\n\n  // Private method (only accessible within the class)\n  private getModelYear(): number {\n    return this.modelYear;\n  }\n\n  // Static method (can be called directly on the class)\n  static getVehicleCount(): number {\n    return Vehicle.numberOfVehicles;\n  }\n}\n\n// Inheritance\nclass Car extends Vehicle {\n  numberOfDoors: number;\n\n  constructor(color: string, modelYear: number, doors: number) {\n    super(color, modelYear); // Call to the superclass constructor\n    this.engineType = \"Car Engine\"; // Accessing protected member in subclass\n    this.numberOfDoors = doors;\n  }\n\n  honk(): void {\n    console.log(\"Honk honk!\");\n  }\n}\n\nlet myCar = new Car(\"Red\", 2023, 4);\nmyCar.startEngine(); // Accessing public method\nmyCar.honk(); // Accessing method of subclass\nconsole.log(\"Car color: \" + myCar.color);\nconsole.log(\"Total vehicles created: \" + Vehicle.getVehicleCount()); // Accessing static method",
      "keyPoints": [
        "Classes are used to create objects with properties (data) and methods (behavior).",
        "Constructors are special methods for initializing objects when they are created using `new`.",
        "Access modifiers (`public`, `private`, `protected`) control the visibility and accessibility of class members.",
        "Inheritance is supported using the `extends` keyword, allowing classes to inherit properties and methods from parent classes.",
        "Static members (properties and methods) are associated with the class itself rather than instances of the class.",
        "Classes implement object-oriented programming principles like encapsulation and inheritance, promoting code organization and reusability."
      ],
      "quiz": [
        {
          "question": "What is the purpose of the `super()` keyword in a TypeScript class constructor?",
          "options": ["To call a static method of the class.", "To access private members of the class.", "To call the constructor of the parent class.", "To define a superclass."],
          "correctAnswer": 2,
          "explanation": "In a subclass constructor, `super()` is used to call the constructor of the parent class (superclass). This is necessary to initialize properties inherited from the parent class before the subclass can add its own initialization logic."
        },
        {
          "question": "Which access modifier in TypeScript classes makes a member accessible only within the class itself?",
          "options": ["public", "protected", "private", "internal"],
          "correctAnswer": 2,
          "explanation": "The `private` access modifier restricts the accessibility of a class member (property or method) to only within the class where it is declared. It cannot be accessed from outside the class or from subclasses."
        },
        {
          "question": "What is the difference between instance members and static members of a class?",
          "options": ["Instance members are shared across all objects, while static members are unique to each object.", "Static members are associated with the class itself, while instance members are associated with instances (objects) of the class.", "Instance members can only be methods, while static members can only be properties.", "There is no difference; instance and static members are interchangeable."],
          "correctAnswer": 1,
          "explanation": "Static members belong to the class itself and are accessed using the class name (e.g., `ClassName.staticMember`). Instance members belong to each object created from the class and are accessed through the object instance (e.g., `objectInstance.instanceMember`)."
        }
      ]
    },
    {
      "id": "generics",
      "title": "Generics",
      "description": "Generics in TypeScript enable you to write reusable code that can work with multiple types while maintaining type safety. They allow you to define type variables that act as placeholders for the actual types, which are specified later when the code is used.",
      "difficulty": "intermediate",
      "category": "advanced-types",
      "explanation": "Generics are a powerful feature in TypeScript for creating components that can work over a variety of types rather than a single one. By using type parameters, you can write functions, interfaces, and classes that are adaptable to different data types without losing type safety. Generics enhance code flexibility and reusability by allowing you to abstract over types, making your components more versatile and less prone to errors. They are widely used in collections, algorithms, and utility functions where the exact type is not known or needs to be flexible.",
      "example": "// Generic function to get the first element of an array\nfunction firstElement<T>(arr: T[]): T | undefined {\n  return arr[0];\n}\n\nlet numbers = [1, 2, 3];\nlet firstNumber = firstElement<number>(numbers); // T is inferred as number\nconsole.log(\"First number:\", firstNumber); // Output: 1\n\nlet strings = [\"apple\", \"banana\", \"cherry\"];\nlet firstString = firstElement<string>(strings); // T is inferred as string\nconsole.log(\"First string:\", firstString); // Output: apple\n\n// Generic interface\ninterface Container<T> {\n  value: T;\n  getValue(): T;\n}\n\nclass NumberContainer implements Container<number> {\n  value: number;\n  constructor(value: number) {\n    this.value = value;\n  }\n  getValue(): number {\n    return this.value;\n  }\n}\n\nlet numContainer = new NumberContainer(100);\nconsole.log(\"Container value:\", numContainer.getValue()); // Output: 100\n\n// Generic class\nclass DataHolder<T> {\n  private data: T;\n\n  constructor(data: T) {\n    this.data = data;\n  }\n\n  getData(): T {\n    return this.data;\n  }\n\n  setData(newData: T): void {\n    this.data = newData;\n  }\n}\n\nlet stringDataHolder = new DataHolder<string>(\"Initial Data\");\nconsole.log(\"Data:\", stringDataHolder.getData()); // Output: Initial Data\nstringDataHolder.setData(\"Updated Data\");\nconsole.log(\"Updated Data:\", stringDataHolder.getData()); // Output: Updated Data",
      "keyPoints": [
        "Generics use type parameters (e.g., `<T>`) to represent types that will be specified later.",
        "They enable writing functions, interfaces, and classes that can work with different types while maintaining type safety.",
        "Type parameters are specified within angle brackets `<>` and can be used throughout the generic component.",
        "Generics improve code reusability by abstracting over types, reducing code duplication.",
        "Type inference often allows TypeScript to automatically determine the type parameter without explicit specification.",
        "Generic constraints can be used to limit the types that a type parameter can accept, adding more control and type safety."
      ],
      "quiz": [
        {
          "question": "In a generic function `function process<T>(item: T): T`, what does `<T>` represent?",
          "options": ["A specific type named 'T'.", "A type parameter that will be specified when the function is called.", "A constraint on the type of 'item'.", "A default type for 'item' if no type is provided."],
          "correctAnswer": 1,
          "explanation": "In generic syntax, `<T>` declares `T` as a type parameter. This means `T` is a placeholder for a type that will be specified when the `process` function is used. It allows the function to work with different types while maintaining type safety."
        },
        {
          "question": "What is the primary advantage of using generics in TypeScript?",
          "options": ["To reduce compile time.", "To increase code execution speed.", "To enable code reusability with type safety.", "To simplify debugging."],
          "correctAnswer": 2,
          "explanation": "The main benefit of generics is that they allow you to write code that can be reused with different types without sacrificing type safety. This means you can create components that are both flexible and type-safe, reducing errors and improving code maintainability."
        },
        {
          "question": "Can a generic type parameter be constrained to certain types?",
          "options": ["No, generic type parameters must be universally applicable.", "Yes, using type constraints with the `extends` keyword.", "Only for generic classes, not for generic functions.", "Only for primitive types, not for object types."],
          "correctAnswer": 1,
          "explanation": "Yes, you can use type constraints with the `extends` keyword to limit the types that a generic type parameter can accept. This allows you to enforce certain properties or structures on the types used with your generics, providing more control and type safety. For example, `function processItem<T extends { id: number }>(item: T) { ... }` constrains `T` to types that have an `id` property of type `number`."
        }
      ]
    },
    {
      "id": "enums",
      "title": "Enums",
      "description": "Enums (enumerations) in TypeScript allow you to define a set of named constants. They provide a way to give more friendly names to sets of numeric or string values, improving code readability and maintainability.",
      "difficulty": "beginner",
      "category": "fundamentals",
      "explanation": "Enums are useful for representing a fixed set of related values, such as status codes, directions, or options. TypeScript supports both numeric and string enums. Numeric enums are auto-incremented by default, starting from 0, or you can explicitly assign numeric values. String enums, introduced more recently, require each member to be explicitly initialized with a string literal. Enums enhance code clarity by replacing magic numbers or strings with meaningful names, making your code easier to understand and less error-prone.",
      "example": "// Numeric Enum\nenum Status {\n  Pending,    // 0\n  InProgress, // 1\n  Completed,  // 2\n  Rejected    // 3\n}\n\nlet taskStatus: Status = Status.InProgress;\nconsole.log(\"Task status:\", Status[taskStatus]); // Output: InProgress (reverse mapping)\nconsole.log(\"Status code:\", Status.Completed);   // Output: 2\n\n// String Enum\nenum Direction {\n  Up = \"UP\",\n  Down = \"DOWN\",\n  Left = \"LEFT\",\n  Right = \"RIGHT\"\n}\n\nlet moveDirection: Direction = Direction.Right;\nconsole.log(\"Move direction:\", moveDirection); // Output: RIGHT\n\n// Heterogeneous Enum (less common, mixing string and numeric)\nenum Mixed {\n  Yes = 1,\n  No = \"No\",\n}\n\nconsole.log(\"Mixed.Yes:\", Mixed.Yes); // Output: 1\nconsole.log(\"Mixed.No:\", Mixed.No);   // Output: No",
      "keyPoints": [
        "Enums define a set of named constants, making code more readable and self-documenting.",
        "TypeScript supports numeric enums (default and explicitly assigned values) and string enums.",
        "Numeric enums auto-increment from 0 by default if no values are assigned.",
        "String enums require explicit string literal values for each member.",
        "Enums provide reverse mapping for numeric enums, allowing you to get the name from the value.",
        "Enums improve code maintainability by centralizing constant values and reducing the use of magic numbers or strings."
      ],
      "quiz": [
        {
          "question": "What is the default starting value for the first member of a numeric enum in TypeScript if no explicit value is assigned?",
          "options": ["-1", "null", "0", "1"],
          "correctAnswer": 2,
          "explanation": "By default, the first member of a numeric enum is assigned the value `0` if no explicit value is provided. Subsequent members are auto-incremented from the previous member's value."
        },
        {
          "question": "Can you have an enum where members have both string and number values?",
          "options": ["No, enums must be strictly either numeric or string.", "Yes, TypeScript supports heterogeneous enums with mixed string and number values.", "Only if you explicitly declare the enum as 'mixed'.", "Only for advanced enums defined in declaration files."],
          "correctAnswer": 1,
          "explanation": "TypeScript does support heterogeneous enums, where you can mix string and numeric values within the same enum. However, this is less common and can sometimes lead to confusion, so it's often recommended to stick to either purely numeric or purely string enums for clarity."
        },
        {
          "question": "For a numeric enum `enum Status { Open, Closed }`, what is the value of `Status.Closed`?",
          "options": ["'Closed'", "undefined", "1", "2"],
          "correctAnswer": 2,
          "explanation": "In the numeric enum `enum Status { Open, Closed }`, `Status.Open` would be `0` (default starting value), and `Status.Closed` would be `1` because numeric enum members auto-increment. If `Open` was explicitly set to `5` (e.g., `enum Status { Open = 5, Closed }`), then `Closed` would be `6`."
        }
      ]
    },
    {
      "id": "type-aliases",
      "title": "Type Aliases",
      "description": "Type aliases in TypeScript allow you to create a new name for an existing type. They do not create a new type, but rather give a more descriptive or convenient name to a type, which can be primitive, union, intersection, object, or any other valid TypeScript type.",
      "difficulty": "beginner",
      "category": "fundamentals",
      "explanation": "Type aliases are extremely useful for improving code readability and maintainability, especially when dealing with complex types. They help in reducing redundancy by allowing you to define a type once and reuse it throughout your code with a meaningful name. Type aliases can be used for simple types, object types, function types, union types, tuple types, and more. They are purely a TypeScript feature and do not change the runtime behavior of your JavaScript code. They are essentially labels for types, enhancing developer experience by making type annotations clearer and more concise.",
      "example": "// Alias for primitive type\ntype Age = number;\nlet userAge: Age = 25;\n\n// Alias for object type\ntype Point2D = {\n  x: number;\n  y: number;\n};\n\nlet origin: Point2D = { x: 0, y: 0 };\n\n// Alias for function type\ntype StringTransformer = (input: string) => string;\n\nconst toUpperCase: StringTransformer = (str) => str.toUpperCase();\nconsole.log(toUpperCase(\"hello\")); // Output: HELLO\n\n// Alias for union type\ntype StringOrNumber = string | number;\n\nfunction processValue(val: StringOrNumber) {\n  if (typeof val === 'string') {\n    console.log(\"String value:\", val);\n  } else {\n    console.log(\"Number value:\", val);\n  }\n}\n\nprocessValue(\"text\"); // Output: String value: text\nprocessValue(123);    // Output: Number value: 123\n\n// Alias for tuple type\ntype Coordinate = [number, number, string?]; // Optional label\n\nlet location: Coordinate = [10, 20];\nlet namedLocation: Coordinate = [30, 40, \"Home\"];",
      "keyPoints": [
        "Type aliases create new names for existing types, improving code readability.",
        "They do not create new types themselves; they are just aliases.",
        "Type aliases can be used for any type, including primitives, objects, functions, unions, and tuples.",
        "They help in reducing code duplication and making complex type annotations more manageable.",
        "Type aliases are a compile-time feature of TypeScript and have no runtime impact.",
        "They are declared using the `type` keyword followed by the alias name and the type definition."
      ],
      "quiz": [
        {
          "question": "What is the primary purpose of type aliases in TypeScript?",
          "options": ["To create new data types.", "To improve code readability and maintainability by giving names to types.", "To enhance runtime performance.", "To enforce stricter type checking at runtime."],
          "correctAnswer": 1,
          "explanation": "The main purpose of type aliases is to enhance code readability and maintainability by providing descriptive names for complex or frequently used types. They make type annotations clearer and more concise, but they do not create new types or affect runtime behavior."
        },
        {
          "question": "Can a type alias be used to create an alias for a union type?",
          "options": ["No, type aliases only work with primitive types.", "Yes, type aliases can be used for union types and any other valid TypeScript type.", "Only if the union type consists of string literals.", "Only for union types of interfaces."],
          "correctAnswer": 1,
          "explanation": "Yes, type aliases are versatile and can be used to create aliases for union types, intersection types, object types, function types, primitive types, and any other valid TypeScript type. This flexibility makes them a powerful tool for managing complex type definitions."
        },
        {
          "question": "How do type aliases differ from interfaces in TypeScript?",
          "options": ["Type aliases create new types, while interfaces do not.", "Interfaces can be implemented by classes and extended, while type aliases cannot.", "Type aliases are only for object types, while interfaces are for function types.", "There is no difference; 'type alias' and 'interface' are interchangeable terms."],
          "correctAnswer": 1,
          "explanation": "Interfaces and type aliases serve different primary purposes. Interfaces are primarily used to define contracts for object shapes and can be implemented by classes and extended by other interfaces. Type aliases, on the other hand, are used to give names to any type, including primitives, unions, and intersections, and do not support implementation or extension in the same way as interfaces. While a type alias can describe an object shape, it does not have the same object-oriented capabilities as interfaces."
        }
      ]
    },
    {
      "id": "union-types",
      "title": "Union Types",
      "description": "Union types in TypeScript allow a variable to hold values of different types. They are a way of saying \"a variable can be of type A or type B or type C, etc.\". Union types are denoted using the pipe symbol `|` to separate the types.",
      "difficulty": "intermediate",
      "category": "advanced-types",
      "explanation": "Union types are essential for dealing with situations where a variable or parameter can accept values of more than one type. They enhance type flexibility while still maintaining type safety. When working with a union type, you can only access properties or methods that are common to all types in the union, unless you narrow down the type using type guards. Union types are commonly used in function parameters, return types, and variable declarations to handle diverse input or output possibilities. They are a core feature for writing flexible and robust TypeScript code.",
      "example": "// Union type for accepting either string or number\nfunction printId(id: string | number): void {\n  if (typeof id === 'string') {\n    console.log(\"ID is a string:\", id.toUpperCase());\n  } else {\n    console.log(\"ID is a number:\", id.toFixed(2));\n  }\n}\n\nprintId(101);         // Output: ID is a number: 101.00\nprintId(\"unique-id\"); // Output: ID is a string: UNIQUE-ID\n// printId(true);      // Error: Argument of type 'boolean' is not assignable to parameter of type 'string | number'.\n\n// Union type for array of strings or numbers\nlet mixedArray: (string | number)[] = [1, \"hello\", 2, \"world\"];\n\n// Union type for literal types\ntype Status = \"loading\" | \"success\" | \"error\";\nlet requestStatus: Status = \"loading\";\nrequestStatus = \"success\";\n// requestStatus = \"pending\"; // Error: Type '\"pending\"' is not assignable to type 'Status'.\n\n// Union type with null or undefined\nfunction maybeGetValue(): string | null {\n  return Math.random() > 0.5 ? \"value\" : null;\n}\n\nlet value = maybeGetValue();\nif (value !== null) {\n  console.log(\"Got a value:\", value.toUpperCase()); // Safe to call toUpperCase() because of null check\n}",
      "keyPoints": [
        "Union types allow a variable to be one of several types.",
        "They are defined using the pipe symbol `|` to separate type options (e.g., `string | number`).",
        "When working with union types, you may need to use type guards (like `typeof`, `instanceof`, custom type guard functions) to narrow down the type before accessing type-specific properties or methods.",
        "Union types increase flexibility in function parameters, return types, and variable declarations.",
        "They help in handling situations where data can be of different types, while still maintaining type safety.",
        "Union types are a powerful feature for creating adaptable and error-resistant TypeScript code."
      ],
      "quiz": [
        {
          "question": "How do you declare a union type in TypeScript?",
          "options": ["Using the `&` symbol.", "Using the `|` symbol.", "Using the `,` symbol.", "Using the `union` keyword."],
          "correctAnswer": 1,
          "explanation": "Union types in TypeScript are declared using the pipe symbol `|` to separate the possible types. For example, `string | number` indicates a type that can be either a string or a number."
        },
        {
          "question": "If a variable is of a union type `string | number`, can you directly call methods specific to only one of the types (e.g., `toUpperCase()` which is only for strings)?",
          "options": ["Yes, always.", "No, never.", "Only if you are sure of the type at compile time.", "Only after narrowing down the type using a type guard."],
          "correctAnswer": 3,
          "explanation": "No, you cannot directly call type-specific methods on a union type variable without first narrowing down the type. TypeScript's type system requires you to use type guards (like `typeof`, `instanceof`, or custom type guard functions) to ensure the variable is of the correct type before calling type-specific methods, thus maintaining type safety."
        },
        {
          "question": "Which of the following is a common use case for union types?",
          "options": ["Defining object interfaces.", "Creating classes with inheritance.", "Handling function parameters that can accept different types of arguments.", "Declaring private class members."],
          "correctAnswer": 2,
          "explanation": "A common use case for union types is in function parameters or return types where a function may need to accept or return values of different types. This allows for greater flexibility in function design while still benefiting from TypeScript's type checking. For instance, a function might accept either a string ID or a numeric ID, which can be represented using a union type for its parameter."
        }
      ]
    },
    {
      "id": "intersection-types",
      "title": "Intersection Types",
      "description": "Intersection types in TypeScript combine multiple types into one. The resulting type has all the features of all member types. They are primarily used to compose existing object types together. Intersection types are denoted using the `&` symbol.",
      "difficulty": "intermediate",
      "category": "advanced-types",
      "explanation": "Intersection types are a way to create new types by combining existing types. An intersection type `A & B` means that a value of this type must satisfy both type `A` and type `B`. This is particularly useful for composing interfaces or object types to create a type that has properties from multiple sources. Intersection types are different from union types; union types represent a value that can be of one of several types, while intersection types represent a value that is simultaneously of several types. They are powerful for creating flexible and composable type structures, especially in object-oriented and functional programming paradigms in TypeScript.",
      "example": "// Define two interface types\ninterface Colorful {\n  color: string;\n}\n\ninterface Shape {\n  area(): number;\n}\n\n// Intersection type combining Colorful and Shape\ntype ColoredShape = Colorful & Shape;\n\nfunction drawShape(shape: ColoredShape): void {\n  console.log(\"Drawing shape with color:\", shape.color, \"and area:\", shape.area());\n}\n\nlet circleShape: ColoredShape = {\n  color: \"red\",\n  area: () => 100, // Implementation of area method\n};\n\ndrawShape(circleShape); // Output: Drawing shape with color: red and area: 100\n\n// Example with primitive types (less common but valid)\ntype StringAndNumber = string & number; // Type is effectively 'never' because a value cannot be both string and number simultaneously\n// let sn: StringAndNumber = ...; // No value can satisfy this type\n\n// Intersection with classes\nclass Loggable {\n  log(message: string): void {\n    console.log(\"Log:\", message);\n  }\n}\n\nclass Printable {\n  print(): void {\n    console.log(\"Printing...\");\n  }\n}\n\nfunction combineLoggablePrintable<T extends Loggable & Printable>(constructor: new (...args: any[]) => T): new (...args: any[]) => T {\n  return constructor;\n}\n\n@combineLoggablePrintable\nclass MyClass {\n  // Class now effectively 'implements' both Loggable and Printable due to the decorator/intersection\n}\n\nlet instance = new MyClass();\ninstance.log(\"Instance created\"); // Loggable method\ninstance.print();         // Printable method",
      "keyPoints": [
        "Intersection types combine multiple types into a single type.",
        "The resulting type has all the properties and methods of all the intersected types.",
        "They are denoted using the `&` symbol (e.g., `TypeA & TypeB`).",
        "Intersection types are primarily used to compose object types or interfaces.",
        "They are different from union types; intersection means 'and', while union means 'or'.",
        "Intersection types are useful for creating composable and reusable type structures in TypeScript."
      ],
      "quiz": [
        {
          "question": "What operator is used to create an intersection type in TypeScript?",
          "options": ["|", "&", ",", "union"],
          "correctAnswer": 1,
          "explanation": "The `&` operator is used to create intersection types in TypeScript. For example, `TypeA & TypeB` creates a type that is both `TypeA` and `TypeB`."
        },
        {
          "question": "If you have an intersection type `TypeA & TypeB`, what properties and methods will a value of this type have?",
          "options": ["Only the properties and methods of `TypeA`.", "Only the properties and methods of `TypeB`.", "The properties and methods that are common to both `TypeA` and `TypeB`.", "All properties and methods of both `TypeA` and `TypeB`."],
          "correctAnswer": 3,
          "explanation": "A value of an intersection type `TypeA & TypeB` must possess all the properties and methods of `TypeA` AND all the properties and methods of `TypeB`. It effectively combines the members of all intersected types into a single type."
        },
        {
          "question": "What is the key difference between union types and intersection types?",
          "options": ["Union types combine types, while intersection types separate them.", "Union types mean 'either/or', while intersection types mean 'and'.", "Union types are used for objects, while intersection types are for primitive types.", "There is no significant difference between union and intersection types."],
          "correctAnswer": 1,
          "explanation": "The fundamental difference is that union types (`TypeA | TypeB`) represent a value that can be either of `TypeA` OR `TypeB`, while intersection types (`TypeA & TypeB`) represent a value that must be of both `TypeA` AND `TypeB`. Union types offer flexibility by allowing multiple type options, whereas intersection types combine features from multiple types into a single, more comprehensive type."
        }
      ]
    },
    {
      "id": "literal-types",
      "title": "Literal Types",
      "description": "Literal types in TypeScript allow you to specify the exact value that a variable or parameter must have. TypeScript supports string literal types, numeric literal types, boolean literal types, and enum literal types. They enable more precise type definitions, making your type system more expressive.",
      "difficulty": "intermediate",
      "category": "advanced-types",
      "explanation": "Literal types are a powerful way to constrain the possible values that a variable can hold to a specific set of literal values. This is in contrast to more general types like `string` or `number`, which can accept a wide range of values. Literal types make your type definitions more precise and self-documenting, reducing the chance of errors caused by unexpected values. They are particularly useful for scenarios where you need to enforce a limited set of valid values, such as status codes, direction names, or configuration options. Literal types enhance type safety and code clarity by making your type system more descriptive and restrictive where needed.",
      "example": "// String Literal Types\ntype AllowedStatus = \"pending\" | \"approved\" | \"rejected\";\nlet currentStatus: AllowedStatus = \"pending\";\ncurrentStatus = \"approved\"; // OK\n// currentStatus = \"processing\"; // Error: Type '\"processing\"' is not assignable to type 'AllowedStatus'.\n\nfunction setStatus(status: AllowedStatus): void {\n  console.log(\"Status set to:\", status);\n}\n setStatus(\"approved\"); // OK\n// setStatus(\"invalid\");  // Error: Argument of type '\"invalid\"' is not assignable to parameter of type 'AllowedStatus'.\n\n// Numeric Literal Types\ntype DiceRoll = 1 | 2 | 3 | 4 | 5 | 6;\nfunction rollDice(): DiceRoll {\n  return (Math.floor(Math.random() * 6) + 1) as DiceRoll; // Type assertion needed as Math.random() returns number\n}\n\nlet rollResult: DiceRoll = rollDice();\nconsole.log(\"Dice roll result:\", rollResult);\n\n// Boolean Literal Types (less common, but valid)\ntype TrueOnly = true;\nlet alwaysTrue: TrueOnly = true;\n// alwaysTrue = false; // Error: Type 'false' is not assignable to type 'true'.\n\n// Enum Literal Types (implicitly created for enum members)\nenum CardinalDirection {\n  North,\n  East,\n  South,\n  West,\n}\n\nfunction getDirectionName(direction: CardinalDirection): string {\n  switch (direction) {\n    case CardinalDirection.North: return \"North\";\n    case CardinalDirection.East: return \"East\";\n    case CardinalDirection.South: return \"South\";\n    case CardinalDirection.West: return \"West\";\n  }\n}\n\nlet directionName = getDirectionName(CardinalDirection.East);\nconsole.log(\"Direction name:\", directionName); // Output: Direction name: East",
      "keyPoints": [
        "Literal types specify exact values that a variable must hold (e.g., 'hello', 42, true).",
        "TypeScript supports string, number, boolean, and enum literal types.",
        "They provide more precise type definitions compared to general types like `string` or `number`.",
        "Literal types are useful for enforcing a limited set of valid values for variables or parameters.",
        "They enhance type safety and code clarity by making type constraints more explicit and restrictive.",
        "Union types are often used in conjunction with literal types to define a set of allowed literal values (e.g., `\"option1\" | \"option2\"`)."
      ],
      "quiz": [
        {
          "question": "Which of the following is NOT a type of literal type in TypeScript?",
          "options": ["String literal type", "Numeric literal type", "Boolean literal type", "Object literal type"],
          "correctAnswer": 3,
          "explanation": "TypeScript supports string, numeric, and boolean literal types, as well as enum literal types. 'Object literal type' is not a standard term in TypeScript's literal types category. While you can define the shape of object literals, the term 'object literal type' is not used in the context of literal types in the same way as string, numeric, or boolean literals."
        },
        {
          "question": "What is the primary benefit of using literal types over more general types like `string` or `number`?",
          "options": ["Improved runtime performance.", "Reduced code compilation time.", "Increased type precision and stricter value constraints.", "Simplified code debugging."],
          "correctAnswer": 2,
          "explanation": "The main benefit of literal types is that they provide increased type precision and allow you to enforce stricter value constraints. By specifying exact values as types, you make your type system more expressive and can catch errors at compile time that might arise from using unexpected or invalid values. This enhances type safety and code reliability."
        },
        {
          "question": "Consider the type `type Status = \"active\" | \"inactive\"`. What kind of type is `Status`?",
          "options": ["A string type.", "A union of string literal types.", "An enum type.", "An intersection type."],
          "correctAnswer": 1,
          "explanation": "The type `Status = \"active\" | \"inactive\"` is a union of string literal types. It means that a variable of type `Status` can only hold either the string literal value 'active' or the string literal value 'inactive'. This is a common pattern for using literal types to define a limited set of valid string values."
        }
      ]
    },
    {
      "id": "type-inference",
      "title": "Type Inference",
      "description": "Type inference in TypeScript is the ability of the compiler to automatically deduce the type of a variable or expression when it's not explicitly annotated. TypeScript uses contextual information and initialization values to infer types, reducing the need for explicit type annotations in many cases.",
      "difficulty": "beginner",
      "category": "fundamentals",
      "explanation": "TypeScript's type inference system is a key feature that balances type safety with developer convenience. It intelligently analyzes your code to determine types based on context, such as initialization values, function return types, and property assignments. This reduces boilerplate code and makes TypeScript feel less verbose compared to languages where explicit type annotations are always required. However, while type inference is powerful, explicit type annotations are still recommended in certain situations, especially for function signatures, complex object structures, and public APIs, to improve code clarity and prevent unintended type mismatches. Understanding how type inference works helps you write more efficient and cleaner TypeScript code.",
      "example": "// Type inference based on initialization\nlet message = \"Hello, TypeScript!\"; // Inferred as string\nlet count = 100;                  // Inferred as number\nlet isActive = true;               // Inferred as boolean\nlet items = [1, 2, 3];              // Inferred as number[]\nlet point = { x: 10, y: 20 };       // Inferred as { x: number; y: number; }\n\n// Type inference in function return types\nfunction add(a: number, b: number) { // Return type inferred as number\n  return a + b;\n}\n\nlet sum = add(5, 3); // 'sum' inferred as number\n\nfunction getFirstElement(arr: any[]) { // Return type inferred as any (less ideal, consider generics)\n  return arr[0];\n}\n\nlet first = getFirstElement([\"a\", \"b\", \"c\"]); // 'first' inferred as any\n\n// Contextual type inference\nwindow.addEventListener('click', (event) => { // 'event' parameter is contextually inferred as MouseEvent\n  console.log(\"Mouse event at:\", event.clientX, event.clientY);\n});\n\n// Best practices: Explicit annotations for function signatures and complex types for clarity and maintainability\nfunction greetUser(name: string): string { // Explicit return type annotation\n  return `Hello, ${name}!`;\n}\n\ninterface Person {\n  firstName: string;\n  lastName: string;\n}\n\nlet person: Person = { // Explicit type annotation for object\n  firstName: \"John\",\n  lastName: \"Doe\"\n};",
      "keyPoints": [
        "Type inference allows TypeScript to automatically deduce types without explicit annotations.",
        "TypeScript infers types based on initialization values, function return types, and contextual information.",
        "It reduces the need for verbose type annotations, making code cleaner and faster to write.",
        "Type inference is powerful but not always perfect, especially in complex scenarios.",
        "Explicit type annotations are still recommended for function signatures, complex object types, and public APIs for clarity and maintainability.",
        "Understanding type inference helps you write efficient and less verbose TypeScript code while maintaining type safety."
      ],
      "quiz": [
        {
          "question": "In which scenario is TypeScript type inference most effective?",
          "options": ["When dealing with complex object structures.", "When function return types are explicitly annotated.", "When variables are initialized with a value.", "When using 'any' type extensively."],
          "correctAnswer": 2,
          "explanation": "Type inference is most effective when variables are initialized with a value. TypeScript can often automatically deduce the type of a variable based on the type of the value it is initially assigned. For example, `let count = 10;` will infer `count` to be of type `number`."
        },
        {
          "question": "When is it generally recommended to use explicit type annotations instead of relying on type inference?",
          "options": ["For simple variable declarations.", "For function parameters and return types, especially in public APIs.", "When initializing variables with literal values.", "When writing short, throwaway scripts."],
          "correctAnswer": 1,
          "explanation": "It's generally recommended to use explicit type annotations for function parameters and return types, particularly in public APIs or when defining reusable functions. Explicit annotations improve code readability, make function signatures clearer, and help prevent unintended type mismatches, especially for developers consuming your APIs."
        },
        {
          "question": "If you declare a variable `let value;` without initializing it, what type will TypeScript infer?",
          "options": ["any", "unknown", "undefined", "void"],
          "correctAnswer": 0,
          "explanation": "If you declare a variable without initializing it and without providing an explicit type annotation (e.g., `let value;`), TypeScript will infer its type as `any`. This is because TypeScript cannot determine the intended type without any initialization value or explicit type hint, and defaults to `any` to allow maximum flexibility (but sacrificing type safety)."
        }
      ]
    },
    {
      "id": "type-assertion",
      "title": "Type Assertion",
      "description": "Type assertion in TypeScript is a way to tell the compiler \"trust me, I know more about the type of this value than you do.\" It allows you to override TypeScript's type inference and explicitly specify a type for a value. Type assertion is like a type cast in other languages, but it performs no runtime checking or restructuring.",
      "difficulty": "intermediate",
      "category": "advanced-types",
      "explanation": "Type assertion is a useful feature when you are certain about the type of a value, but TypeScript's type inference is unable to deduce it correctly, or when you are working with JavaScript code that doesn't have type information. It's important to use type assertion judiciously because it bypasses TypeScript's compile-time type checking. Overusing type assertion can reduce the benefits of type safety and potentially lead to runtime errors if the asserted type is incorrect. There are two main syntaxes for type assertion in TypeScript: angle bracket syntax (`<Type>value`) and `as` syntax (`value as Type`), with the `as` syntax being generally preferred as it is less ambiguous, especially when working with JSX.",
      "example": "// Type assertion using 'as' syntax (preferred)\nlet someValue: any = \"this is a string\";\nlet strLength: number = (someValue as string).length; // Asserting 'someValue' as string to access string methods\nconsole.log(\"String length:\", strLength); // Output: 16\n\n// Type assertion using angle bracket syntax (less common, can conflict with JSX)\nlet anotherValue: any = \"hello world\";\nlet strLength2: number = (<string>anotherValue).length; // Asserting 'anotherValue' as string\nconsole.log(\"String length 2:\", strLength2); // Output: 11\n\n// Type assertion when fetching data (example)\nasync function fetchData(): Promise<any> {\n  const response = await fetch('https://api.example.com/data');\n  return await response.json();\n}\n\nasync function processData() {\n  let rawData = await fetchData(); // 'rawData' is of type 'any' due to fetch API types\n  if (rawData) {\n    let processedData = rawData as { name: string, value: number }; // Asserting structure of fetched data\n    console.log(\"Processed data name:\", processedData.name);\n    console.log(\"Processed data value:\", processedData.value);\n  }\n}\n\n// Type assertion for DOM elements (example)\nconst canvas = document.getElementById('myCanvas'); // 'canvas' is inferred as HTMLElement | null\nif (canvas) {\n  const ctx = (canvas as HTMLCanvasElement).getContext('2d'); // Asserting 'canvas' as HTMLCanvasElement to access 2D context methods\n  if (ctx) {\n    ctx.fillStyle = 'red';\n    ctx.fillRect(10, 10, 50, 50);\n  }\n}",
      "keyPoints": [
        "Type assertion allows you to override TypeScript's type inference and specify a type for a value.",
        "It tells the compiler \"trust me, I know the type.\"",
        "Type assertion performs no runtime type checking or type conversion.",
        "Use type assertion when you are certain about the type, but TypeScript cannot infer it.",
        "Two syntaxes for type assertion: `value as Type` (preferred) and `<Type>value` (angle bracket, less common).",
        "Use type assertion judiciously to maintain type safety and avoid potential runtime errors."
      ],
      "quiz": [
        {
          "question": "What is the primary purpose of type assertion in TypeScript?",
          "options": ["To convert a value from one type to another at runtime.", "To force TypeScript to perform runtime type checking.", "To tell the TypeScript compiler to treat a value as a specific type, overriding inference.", "To create a new type based on an existing type."],
          "correctAnswer": 2,
          "explanation": "The main purpose of type assertion is to instruct the TypeScript compiler to treat a value as being of a specific type. This is done when you, as the developer, have more information about the type than TypeScript can infer. It's a way to override type inference, not to perform runtime type conversion or checking."
        },
        {
          "question": "Which syntax is generally preferred for type assertion in TypeScript, especially when working with JSX?",
          "options": ["Angle bracket syntax (`<Type>value`)", "`as` syntax (`value as Type`)", "Type casting syntax (`(Type)value`)", "There is no preferred syntax; both are equally valid."],
          "correctAnswer": 1,
          "explanation": "The `as` syntax (`value as Type`) is generally preferred for type assertion in TypeScript, especially when working with JSX. Angle bracket syntax (`<Type>value`) can sometimes be ambiguous and conflict with JSX syntax, making `as` syntax the recommended and clearer approach in most cases."
        },
        {
          "question": "Does type assertion perform any runtime type checking or type conversion?",
          "options": ["Yes, it performs both runtime type checking and conversion.", "Yes, it performs runtime type checking but no conversion.", "No, it performs no runtime type checking or conversion; it's purely a compile-time construct.", "No, it performs runtime type conversion but no type checking."],
          "correctAnswer": 2,
          "explanation": "Type assertion in TypeScript is purely a compile-time construct. It does not perform any runtime type checking or type conversion. It's simply a way to tell the TypeScript compiler to treat a value as a specific type, and it's up to the developer to ensure that the assertion is correct. If the assertion is incorrect, it can lead to runtime errors that TypeScript's type system is intended to prevent."
        }
      ]
    },
    {
      "id": "type-guards",
      "title": "Type Guards",
      "description": "Type guards in TypeScript are expressions that narrow down the type of a variable within a conditional block. They allow TypeScript to understand the specific type of a variable in certain code paths, especially when dealing with union types or `unknown` types. Type guards ensure type safety when working with values that could be of multiple types.",
      "difficulty": "intermediate",
      "category": "advanced-types",
      "explanation": "Type guards are crucial for safely working with union types or when dealing with values of `unknown` type. They help TypeScript understand the specific type of a variable within a conditional block, enabling you to access type-specific properties and methods without type errors. Common type guards include `typeof`, `instanceof`, `in` operator, and custom type guard functions. By using type guards, you can write more flexible and robust code that handles different types appropriately, while still benefiting from TypeScript's strong type system. Type guards make your code more readable and maintainable by clearly delineating how different types are handled in various code paths.",
      "example": "// Type guard using 'typeof'\nfunction processValue(value: string | number) {\n  if (typeof value === 'string') { // Type guard: typeof value === 'string'\n    console.log(\"String value:\", value.toUpperCase()); // Safe to call toUpperCase() as TypeScript knows 'value' is string here\n  } else if (typeof value === 'number') { // Type guard: typeof value === 'number'\n    console.log(\"Number value:\", value.toFixed(2)); // Safe to call toFixed() as TypeScript knows 'value' is number here\n  }\n}\n\nprocessValue(\"hello\"); // Output: String value: HELLO\nprocessValue(123.456); // Output: Number value: 123.46\n\n// Type guard using 'instanceof'\nclass Animal {\n  move() {\n    console.log(\"Moving...\");\n  }\n}\n\nclass Dog extends Animal {\n  bark() {\n    console.log(\"Woof!\");\n  }\n}\n\nfunction animalAction(animal: Animal) {\n  animal.move(); // Always safe as all Animals move\n  if (animal instanceof Dog) { // Type guard: animal instanceof Dog\n    animal.bark(); // Safe to call bark() as TypeScript knows 'animal' is Dog here\n  }\n}\n\nanimalAction(new Animal()); // Output: Moving...\nanimalAction(new Dog());    // Output: Moving...\n                             //         Woof!\n\n// Custom type guard function\ninterface Bird {\n  fly(): void;\n  layEggs(): void;\n}\n\ninterface Fish {\n  swim(): void;\n  layEggs(): void;\n}\n\nfunction isBird(pet: Bird | Fish): pet is Bird { // Custom type guard function\n  return (pet as Bird).fly !== undefined; // Simple check to determine if it's a Bird\n}\n\nfunction petAction(pet: Bird | Fish) {\n  pet.layEggs(); // Common method, always safe\n  if (isBird(pet)) { // Using custom type guard function\n    pet.fly(); // Safe to call fly() as TypeScript knows 'pet' is Bird here\n  } else { // Implicitly, TypeScript knows 'pet' must be Fish here\n    pet.swim(); // Safe to call swim() as TypeScript knows 'pet' is Fish here\n  }\n}\n\npetAction({ fly: () => console.log(\"Flying\"), layEggs: () => console.log(\"Laying bird eggs\") } as Bird); // Output: Laying bird eggs\n                                                                                                      //         Flying\npetAction({ swim: () => console.log(\"Swimming\"), layEggs: () => console.log(\"Laying fish eggs\") } as Fish); // Output: Laying fish eggs\n                                                                                                      //         Swimming",
      "keyPoints": [
        "Type guards narrow down the type of a variable within conditional blocks.",
        "They enable TypeScript to understand specific types in different code paths, especially for union types.",
        "Common type guards include `typeof`, `instanceof`, `in` operator, and custom type guard functions.",
        "Type guards are essential for safely accessing type-specific properties and methods on union types or `unknown` values.",
        "They improve type safety and reduce potential runtime errors when dealing with values of multiple possible types.",
        "Custom type guard functions use return type annotations like `variable is Type` to inform TypeScript about the type narrowing."
      ],
      "quiz": [
        {
          "question": "What is the purpose of type guards in TypeScript?",
          "options": ["To convert a value from one type to another at runtime.", "To enforce stricter type checking across the entire codebase.", "To narrow down the type of a variable within a conditional block, enabling type-safe operations.", "To bypass TypeScript's type system and allow any operation on a variable."],
          "correctAnswer": 2,
          "explanation": "Type guards are designed to narrow down the type of a variable within a conditional block. This allows TypeScript to understand that in a certain part of your code, a variable of a union type is actually of a more specific type, enabling you to safely perform operations specific to that narrowed type."
        },
        {
          "question": "Which of the following is NOT a common type guard in TypeScript?",
          "options": ["typeof", "instanceof", "in", "as"],
          "correctAnswer": 3,
          "explanation": "While `typeof`, `instanceof`, and `in` operator are common type guards in TypeScript, `as` is used for type assertion, not type guarding. Type assertion overrides type inference, whereas type guards narrow down types within conditional blocks based on checks like `typeof`, `instanceof`, or property existence (`in`)."
        },
        {
          "question": "What is the return type annotation for a custom type guard function that checks if a variable `pet` is a `Bird`?",
          "options": ["boolean", "void", "pet: Bird", "pet is Bird"],
          "correctAnswer": 3,
          "explanation": "The correct return type annotation for a custom type guard function that checks if a variable `pet` is a `Bird` is `pet is Bird`. This special syntax tells TypeScript that if the function returns `true`, then within the scope where the function is called and returns `true`, TypeScript should treat the variable `pet` as being of type `Bird`. This is how custom type guard functions inform TypeScript about type narrowing."
        }
      ]
    },
    {
      "id": "mapped-types",
      "title": "Mapped Types",
      "description": "Mapped types in TypeScript allow you to create new types by transforming properties of existing types. They are based on index signatures and type parameters, enabling you to create types that are derived from other types in a systematic and declarative way. Mapped types are powerful for creating utility types and transforming object structures.",
      "difficulty": "advanced",
      "category": "advanced-types",
      "explanation": "Mapped types are a sophisticated feature in TypeScript that allows for creating new types by iterating over the properties of an existing type and applying transformations to each property. They are built upon index signatures and generics, providing a declarative way to perform common type transformations such as making properties readonly, optional, or picking specific properties. Mapped types are incredibly useful for reducing boilerplate code and creating reusable type transformations, especially when working with complex object types. They are at the heart of many built-in utility types in TypeScript like `Partial<T>`, `Readonly<T>`, `Pick<T, K>`, and `Record<K, T>`.",
      "example": "// Mapped type to make all properties of a type Readonly\ntype Readonly<T> = {\n  readonly [P in keyof T]: T[P];\n};\n\ninterface Person {\n  name: string;\n  age: number;\n}\n\ntype ReadonlyPerson = Readonly<Person>; // Applies Readonly to all properties of Person\n\nlet person: ReadonlyPerson = {\n  name: \"Alice\",\n  age: 30\n};\n\n// person.age = 31; // Error: Cannot assign to 'age' because it is a read-only property.\n\n// Mapped type to make all properties of a type Partial (optional)\ntype Partial<T> = {\n  [P in keyof T]?: T[P];\n};\n\ntype OptionalPerson = Partial<Person>; // Makes all properties of Person optional\n\nlet optionalPerson: OptionalPerson = {}; // OK, all properties are optional\noptionalPerson = { name: \"Bob\" };       // OK, only 'name' is provided\noptionalPerson = { name: \"Charlie\", age: 25 }; // OK, both are provided\n\n// Mapped type to pick specific properties from a type\ntype Pick<T, K extends keyof T> = {\n  [P in K]: T[P];\n};\n\ntype NameAndAge = Pick<Person, 'name' | 'age'>; // Picks 'name' and 'age' properties from Person\n\nlet personInfo: NameAndAge = {\n  name: \"David\",\n  age: 40\n};\n// personInfo = { name: \"Eve\", city: \"London\" }; // Error: Type '{ name: string; city: string; }' is not assignable to type 'NameAndAge'.\n\n// Mapped type with modifiers (+/- readonly, +/- optional)\ntype Mutable<T> = {\n  -readonly [P in keyof T]: T[P]; // Removes readonly modifier\n};\n\ntype WritablePerson = Mutable<ReadonlyPerson>; // Removes readonly from ReadonlyPerson, making properties writable\nlet writablePerson: WritablePerson = { name: \"Frank\", age: 50 };\nwritablePerson.age = 51; // OK, 'age' is now writable",
      "keyPoints": [
        "Mapped types transform properties of existing types to create new types.",
        "They use index signatures (`[P in keyof T]`) to iterate over properties of a type.",
        "Type parameters and `keyof` operator are central to mapped type definitions.",
        "Common transformations include making properties readonly, optional, or picking/omitting specific properties.",
        "Mapped types are used to create utility types like `Partial<T>`, `Readonly<T>`, `Pick<T, K>`, and `Omit<T, K>`.",
        "Modifiers like `readonly` and `?` (optional) can be added or removed using `+/-` in mapped types."
      ],
      "quiz": [
        {
          "question": "What is the primary purpose of mapped types in TypeScript?",
          "options": ["To create new instances of classes.", "To transform properties of existing types to create new types.", "To perform runtime type checking.", "To define interfaces with optional properties."],
          "correctAnswer": 1,
          "explanation": "The primary purpose of mapped types is to enable the creation of new types by transforming the properties of existing types. This transformation can include making properties readonly, optional, or selecting/omitting specific properties, among other operations. Mapped types are about type-level transformations rather than runtime operations."
        },
        {
          "question": "Which keyword is used to iterate over the properties of a type in a mapped type definition?",
          "options": ["for...in", "keyof", "typeof", "instanceof"],
          "correctAnswer": 1,
          "explanation": "The `keyof` keyword is used in mapped types to iterate over the property keys of a type. The syntax `[P in keyof T]` means \"for each property key `P` in the set of keys of type `T`...\". This allows you to apply transformations to each property of the original type."
        },
        {
          "question": "Which built-in utility type in TypeScript is created using mapped types to make all properties of a type optional?",
          "options": ["Readonly<T>", "Required<T>", "Partial<T>", "Pick<T, K>"],
          "correctAnswer": 2,
          "explanation": "The `Partial<T>` utility type in TypeScript is implemented using mapped types to make all properties of a type `T` optional. It transforms each property of `T` to be optional by adding the `?` modifier. This is a common use case for mapped types, demonstrating their power in creating reusable type transformations."
        }
      ]
    },
    {
      "id": "conditional-types",
      "title": "Conditional Types",
      "description": "Conditional types in TypeScript allow you to express type relationships that depend on conditions, similar to ternary conditional expressions in JavaScript. They enable you to define types that are resolved based on whether a type satisfies a certain condition. Conditional types add significant power and flexibility to TypeScript's type system, allowing for complex type logic and transformations.",
      "difficulty": "advanced",
      "category": "advanced-types",
      "explanation": "Conditional types are one of the most advanced features in TypeScript's type system. They enable you to create types that are determined by conditions expressed in terms of other types. The basic structure of a conditional type is `T extends U ? X : Y`, meaning if type `T` is assignable to type `U`, then the resulting type is `X`; otherwise, it's `Y`. This allows for creating types that dynamically adapt based on type relationships, enabling complex type transformations and type-level logic. Conditional types are fundamental for creating advanced utility types and solving intricate type challenges, especially in library and framework development.",
      "example": "// Basic conditional type: Determine type based on whether T extends string\ntype StringOrNumber<T> = T extends string ? string : number;\n\n// If we use string, it resolves to string\ntype StringResult = StringOrNumber<string>; // string\n// If we use number, it resolves to number\ntype NumberResult = StringOrNumber<number>; // number\n// If we use boolean, it resolves to number (because boolean does not extend string)\ntype BooleanResult = StringOrNumber<boolean>; // number\n\n// Conditional type with distributive property over union types\ntype ToArray<T> = T extends any ? T[] : T[]; // Distributive conditional type\n\n// For a union type, it distributes over each member\ntype StringOrNumberArray = ToArray<string | number>; // string[] | number[]\n\n// Without distributive property (using never to prevent distribution, less common)\ntype NonDistributiveToArray<T> = [T] extends [any] ? T[] : T[];\ntype NonDistributiveUnionArray = NonDistributiveToArray<string | number>; // (string | number)[]\n\n// Inferring within conditional types using 'infer' keyword\ntype ReturnType<T extends (...args: any) => any> = T extends (...args: any) => infer R ? R : any;\n\nfunction add(x: number, y: number): number {\n  return x + y;\n}\n\ntype AddReturnType = ReturnType<typeof add>; // Infers the return type of 'add', which is number\n\nfunction greet(name: string): string {\n  return `Hello, ${name}!`;\n}\n\ntype GreetReturnType = ReturnType<typeof greet>; // Infers the return type of 'greet', which is string\n\n// Example: Exclude null and undefined from a type\ntype NonNullable<T> = T extends null | undefined ? never : T;\n\ntype MaybeString = string | null | undefined;\ntype StringOnly = NonNullable<MaybeString>; // string",
      "keyPoints": [
        "Conditional types express type relationships based on conditions using `T extends U ? X : Y` syntax.",
        "They allow for type-level logic and transformations based on type compatibility.",
        "Conditional types can be distributive over union types unless prevented.",
        "The `infer` keyword allows for type inference within the 'true' branch of a conditional type, capturing parts of a type.",
        "Conditional types are used to create advanced utility types and solve complex type challenges.",
        "They enable highly flexible and adaptable type definitions, enhancing TypeScript's type system expressiveness."
      ],
      "quiz": [
        {
          "question": "What is the basic structure of a conditional type in TypeScript?",
          "options": ["`if (T extends U) { return X; } else { return Y; }`", "`T extends U ? X : Y`", "`switch (T) { case U: return X; default: return Y; }`", "`Conditional<T, U, X, Y>`"],
          "correctAnswer": 1,
          "explanation": "The basic structure of a conditional type in TypeScript is `T extends U ? X : Y`. This syntax is similar to a ternary conditional expression in JavaScript, but it operates at the type level. It checks if type `T` is assignable to type `U`. If true, the resulting type is `X`; otherwise, it's `Y`."
        },
        {
          "question": "What does the `infer` keyword do within a conditional type?",
          "options": ["It infers the type of a variable at runtime.", "It allows for type inference within the 'true' branch of a conditional type, capturing parts of a type.", "It forces TypeScript to use type inference instead of explicit type annotations.", "It disables type inference within the conditional type."],
          "correctAnswer": 1,
          "explanation": "The `infer` keyword in conditional types allows you to declare a type variable within the 'true' branch of a conditional type. TypeScript then tries to infer a type for this variable based on the type being checked (`T extends U`). This inferred type can then be used in the 'true' branch (`X`) of the conditional type, enabling powerful type transformations and extractions, such as extracting the return type of a function."
        },
        {
          "question": "Consider the conditional type `type Example<T> = T extends string ? string : number;`. If you use `Example<\"hello\">`, what will be the resulting type?",
          "options": ["number", "boolean", "string", "any"],
          "correctAnswer": 2,
          "explanation": "Given the conditional type `type Example<T> = T extends string ? string : number;`, when you use `Example<\"hello\">`, TypeScript checks if the literal type `\"hello\"` (which is a subtype of `string`) extends `string`. Since it does, the 'true' branch is taken, and the resulting type is `string`. Therefore, `Example<\"hello\">` resolves to `string`."
        }
      ]
    },
    {
      "id": "modules-namespaces",
      "title": "Modules and Namespaces",
      "description": "Modules and namespaces in TypeScript are used to organize code and avoid naming collisions. Modules (using `export` and `import`) are the modern standard for code organization, while namespaces (using `namespace`) are an older approach for creating logical groupings within your code.",
      "difficulty": "beginner",
      "category": "fundamentals",
      "explanation": "Modules and namespaces help in structuring TypeScript applications by encapsulating code and preventing pollution of the global scope. Modules are based on file-based modularity, where each file is treated as a module and variables, functions, classes, etc., are scoped to that module unless explicitly exported. Namespaces, on the other hand, are declared within a single file or across multiple files to group related code under a common name. Modules are generally preferred for modern TypeScript development as they align with ECMAScript module standards and offer better tooling support and clearer separation of concerns. Namespaces can still be useful for organizing code within smaller projects or for migrating legacy JavaScript code.",
      "example": "// --- Module Example (module.ts) ---\nexport function greet(name: string) {\n  return `Hello, ${name}!`;\n}\n\nexport const message = \"Welcome to modules!\";\n\n// --- Another Module Example (app.ts) ---\nimport { greet, message } from './module';\n\nconsole.log(greet(\"Alice\"));\nconsole.log(message);\n\n// --- Namespace Example (namespace.ts) ---\nnamespace StringUtils {\n  export function toUpper(str: string): string {\n    return str.toUpperCase();\n  }\n  export function toLower(str: string): string {\n    return str.toLowerCase();\n  }\n}\n\nconsole.log(StringUtils.toUpper(\"hello\"));\nconsole.log(StringUtils.toLower(\"WORLD\"));",
      "keyPoints": [
        "Modules (`export`/`import`) are file-based and the standard for code organization in TypeScript.",
        "Namespaces (`namespace`) provide a way to group code logically within a global scope, but are less preferred for new projects.",
        "Modules promote better encapsulation and avoid global scope pollution.",
        "Modules align with ECMAScript module standards.",
        "Namespaces can be used to organize code or for legacy JavaScript migration.",
        "Use modules for modern, scalable TypeScript applications."
      ],
      "quiz": [
        {
          "question": "Which keyword is used to make a variable or function accessible outside of a TypeScript module?",
          "options": ["public", "namespace", "export", "module"],
          "correctAnswer": 2,
          "explanation": "The `export` keyword in TypeScript is used to make variables, functions, classes, interfaces, etc., accessible from outside the module where they are defined. This is fundamental for creating reusable and modular code."
        },
        {
          "question": "What is the primary advantage of using modules over namespaces in TypeScript for modern projects?",
          "options": ["Modules are simpler to declare.", "Modules prevent naming collisions and offer better encapsulation.", "Namespaces are more compatible with JavaScript.", "Namespaces offer better performance."],
          "correctAnswer": 1,
          "explanation": "Modules provide better encapsulation by creating file-level scopes, which naturally prevent naming collisions and help in organizing code into independent units. This leads to more maintainable and scalable applications compared to namespaces, which operate within the global scope (or a named scope within it)."
        },
        {
          "question": "How do you import members from a module in TypeScript?",
          "options": ["Using the `include` keyword.", "Using the `require` keyword.", "Using the `import` keyword.", "Using the `namespace` keyword."],
          "correctAnswer": 2,
          "explanation": "The `import` keyword is used in TypeScript to bring in members (variables, functions, classes, interfaces, etc.) that have been exported from another module. This allows you to reuse code from different parts of your application in a modular and organized way."
        }
      ]
    },
    {
      "id": "declaration-files",
      "title": "Declaration Files (.d.ts)",
      "description": "Declaration files in TypeScript (`.d.ts`) are used to provide type information about existing JavaScript code, such as libraries or modules, without rewriting the JavaScript code itself. They describe the shape of JavaScript APIs for TypeScript's type checker.",
      "difficulty": "intermediate",
      "category": "fundamentals",
      "explanation": "Declaration files are essential for using JavaScript libraries in TypeScript projects. They allow TypeScript to understand the types and structure of JavaScript code, enabling type checking and autocompletion even for libraries written in plain JavaScript. A `.d.ts` file typically contains interface, type alias, class, function, and variable declarations, but no implementation. TypeScript uses these files to provide type safety when you import and use JavaScript modules. They bridge the gap between dynamically typed JavaScript and statically typed TypeScript, making it possible to integrate existing JavaScript ecosystems into TypeScript projects seamlessly. Declaration files can be created manually or often are provided by the library authors themselves (e.g., DefinitelyTyped repository for community-maintained declarations).",
      "example": "// --- Example Declaration File (mylibrary.d.ts) ---\ndeclare module 'mylibrary' {\n  export function libraryFunction(name: string): string;\n  export interface LibraryOptions {\n    optionA: boolean;\n    optionB?: number;\n  }\n  export const libraryVersion: string;\n}\n\n// --- Example JavaScript Library (mylibrary.js) ---\n// This is just plain JavaScript, no types here\nexport function libraryFunction(name) {\n  return \"Library says hello to \" + name;\n}\n\nexport const libraryVersion = \"1.0.0\";\n\n// --- Example TypeScript Usage (app.ts) ---\nimport { libraryFunction, libraryVersion, LibraryOptions } from 'mylibrary';\n\nconsole.log(libraryFunction(\"TypeScript User\"));\nconsole.log(\"Library version:\", libraryVersion);\n\nlet options: LibraryOptions = { optionA: true }; // Type-safe usage thanks to .d.ts",
      "keyPoints": [
        "Declaration files (`.d.ts`) describe the types of JavaScript code for TypeScript.",
        "They enable type checking and autocompletion for JavaScript libraries in TypeScript projects.",
        "`.d.ts` files contain only type declarations (interfaces, types, function signatures) without implementation.",
        "They bridge the gap between JavaScript and TypeScript, allowing integration of JavaScript libraries.",
        "Declaration files can be manually created or obtained from sources like DefinitelyTyped.",
        "Essential for type safety when using JavaScript libraries in TypeScript."
      ],
      "quiz": [
        {
          "question": "What is the file extension for TypeScript declaration files?",
          "options": [".ts", ".js", ".d.ts", ".tsx"],
          "correctAnswer": 2,
          "explanation": "TypeScript declaration files use the `.d.ts` file extension. This extension signals to the TypeScript compiler that the file contains type declarations rather than executable code, and is used to describe the types of JavaScript libraries or modules."
        },
        {
          "question": "What is the main purpose of declaration files?",
          "options": ["To convert TypeScript code to JavaScript.", "To provide type information for existing JavaScript code.", "To improve the runtime performance of TypeScript applications.", "To create executable JavaScript code."],
          "correctAnswer": 1,
          "explanation": "The primary purpose of declaration files is to provide type information for existing JavaScript code. This allows TypeScript projects to use JavaScript libraries and modules with type safety, enabling compile-time checks and better tooling support."
        },
        {
          "question": "Do declaration files contain the implementation of functions and classes?",
          "options": ["Yes, they contain both type declarations and implementation.", "No, they only contain type declarations, not implementation.", "Only for external JavaScript libraries.", "Only for internal modules within a TypeScript project."],
          "correctAnswer": 1,
          "explanation": "Declaration files (`.d.ts`) do not contain the implementation of functions or classes. They solely consist of type declarations, such as interfaces, type aliases, and function signatures. The actual implementation resides in the corresponding JavaScript files (`.js`)."
        }
      ]
    },
    {
      "id": "decorators",
      "title": "Decorators",
      "description": "Decorators in TypeScript provide a way to add annotations and meta-programming syntax for class declarations and members. They are functions that can modify classes, methods, properties, or parameters at design time.",
      "difficulty": "advanced",
      "category": "advanced-types",
      "explanation": "Decorators are a powerful feature in TypeScript, inspired by patterns in languages like Python and Java. They use the `@expression` syntax to attach metadata or modify the behavior of classes, methods, accessors, properties, and parameters. Decorators are essentially functions that are called with information about the decorated declaration. They can be used for various purposes, such as logging, validation, dependency injection, and aspect-oriented programming. Decorators enhance code readability and maintainability by separating cross-cutting concerns from the core logic of classes and their members. They are a stage 2 ECMAScript proposal and are a significant feature for framework and library development in TypeScript.",
      "example": "// Class Decorator\nfunction sealed(constructor: Function) {\n  Object.seal(constructor);\n  Object.seal(constructor.prototype);\n}\n\n@sealed\nclass Greeter {\n  greeting: string;\n  constructor(message: string) {\n    this.greeting = message;\n  }\n  greet() {\n    return \"Hello, \" + this.greeting;\n  }\n}\n\n// Method Decorator\nfunction logMethod(target: any, propertyKey: string, descriptor: PropertyDescriptor) {\n  const originalMethod = descriptor.value;\n  descriptor.value = function (...args: any[]) {\n    console.log(`Calling method: ${propertyKey} with arguments:`, args);\n    const result = originalMethod.apply(this, args);\n    console.log(`Method ${propertyKey} returned:`, result);\n    return result;\n  };\n  return descriptor;\n}\n\nclass Calculator {\n  @logMethod\n  add(a: number, b: number): number {\n    return a + b;\n  }\n}\n\nlet calc = new Calculator();\ncalc.add(5, 3);",
      "keyPoints": [
        "Decorators use `@expression` syntax to annotate and modify class declarations and members.",
        "They are functions that can alter the behavior of classes, methods, properties, and parameters.",
        "Decorators can be used for logging, validation, dependency injection, and AOP.",
        "Class decorators are applied to class constructors.",
        "Method decorators are applied to method descriptors.",
        "TypeScript decorators are a stage 2 ECMAScript proposal."
      ],
      "quiz": [
        {
          "question": "What is the syntax for applying a decorator in TypeScript?",
          "options": ["`#decoratorName`", "`$decoratorName`", "`@decoratorName`", "`^decoratorName`"],
          "correctAnswer": 2,
          "explanation": "Decorators in TypeScript are applied using the `@decoratorName` syntax, placed immediately before the declaration of a class, method, property, parameter, or accessor that you want to decorate."
        },
        {
          "question": "What can class decorators be used for?",
          "options": ["To modify instances of a class at runtime.", "To add metadata to class properties.", "To seal a class to prevent further modifications.", "To define the inheritance hierarchy of classes."],
          "correctAnswer": 2,
          "explanation": "Class decorators can be used to modify the class constructor. For example, they can be used to seal the constructor and its prototype using `Object.seal()`, preventing further additions or removals of properties. They operate on the class level, not instances directly."
        },
        {
          "question": "What type of declaration can method decorators be applied to?",
          "options": ["Class declarations", "Function declarations", "Method definitions within classes", "Interface declarations"],
          "correctAnswer": 2,
          "explanation": "Method decorators in TypeScript are applied to method definitions within classes. They can intercept and modify the method descriptor, allowing you to alter the method's behavior, such as logging arguments and return values, as demonstrated in the example."
        }
      ]
    },
    {
      "id": "mixins",
      "title": "Mixins",
      "description": "Mixins in TypeScript (and JavaScript) are a pattern for code reuse where functionalities are composed into a class by mixing in traits or behaviors from multiple sources, without relying on traditional class inheritance.",
      "difficulty": "advanced",
      "category": "advanced-types",
      "explanation": "Mixins offer a flexible way to build up classes by combining functionalities from reusable components. Unlike classical inheritance, which creates a rigid hierarchy, mixins allow you to 'mix in' properties and methods from multiple 'mixin classes' or objects into a target class. This is particularly useful in JavaScript and TypeScript, where single inheritance is the norm. Mixins help in avoiding the 'diamond problem' and enable more composable and reusable code. In TypeScript, mixins are typically implemented using class factories or composition patterns, often involving intersection types and generics to ensure type safety and flexibility.",
      "example": "// Mixin classes\nclass Disposable {\n  isDisposed: boolean = false;\n  dispose() {\n    this.isDisposed = true;\n  }\n}\n\nclass Activatable {\n  isActive: boolean = false;\n  activate() {\n    this.isActive = true;\n  }\n  deactivate() {\n    this.isActive = false;\n  }\n}\n\n// Function to apply mixins\nfunction applyMixins(derivedCtor: any, baseCtors: any[]) {\n  baseCtors.forEach(baseCtor => {\n    Object.getOwnPropertyNames(baseCtor.prototype).forEach(name => {\n      Object.defineProperty(derivedCtor.prototype, name, Object.getOwnPropertyDescriptor(baseCtor.prototype, name) ||\n        Object.create(null));\n    });\n  });\n}\n\n// Class to apply mixins to\nclass MyComponent implements Disposable, Activatable {\n  // Disposable properties and methods will be here after mixin\n  isDisposed!: boolean;\n  dispose!: () => void;\n  // Activatable properties and methods will be here after mixin\n  isActive!: boolean;\n  activate!: () => void;\n  deactivate!: () => void;\n\n  constructor() {\n    // Apply mixins\n    applyMixins(MyComponent, [Disposable, Activatable]);\n  }\n  render() {\n    console.log(\"Component rendered, isDisposed:\", this.isDisposed, \", isActive:\", this.isActive);\n  }\n}\n\nconst component = new MyComponent();\ncomponent.activate();\ncomponent.render();\ncomponent.dispose();\ncomponent.render();",
      "keyPoints": [
        "Mixins are a pattern for code reuse by composing functionalities from multiple sources.",
        "They provide an alternative to classical inheritance, offering more flexibility.",
        "Mixins help avoid the 'diamond problem' and promote code composability.",
        "Implemented using class factories or composition, often with intersection types.",
        "Enable combining behaviors from different 'mixin classes' into a single class.",
        "Useful in JavaScript and TypeScript for single inheritance environments."
      ],
      "quiz": [
        {
          "question": "What problem do mixins primarily solve in object-oriented programming?",
          "options": ["Memory leaks in inheritance hierarchies.", "The 'diamond problem' and rigidness of classical inheritance.", "Complexity of constructor chaining in subclasses.", "Lack of support for interfaces in JavaScript."],
          "correctAnswer": 1,
          "explanation": "Mixins primarily address the limitations and complexities of classical inheritance, especially the 'diamond problem' (ambiguity in multiple inheritance) and the rigidity of deep inheritance hierarchies. They offer a more flexible and composable way to reuse code."
        },
        {
          "question": "How do mixins differ from traditional class inheritance?",
          "options": ["Mixins establish a strict 'is-a' relationship, while inheritance is more about 'has-a'.", "Mixins compose functionalities horizontally, while inheritance creates a vertical hierarchy.", "Mixins are only applicable to functional programming, while inheritance is for object-oriented.", "Mixins are a runtime feature, while inheritance is a compile-time feature."],
          "correctAnswer": 1,
          "explanation": "Mixins allow for horizontal composition of functionalities, meaning you can combine features from different sources into a class without creating a deep, rigid hierarchy. Inheritance, on the other hand, establishes a vertical 'is-a' relationship, which can sometimes lead to inflexibility and the diamond problem in multiple inheritance scenarios."
        },
        {
          "question": "What are common implementation techniques for mixins in TypeScript?",
          "options": ["Using interfaces and abstract classes.", "Using class factories, composition patterns, and intersection types.", "Using decorators exclusively.", "Using enums and type aliases."],
          "correctAnswer": 1,
          "explanation": "In TypeScript, mixins are commonly implemented using class factories, composition patterns, and intersection types. These techniques allow you to dynamically combine properties and methods from mixin classes into a target class while maintaining type safety and flexibility. Decorators can sometimes be used in conjunction with mixins but are not the primary implementation technique for mixins themselves."
        }
      ]
    },
    {
      "id": "type-parameters-in-classes",
      "title": "Type Parameters in Classes (Generic Classes)",
      "description": "Generic classes in TypeScript use type parameters to create classes that can work with a variety of types while maintaining type safety. They allow you to define classes that are parameterized by types, similar to generic functions and interfaces.",
      "difficulty": "intermediate",
      "category": "advanced-types",
      "explanation": "Generic classes extend the concept of generics to class definitions. They enable you to create classes where the type of certain properties or method parameters is not specified until an instance of the class is created. This is achieved through type parameters, typically denoted by `<T>`, `<U>`, etc., which act as placeholders for actual types. Generic classes enhance code reusability and type safety by allowing you to write classes that can operate on different data types without losing type information. They are commonly used in data structures, collections, and utility classes where the specific type of data being handled is not predetermined.",
      "example": "// Generic class definition\nclass GenericContainer<T> {\n  private items: T[] = [];\n\n  addItem(item: T): void {\n    this.items.push(item);\n  }\n\n  getItems(): T[] {\n    return this.items;\n  }\n}\n\n// Using GenericContainer with number\nlet numberContainer = new GenericContainer<number>();\nnumberContainer.addItem(10);\nnumberContainer.addItem(20);\n// numberContainer.addItem(\"string\"); // Error: Argument of type 'string' is not assignable to parameter of type 'number'.\nconsole.log(\"Number container items:\", numberContainer.getItems());\n\n// Using GenericContainer with string\nlet stringContainer = new GenericContainer<string>();\nstringContainer.addItem(\"apple\");\nstringContainer.addItem(\"banana\");\nconsole.log(\"String container items:\", stringContainer.getItems());\n\n// Generic class with multiple type parameters\nclass KeyValueStore<K, V> {\n  private keys: K[] = [];\n  private values: V[] = [];\n\n  add(key: K, value: V): void {\n    this.keys.push(key);\n    this.values.push(value);\n  }\n\n  getKeys(): K[] {\n    return this.keys;\n  }\n\n  getValues(): V[] {\n    return this.values;\n  }\n}\n\nlet store = new KeyValueStore<string, number>();\nstore.add(\"age\", 30);\nstore.add(\"count\", 100);\nconsole.log(\"Store keys:\", store.getKeys());\nconsole.log(\"Store values:\", store.getValues());",
      "keyPoints": [
        "Generic classes use type parameters (e.g., `<T>`) to define classes parameterized by types.",
        "Type parameters act as placeholders for actual types specified when creating class instances.",
        "Generic classes enhance code reusability and type safety for classes.",
        "They are useful for data structures, collections, and utility classes.",
        "Multiple type parameters can be used in a single class definition (e.g., `<K, V>`).",
        "Type constraints can be applied to type parameters in generic classes."
      ],
      "quiz": [
        {
          "question": "What is the purpose of type parameters in generic classes?",
          "options": ["To define static properties of a class.", "To specify the access modifiers of class members.", "To create classes that can work with multiple types while maintaining type safety.", "To enable runtime type checking in classes."],
          "correctAnswer": 2,
          "explanation": "Type parameters in generic classes allow you to create classes that are flexible enough to work with various types of data without sacrificing type safety. They act as placeholders for types that will be specified when an instance of the generic class is created."
        },
        {
          "question": "How are type parameters typically denoted in TypeScript generic classes?",
          "options": ["Using curly braces `{}`.", "Using square brackets `[]`.", "Using angle brackets `<>`.", "Using parentheses `()`."],
          "correctAnswer": 2,
          "explanation": "Type parameters in TypeScript, including in generic classes, are denoted using angle brackets `<>`. For example, `class GenericClass<T> { ... }` declares a generic class named `GenericClass` with a type parameter `T`."
        },
        {
          "question": "Can you use multiple type parameters in a generic class?",
          "options": ["No, generic classes can only have one type parameter.", "Yes, you can define multiple type parameters separated by commas (e.g., `<K, V>`).", "Only if the class extends another generic class.", "Only for classes that implement generic interfaces."],
          "correctAnswer": 1,
          "explanation": "Yes, TypeScript allows you to define generic classes with multiple type parameters. These are specified within the angle brackets, separated by commas, such as `<K, V>` in `class KeyValueStore<K, V> { ... }`. This enables classes to be generic over multiple types, enhancing their flexibility and reusability."
        }
      ]
    },
    {
      "id": "type-predicates",
      "title": "Type Predicates",
      "description": "Type predicates in TypeScript are function return types that narrow down the type of a variable based on the function's return value. They are used in custom type guard functions to inform the TypeScript compiler about type narrowing within conditional blocks.",
      "difficulty": "intermediate",
      "category": "advanced-types",
      "explanation": "Type predicates are a specific form of type annotation for function return types that tell TypeScript the type of a value within a certain scope after the function returns true. A type predicate has the form `parameterName is Type`, where `parameterName` must be the name of a parameter of the function. When a function with a type predicate return type returns true, TypeScript understands that the parameter passed to the function is of the specified `Type` within the `if` block or similar conditional context. Type predicates are crucial for creating custom type guard functions, enabling more sophisticated type narrowing than built-in type guards like `typeof` and `instanceof`.",
      "example": "// Interface definitions\ninterface Bird {\n  fly(): void;\n  layEggs(): void;\n}\n\ninterface Fish {\n  swim(): void;\n  layEggs(): void;\n}\n\n// Custom type guard function with type predicate\nfunction isBird(pet: Bird | Fish): pet is Bird {\n  return (pet as Bird).fly !== undefined; // Heuristic to identify a Bird\n}\n\nfunction petAction(pet: Bird | Fish) {\n  pet.layEggs(); // Safe, common to both Bird and Fish\n  if (isBird(pet)) { // Type guard with type predicate\n    pet.fly();     // Safe to call fly(), TypeScript knows 'pet' is Bird here\n  } else {         // TypeScript infers 'pet' must be Fish here\n    pet.swim();    // Safe to call swim(), TypeScript knows 'pet' is Fish here\n  }\n}\n\n// Example usage\nconst myBird = { fly: () => console.log(\"Flying\"), layEggs: () => console.log(\"Bird eggs\") };\nconst myFish = { swim: () => console.log(\"Swimming\"), layEggs: () => console.log(\"Fish eggs\") };\n\npetAction(myBird);\npetAction(myFish);\n\n// Type predicate example with class\nclass Circle {\n  radius: number;\n  constructor(radius: number) { this.radius = radius; }\n  getArea() { return Math.PI * this.radius * this.radius; }\n}\n\nclass Square {\n  sideLength: number;\n  constructor(sideLength: number) { this.sideLength = sideLength; }\n  getArea() { return this.sideLength * this.sideLength; }\n}\n\ntype Shape = Circle | Square;\n\nfunction isCircle(shape: Shape): shape is Circle {\n  return (shape as Circle).radius !== undefined;\n}\n\nfunction printShapeArea(shape: Shape) {\n  if (isCircle(shape)) {\n    console.log(\"Circle area:\", shape.getArea()); // 'shape' is Circle here\n  } else {\n    console.log(\"Square area:\", shape.getArea()); // 'shape' is Square here\n  }\n}",
      "keyPoints": [
        "Type predicates are function return types of the form `parameterName is Type`.",
        "They are used in custom type guard functions to narrow down types.",
        "When a function with a type predicate returns true, TypeScript narrows the type of the parameter.",
        "Type predicates enable more sophisticated type narrowing beyond `typeof` and `instanceof`.",
        "They are essential for creating custom type guards for complex type conditions.",
        "Enhance type safety and code readability when working with union types."
      ],
      "quiz": [
        {
          "question": "What is the syntax for a type predicate return type in TypeScript?",
          "options": ["`: Type`", "`: boolean`", "`: parameterName of Type`", "`: parameterName is Type`"],
          "correctAnswer": 3,
          "explanation": "The syntax for a type predicate return type is `: parameterName is Type`, where `parameterName` is the name of a parameter of the function and `Type` is the type to which you are narrowing down the parameter within a conditional block if the function returns `true`."
        },
        {
          "question": "What does a function with a type predicate return type achieve?",
          "options": ["It converts a value to the specified type at runtime.", "It performs runtime type checking.", "It informs the TypeScript compiler about type narrowing based on the function's return value.", "It throws an error if the type is not as predicated."],
          "correctAnswer": 2,
          "explanation": "A function with a type predicate return type informs the TypeScript compiler about type narrowing. When such a function returns `true`, TypeScript understands that within the scope where the function is called and returns `true`, the specified parameter is of the asserted type. This is purely a compile-time construct for type safety."
        },
        {
          "question": "In `function isStringArray(value: any): value is string[]`, what is `value is string[]`?",
          "options": ["A type assertion.", "A type predicate.", "A type alias.", "A generic type constraint."],
          "correctAnswer": 1,
          "explanation": "`value is string[]` in the function signature `function isStringArray(value: any): value is string[]` is a type predicate. It indicates that if `isStringArray(value)` returns `true`, then TypeScript should treat `value` as being of type `string[]` within the relevant conditional scope. This is the defining characteristic of a type predicate."
        }
      ]
    },
    {
      "id": "index-signatures",
      "title": "Index Signatures",
      "description": "Index signatures in TypeScript allow you to define the type of properties in an object when you don't know the property names in advance. They are useful for working with dynamic data structures like dictionaries or maps where keys are not known at compile time.",
      "difficulty": "intermediate",
      "category": "advanced-types",
      "explanation": "Index signatures are a feature in TypeScript that enables you to describe the shape of objects where property names are not fixed but are dynamically determined. They are particularly useful for representing data structures like dictionaries, maps, or records where you want to enforce a consistent type for all properties, regardless of their names. An index signature is defined within an interface or type alias using the syntax `[indexName: indexType]: valueType;`. Here, `indexName` is a name for the index (like a parameter name), `indexType` must be either `string`, `number`, or `symbol`, and `valueType` is the type of the properties accessed via that index.",
      "example": "// Index signature for string keys and number values (dictionary-like)\ninterface NumberDictionary {\n  [index: string]: number; // Index signature: string index, number value\n}\n\nlet ages: NumberDictionary = {\n  \"Alice\": 30,\n  \"Bob\": 25,\n  \"Charlie\": 35\n};\n\nages[\"David\"] = 40; // OK\n// ages[\"Eve\"] = \"forty\"; // Error: Type 'string' is not assignable to type 'number'.\n\nfunction getAge(dict: NumberDictionary, name: string): number {\n  return dict[name]; // Accessing property via index signature\n}\n\nconsole.log(\"Alice's age:\", getAge(ages, \"Alice\"));\n\n// Index signature for number keys and string values (array-like, but keys are strings)\ninterface StringArrayLike {\n  [index: number]: string; // Index signature: number index, string value\n}\n\nlet namesArrayLike: StringArrayLike = {\n  0: \"First\",\n  1: \"Second\",\n  2: \"Third\"\n};\n\nconsole.log(\"Element at index 1:\", namesArrayLike[1]);\n\n// Combining index signature with known properties\ninterface Config {\n  apiUrl: string;\n  [key: string]: string; // Index signature: any string key, string value\n}\n\nlet appConfig: Config = {\n  apiUrl: \"https://api.example.com\",\n  theme: \"dark\",\n  language: \"en\"\n};\n\nconsole.log(\"API URL:\", appConfig.apiUrl);\nconsole.log(\"Theme:\", appConfig.theme);",
      "keyPoints": [
        "Index signatures define the type of properties in objects with dynamic keys.",
        "Syntax: `[indexName: indexType]: valueType;` within interfaces or type aliases.",
        "`indexType` must be `string`, `number`, or `symbol`. `valueType` can be any type.",
        "Useful for dictionaries, maps, and dynamic data structures.",
        "Allows type checking for dynamically accessed properties.",
        "Can be combined with known properties in the same type definition."
      ],
      "quiz": [
        {
          "question": "What is the purpose of index signatures in TypeScript interfaces?",
          "options": ["To define the order of properties in an object.", "To specify the type of properties when property names are not known in advance.", "To create index-based arrays.", "To define static properties of an interface."],
          "correctAnswer": 1,
          "explanation": "Index signatures are used to define the type of properties in objects where the property names are not fixed or known at compile time. They are essential for describing the shape of dynamic objects like dictionaries or maps, ensuring type safety for dynamically accessed properties."
        },
        {
          "question": "Which types are allowed for the `indexType` in an index signature?",
          "options": ["`string` and `number` only.", "`string`, `number`, and `boolean`.", "`string`, `number`, and `symbol`.", "Any primitive type."],
          "correctAnswer": 2,
          "explanation": "The `indexType` in an index signature is restricted to `string`, `number`, or `symbol`. These are the types that can be used as keys in JavaScript objects. `boolean` or other primitive types are not valid for `indexType`."
        },
        {
          "question": "Consider `interface Dictionary { [key: string]: number; }`. What does this index signature indicate?",
          "options": ["The interface `Dictionary` can only have string properties.", "Properties of `Dictionary` can be accessed using string indices.", "All properties of `Dictionary` must have keys of type string and values of type number.", "`Dictionary` is an array-like interface with string indices and number values."],
          "correctAnswer": 2,
          "explanation": "The index signature `[key: string]: number;` in the interface `Dictionary` indicates that for any string key (`key`) in an object of type `Dictionary`, the corresponding value must be of type `number`. It defines a dictionary-like structure where keys are strings and values are numbers, and allows for any string to be used as a property name."
        }
      ]
    },
    {
      "id": "utility-types-omit-required-record",
      "title": "Utility Types: Omit, Required, Record",
      "description": "TypeScript utility types are built-in type transformations that make common type manipulations easier and more declarative. `Omit<T, K>`, `Required<T>`, and `Record<K, T>` are examples that provide powerful ways to create new types based on existing ones.",
      "difficulty": "advanced",
      "category": "advanced-types",
      "explanation": "Utility types in TypeScript are pre-defined type operations that are very helpful in type manipulation and code reuse. `Omit<T, K>` constructs a type by picking all properties from `T` and then removing `K` (which can be a string literal or union of string literals). `Required<T>` makes all properties in `T` required (removes `?` optional modifier). `Record<K, T>` constructs an object type whose property keys are `K` and property values are `T`. These utility types, built using mapped types and conditional types, significantly enhance type system expressiveness and reduce boilerplate in type definitions, making TypeScript type system more powerful and developer-friendly.",
      "example": "// Omit<T, K>: Exclude keys K from type T\ninterface Product {\n  id: number;\n  name: string;\n  description?: string;\n  price: number;\n}\n\ntype ProductPreview = Omit<Product, 'description' | 'price'>; // Removes 'description' and 'price'\n\nlet previewProduct: ProductPreview = {\n  id: 123,\n  name: \"Laptop\"\n  // description and price are omitted\n};\n\n// Required<T>: Make all properties in T required\ntype ProductDetailsRequired = Required<Product>; // Makes 'description' required\n\nlet detailedProduct: ProductDetailsRequired = {\n  id: 456,\n  name: \"Tablet\",\n  description: \"High-resolution display\", // Now required\n  price: 299\n};\n\n// Record<K, T>: Construct a type with keys K and values T\ntype StatusMap = Record<string, 'pending' | 'success' | 'error'>;\n\nlet taskStatuses: StatusMap = {\n  taskA: 'pending',\n  taskB: 'success',\n  taskC: 'error'\n};\n\ntaskStatuses['taskD'] = 'pending'; // OK, any string key with Status value\n// taskStatuses['taskE'] = 123;     // Error: Type '123' is not assignable to type '\"pending\" | \"success\" | \"error\"'.",
      "keyPoints": [
        "Utility types are built-in type transformations in TypeScript.",
        "`Omit<T, K>` creates a type by excluding properties `K` from `T`.",
        "`Required<T>` makes all properties of `T` required.",
        "`Record<K, T>` creates an object type with keys `K` and values `T`.",
        "These utility types are built using mapped and conditional types.",
        "Enhance type system expressiveness and reduce type definition boilerplate."
      ],
      "quiz": [
        {
          "question": "What does the utility type `Omit<T, K>` do?",
          "options": ["It makes properties of type `T` optional.", "It selects only properties `K` from type `T`.", "It removes properties `K` from type `T`.", "It renames properties `K` in type `T`."],
          "correctAnswer": 2,
          "explanation": "The `Omit<T, K>` utility type constructs a new type by taking all properties from type `T` and then removing the properties whose keys are listed in `K`. `K` is typically a union of string literal types representing property names to be omitted."
        },
        {
          "question": "What is the effect of applying the `Required<T>` utility type to an interface with optional properties?",
          "options": ["It makes all properties of the interface optional.", "It makes all properties of the interface required.", "It removes all optional properties from the interface.", "It does not change the interface; `Required<T>` is for classes only."],
          "correctAnswer": 1,
          "explanation": "The `Required<T>` utility type makes all properties of type `T` required. If `T` is an interface or type with some optional properties (marked with `?`), `Required<T>` will transform it into a type where all those properties are mandatory, effectively removing the optional modifier."
        },
        {
          "question": "For `Record<K, T>`, what do `K` and `T` represent?",
          "options": ["`K` is the type of values, and `T` is the type of keys.", "`K` is the type of keys, and `T` is the type of values.", "`K` and `T` both represent keys, but from different interfaces.", "`K` and `T` both represent values, but for different properties."],
          "correctAnswer": 1,
          "explanation": "In `Record<K, T>`, `K` represents the type of the keys of the object, and `T` represents the type of the values of the object. `Record<K, T>` constructs a type that is an object where all property keys are of type `K` and all property values are of type `T`."
        }
      ]
    },
    {
      "id": "tuple-types",
      "title": "Tuple Types",
      "description": "Tuple types in TypeScript are a specific kind of array type that allows you to define arrays with a fixed number of elements, where the type of each element at a specific position is known. Tuples are useful for representing ordered lists with heterogeneous types.",
      "difficulty": "beginner",
      "category": "fundamentals",
      "explanation": "Tuple types are a powerful feature in TypeScript that allows you to define array-like structures with a predefined number of elements and specific types at each index. Unlike regular arrays where all elements are typically of the same type, tuples can contain elements of different types. The order of types is important in tuples. Tuple types are declared using array-like syntax `[type1, type2, type3, ...]`. They are beneficial when you need to represent a fixed sequence of values where each value has a specific meaning and type, such as coordinates, RGB color values, or function return values that need to return multiple, differently typed values.",
      "example": "// Define a tuple type for RGB color\ntype RGBColor = [number, number, number]; // Red, Green, Blue values\n\nlet color: RGBColor = [255, 0, 0]; // Red color\n// let invalidColor: RGBColor = [255, 0, 0, 0]; // Error: Tuple type '[number, number, number]' of length '3' has no element at index '3'.\n// let wrongTypeColor: RGBColor = [\"red\", \"green\", \"blue\"]; // Error: Type 'string' is not assignable to type 'number'.\n\nconsole.log(\"Red component:\", color[0]);\nconsole.log(\"Green component:\", color[1]);\nconsole.log(\"Blue component:\", color[2]);\n\n// Tuple type with mixed types\ntype UserDetails = [number, string, boolean?]; // ID, name, isActive (optional)\n\nlet user1: UserDetails = [1, \"Alice\", true];\nlet user2: UserDetails = [2, \"Bob\"]; // Optional boolean is not required\n\nconsole.log(\"User ID:\", user1[0], \"Name:\", user1[1], \"Active:\", user1[2]);\nconsole.log(\"User ID:\", user2[0], \"Name:\", user2[1], \"Active:\", user2[2]); // Accessing optional element may be undefined\n\n// Tuple destructuring\nlet point: [number, number] = [10, 20];\nlet [x, y] = point; // Destructuring tuple into x and y\nconsole.log(\"x:\", x, \"y:\", y);",
      "keyPoints": [
        "Tuple types define arrays with a fixed number of elements and specific types at each position.",
        "Declared using array-like syntax: `[type1, type2, ...]`. Order of types matters.",
        "Can contain elements of different types (heterogeneous types).",
        "Useful for representing ordered lists with specific element meanings.",
        "Tuple destructuring allows easy access to tuple elements.",
        "Optional elements in tuples are indicated with `?` after the type (e.g., `[number, string, boolean?]`)."
      ],
      "quiz": [
        {
          "question": "How do tuple types differ from regular arrays in TypeScript?",
          "options": ["Tuples are mutable, while arrays are immutable.", "Tuples have a fixed length and element types, while arrays typically have elements of the same type and variable length.", "Tuples are used for objects, while arrays are for lists.", "There is no difference; 'tuple' and 'array' are interchangeable terms."],
          "correctAnswer": 1,
          "explanation": "Tuple types are distinct from regular arrays because tuples are defined with a fixed number of elements, and the type of each element at a specific position is known and specified. Regular arrays, on the other hand, usually contain elements of the same type and can have a variable number of elements."
        },
        {
          "question": "Which syntax is used to define a tuple type in TypeScript?",
          "options": ["`{type1, type2, ...}`", "`<type1, type2, ...>`", "`[type1, type2, ...]`", "`type(type1, type2, ...)`"],
          "correctAnswer": 2,
          "explanation": "Tuple types in TypeScript are defined using array-like syntax with square brackets `[]`, listing the types of elements in order: `[type1, type2, type3, ...]`. For example, `[number, string]` defines a tuple with two elements, the first being a number and the second a string."
        },
        {
          "question": "Can a tuple contain elements of different types?",
          "options": ["No, tuple elements must all be of the same type.", "Yes, tuples can contain elements of heterogeneous types.", "Only if the tuple is declared as 'any[]'.", "Only for tuples of length 2 or less."],
          "correctAnswer": 1,
          "explanation": "Yes, one of the key features of tuple types is that they can contain elements of different types at different positions. This is in contrast to typical arrays where elements are usually expected to be of the same type. Tuples are designed for situations where you need to represent a fixed sequence of values with varying types, such as coordinates (number, number) or user details (number, string, boolean)."
        }
      ]
    },
    {
      "id": "rest-parameters-spread-syntax-types",
      "title": "Rest Parameters and Spread Syntax in Types",
      "description": "Rest parameters and spread syntax in TypeScript, when combined with types, allow for flexible function argument handling and array/object manipulations while maintaining type safety. Rest parameters collect multiple arguments into an array, and spread syntax expands arrays or objects.",
      "difficulty": "beginner",
      "category": "fundamentals",
      "explanation": "Rest parameters and spread syntax are powerful features in JavaScript and TypeScript for working with function arguments and iterable data structures. Rest parameters, denoted by `...parameterName` in function parameter lists, allow a function to accept a variable number of arguments, which are collected into an array. Spread syntax (`...iterable`) has multiple uses: in function calls, it expands an iterable (like an array) into individual arguments; in array literals, it expands an iterable into array elements; and in object literals (in newer ECMAScript versions), it can spread properties from one object into another. When used in TypeScript, these features are type-safe, meaning you can specify the types of rest parameters and the types of elements being spread, ensuring that operations are type-correct.",
      "example": "// Rest parameters with type annotation (number[])\nfunction sumAllNumbers(...numbers: number[]): number {\n  return numbers.reduce((sum, num) => sum + num, 0);\n}\n\nconsole.log(\"Sum:\", sumAllNumbers(1, 2, 3, 4, 5));\n// console.log(\"Sum:\", sumAllNumbers(1, 2, \"3\")); // Error: Argument of type 'string' is not assignable to parameter of type 'number'.\n\n// Spread syntax in function calls\nfunction greetPeople(greeting: string, ...names: string[]): void {\n  names.forEach(name => console.log(`${greeting}, ${name}!`));\n}\n\nlet people = [\"Alice\", \"Bob\", \"Charlie\"];\ngreetPeople(\"Hello\", ...people); // Spreading array elements as arguments\n\n// Spread syntax in array literals\nlet parts = [\"shoulders\", \"knees\"];\nlet lyrics = [\"head\", ...parts, \"and\", \"toes\"]; // Spreading array into another array\nconsole.log(\"Lyrics:\", lyrics);\n\n// Spread syntax in object literals (property spreading)\nlet defaults = { color: \"red\", fontSize: 12 };\nlet userSettings = { ...defaults, fontSize: 16, fontWeight: \"bold\" }; // Overriding and adding properties\nconsole.log(\"User settings:\", userSettings);",
      "keyPoints": [
        "Rest parameters (`...parameterName`) allow functions to accept a variable number of arguments as an array.",
        "Spread syntax (`...iterable`) expands iterables into individual elements in function calls, array literals, and object literals.",
        "TypeScript provides type safety for rest parameters and spread syntax.",
        "Type annotations can be used to specify the types of rest parameters (e.g., `...numbers: number[]`).",
        "Spread syntax is versatile for manipulating arrays and objects in a type-safe manner.",
        "Rest parameters and spread syntax enhance function flexibility and code conciseness."
      ],
      "quiz": [
        {
          "question": "What is the purpose of rest parameters in TypeScript function definitions?",
          "options": ["To define default values for function parameters.", "To restrict the number of arguments a function can accept.", "To allow a function to accept a variable number of arguments, collected into an array.", "To specify that a parameter is optional."],
          "correctAnswer": 2,
          "explanation": "Rest parameters in TypeScript function definitions, indicated by `...parameterName`, enable a function to accept any number of arguments. These arguments are then gathered into an array, allowing the function to process a variable list of inputs."
        },
        {
          "question": "In TypeScript, what does the spread syntax (`...`) do when used in a function call with an array?",
          "options": ["It creates a copy of the array.", "It passes the array as a single argument.", "It expands the array elements into individual arguments.", "It reverses the order of elements in the array."],
          "correctAnswer": 2,
          "explanation": "When spread syntax (`...`) is used in a function call with an array, it expands the elements of the array and passes them as individual arguments to the function. This is useful when you have an array of values that you want to pass as separate arguments to a function that expects individual parameters."
        },
        {
          "question": "How can you specify the type of rest parameters in a TypeScript function?",
          "options": ["Using a type alias.", "Using a generic type.", "By annotating the rest parameter with an array type (e.g., `...args: string[]`).", "Rest parameters cannot be explicitly typed."],
          "correctAnswer": 2,
          "explanation": "You can specify the type of rest parameters in a TypeScript function by annotating the rest parameter with an array type. For example, `...args: string[]` indicates that the rest parameter `args` will be an array of strings. This ensures type safety for the arguments collected by the rest parameter."
        }
      ]
    },
    {
      "id": "type-compatibility",
      "title": "Type Compatibility",
      "description": "Type compatibility in TypeScript is based on structural typing (also known as duck typing). Two types are compatible if their members are compatible, regardless of their names or declarations. This contrasts with nominal typing found in languages like Java or C#.",
      "difficulty": "intermediate",
      "category": "advanced-types",
      "explanation": "TypeScript's type system is structurally typed, which means that type compatibility is determined by the shape or structure of types, rather than their names or explicit declarations. If two types have the same set of members (properties and methods) with compatible types, they are considered compatible, even if they are declared differently or have different names. This is different from nominal typing, where types are considered compatible only if they have the same name or are explicitly related through inheritance. Structural typing provides greater flexibility and is more aligned with JavaScript's dynamic nature. It allows for more intuitive type relationships and facilitates code reuse based on object shapes rather than class hierarchies. However, it can sometimes lead to unexpected type compatibility if you are not familiar with structural typing principles.",
      "example": "// Structural typing example\ninterface Point2D {\n  x: number;\n  y: number;\n}\n\ninterface Point3D {\n  x: number;\n  y: number;\n  z: number;\n}\n\nlet p2d: Point2D = { x: 10, y: 20 };\nlet p3d: Point3D = { x: 10, y: 20, z: 30 };\n\n// Point3D is structurally compatible with Point2D because it has at least all members of Point2D\np2d = p3d; // OK, Point3D can be assigned to Point2D\n// p3d = p2d; // Error: Property 'z' is missing in type 'Point2D' but required in type 'Point3D'.\n\nfunction printPoint(point: Point2D) {\n  console.log(`Point at (${point.x}, ${point.y})`);\n}\n\nprintPoint(p2d); // OK\nprintPoint(p3d); // OK, Point3D is compatible with Point2D for function parameter\n\n// Class compatibility (also structural)\nclass Animal {\n  feet: number;\n  constructor(feet: number) { this.feet = feet; }\n}\n\nclass Dog extends Animal {\n  bark() { console.log(\"Woof!\"); }\n}\n\nclass Cat {\n  feet: number;\n  meow() { console.log(\"Meow!\"); }\n}\n\nfunction petAnimal(animal: Animal) {\n  console.log(`Animal has ${animal.feet} feet.`);\n}\n\npetAnimal(new Dog(4)); // OK, Dog is structurally compatible with Animal\npetAnimal(new Cat(4)); // OK, Cat is structurally compatible with Animal (same 'feet' property)",
      "keyPoints": [
        "TypeScript uses structural typing for type compatibility (duck typing).",
        "Type compatibility is based on the structure (members) of types, not names.",
        "Two types are compatible if they have compatible members, regardless of declaration names.",
        "Structural typing is more flexible than nominal typing (e.g., Java, C#).",
        "Allows for more intuitive type relationships and code reuse.",
        "Can sometimes lead to unexpected compatibility if structural rules are not well understood."
      ],
      "quiz": [
        {
          "question": "What is the basis of type compatibility in TypeScript?",
          "options": ["Nominal typing.", "Structural typing.", "Inheritance hierarchy.", "Explicit type casting."],
          "correctAnswer": 1,
          "explanation": "TypeScript uses structural typing for determining type compatibility. This means that two types are considered compatible if they have the same shape or structure, i.e., if they have compatible members (properties and methods), regardless of their names or how they are declared."
        },
        {
          "question": "If type `A` and type `B` have the same structure (same properties and methods with compatible types), are they considered compatible in TypeScript?",
          "options": ["No, they are compatible only if they have the same name.", "Yes, they are considered compatible due to structural typing.", "Only if they are both classes.", "Only if they are both interfaces."],
          "correctAnswer": 1,
          "explanation": "Yes, in TypeScript, if type `A` and type `B` have the same structure (meaning they have the same set of properties and methods, and the types of corresponding members are compatible), they are considered structurally compatible. This is a core principle of TypeScript's structural type system."
        },
        {
          "question": "How does structural typing differ from nominal typing in terms of type compatibility?",
          "options": ["Structural typing relies on names, while nominal typing relies on structure.", "Nominal typing relies on names, while structural typing relies on structure.", "Structural typing is stricter than nominal typing.", "Nominal typing is used in JavaScript, while structural typing is used in TypeScript."],
          "correctAnswer": 1,
          "explanation": "Nominal typing (used in languages like Java and C#) determines type compatibility based on type names and explicit relationships (like inheritance). Structural typing (used in TypeScript) determines type compatibility based on the structure of types. In nominal typing, types are compatible if they have the same name or are in an inheritance hierarchy. In structural typing, types are compatible if they have compatible structures, regardless of their names or declarations."
        }
      ]
    },
    {
      "id": "ambient-declarations",
      "title": "Ambient Declarations",
      "description": "Ambient declarations in TypeScript are used to describe the shape of existing JavaScript environments or libraries that are not written in TypeScript. They inform the TypeScript compiler about global variables, modules, or external JavaScript code without providing implementation.",
      "difficulty": "intermediate",
      "category": "advanced-types",
      "explanation": "Ambient declarations are a way to tell the TypeScript compiler about JavaScript code that exists outside of your TypeScript project, such as browser APIs, Node.js globals, or external JavaScript libraries for which you might not have `.d.ts` files. They are declared using the `declare` keyword and do not include any implementation, only type signatures. Ambient declarations can describe global variables, functions, classes, modules, namespaces, and interfaces that are available in your runtime environment. They are essential for integrating TypeScript with existing JavaScript ecosystems and ensuring type safety when interacting with non-TypeScript code. Ambient declarations can be placed directly in your `.ts` files or, more commonly, in `.d.ts` declaration files.",
      "example": "// Ambient declaration for a global variable (e.g., from a JavaScript library)\ndeclare var LIBRARY_VERSION: string;\n\nconsole.log(\"Library version:\", LIBRARY_VERSION); // TypeScript now knows about LIBRARY_VERSION\n\n// Ambient declaration for a global function\ndeclare function externalFunction(param: string): void;\n\nexternalFunction(\"Hello from external function\"); // TypeScript knows externalFunction exists and its type\n\n// Ambient module declaration for a JavaScript module without .d.ts\ndeclare module 'legacy-js-module' {\n  export function doSomething(): string;\n  export const MODULE_CONSTANT: number;\n}\n\nimport { doSomething, MODULE_CONSTANT } from 'legacy-js-module';\nconsole.log(doSomething());\nconsole.log(\"Module constant:\", MODULE_CONSTANT);\n\n// Ambient interface declaration\ndeclare interface GlobalSettings {\n  theme: string;\n  language: string;\n}\n\ndeclare var appSettings: GlobalSettings;\nconsole.log(\"App theme:\", appSettings.theme);\nconsole.log(\"App language:\", appSettings.language);",
      "keyPoints": [
        "Ambient declarations use `declare` keyword to describe external JavaScript environments or libraries.",
        "They provide type information without implementation.",
        "Used for global variables, functions, modules, namespaces, and interfaces from JavaScript.",
        "Essential for integrating TypeScript with existing JavaScript codebases.",
        "Can be placed in `.ts` files or `.d.ts` declaration files.",
        "Enable type safety when interacting with non-TypeScript code."
      ],
      "quiz": [
        {
          "question": "What is the primary purpose of ambient declarations in TypeScript?",
          "options": ["To define the implementation of JavaScript functions.", "To convert JavaScript code to TypeScript.", "To describe the types of existing JavaScript environments or libraries to the TypeScript compiler.", "To improve the runtime performance of JavaScript code."],
          "correctAnswer": 2,
          "explanation": "The primary purpose of ambient declarations is to provide type information to the TypeScript compiler about JavaScript code that exists outside of the TypeScript project, such as global variables, browser APIs, or external JavaScript libraries. They allow TypeScript to understand the types of these external entities without needing to rewrite the JavaScript code in TypeScript."
        },
        {
          "question": "Which keyword is used to create an ambient declaration in TypeScript?",
          "options": ["`export`", "`import`", "`declare`", "`ambient`"],
          "correctAnswer": 2,
          "explanation": "The `declare` keyword is used in TypeScript to create ambient declarations. It signals to the compiler that you are declaring the existence of a variable, function, class, module, etc., that is assumed to exist in the runtime environment or in external JavaScript code, without providing an implementation in the TypeScript file itself."
        },
        {
          "question": "Do ambient declarations include implementation details?",
          "options": ["Yes, they must include both type declarations and implementation.", "No, they only include type declarations and no implementation.", "Only for global variables, not for functions or classes.", "Only for external modules, not for global variables."],
          "correctAnswer": 1,
          "explanation": "No, ambient declarations in TypeScript do not include implementation details. They are purely for type declarations. An ambient declaration only tells the TypeScript compiler about the existence and type signature of something (like a variable, function, or module) that is implemented elsewhere (typically in JavaScript code or the runtime environment). They are used to inform TypeScript about the shape of external code so that TypeScript can type-check code that interacts with it."
        }
      ]
    },
    {
      "id": "tsconfig-json",
      "title": "Project Configuration (tsconfig.json)",
      "description": "`tsconfig.json` is the configuration file for TypeScript projects. It specifies compiler options, project settings, and includes/excludes files from the TypeScript compilation process. It's essential for managing and customizing how TypeScript compiles your code.",
      "difficulty": "beginner",
      "category": "fundamentals",
      "explanation": "`tsconfig.json` is the heart of any TypeScript project. It serves as a configuration file that directs the TypeScript compiler (`tsc`) on how to compile your TypeScript code. It allows you to specify a wide range of compiler options, such as target ECMAScript version (`target`), module system (`module`), output directory (`outDir`), strict type checking options (`strict`), and many more. `tsconfig.json` also controls which files are included in your project (using `include` and `exclude` arrays or `files` array), defining the compilation scope. By customizing `tsconfig.json`, you can tailor the TypeScript compilation process to meet the specific needs of your project, ensuring consistent build behavior and enabling various TypeScript features and optimizations. It simplifies project setup and management, making TypeScript development more efficient and organized.",
      "example": "// --- Example tsconfig.json ---\n{\n  \"compilerOptions\": {\n    \"target\": \"es5\",         // Target ECMAScript version\n    \"module\": \"commonjs\",     // Module system\n    \"outDir\": \"./dist\",      // Output directory for compiled JavaScript files\n    \"strict\": true,          // Enable strict type checking options\n    \"esModuleInterop\": true,  // Enable interoperability between CommonJS and ES modules\n    \"skipLibCheck\": true,     // Skip type checking of declaration files (*.d.ts)\n    \"forceConsistentCasingInFileNames\": true // Enforce consistent casing in file names\n  },\n  \"include\": [\n    \"src/**/*.ts\"           // Include all TypeScript files in 'src' directory and subdirectories\n  ],\n  \"exclude\": [\n    \"node_modules\",          // Exclude 'node_modules' directory\n    \"**/*.spec.ts\"          // Exclude all test files ending with '.spec.ts'\n  ]\n}",
      "keyPoints": [
        "`tsconfig.json` is the configuration file for TypeScript projects.",
        "Specifies compiler options (e.g., `target`, `module`, `strict`).",
        "Controls project settings and compilation behavior.",
        "Defines files to include and exclude from compilation using `include`, `exclude`, or `files`.",
        "Customizes TypeScript compilation process for specific project needs.",
        "Essential for project setup, management, and consistent builds."
      ],
      "quiz": [
        {
          "question": "What is the primary purpose of the `tsconfig.json` file in a TypeScript project?",
          "options": ["To define the project's dependencies.", "To configure the TypeScript compiler and project settings.", "To manage version control for TypeScript files.", "To specify the runtime environment for TypeScript code."],
          "correctAnswer": 1,
          "explanation": "The primary purpose of `tsconfig.json` is to configure the TypeScript compiler and project settings. It allows developers to specify compiler options like target ECMAScript version, module system, output directory, and strict type checking options, as well as to control which files are included in the compilation process."
        },
        {
          "question": "Which `tsconfig.json` option specifies the target ECMAScript version for the compiled JavaScript code?",
          "options": ["`module`", "`target`", "`outDir`", "`strict`"],
          "correctAnswer": 1,
          "explanation": "The `target` option in `tsconfig.json` specifies the ECMAScript target version for the compiled JavaScript code. Common values include 'es5', 'es6', 'es2017', 'es2020', 'esnext', etc. This option determines the JavaScript syntax features that the TypeScript compiler will output."
        },
        {
          "question": "What do the `include` and `exclude` arrays in `tsconfig.json` control?",
          "options": ["They define the runtime dependencies of the project.", "They specify which files are included and excluded from the TypeScript compilation process.", "They configure the code formatting rules for the project.", "They determine the order of compilation for TypeScript files."],
          "correctAnswer": 1,
          "explanation": "The `include` and `exclude` arrays in `tsconfig.json` are used to control which files are part of the TypeScript compilation process. The `include` array specifies patterns for files to include, while the `exclude` array specifies patterns for files and directories to exclude. This allows you to define the scope of your TypeScript project's compilation."
        }
      ]
    },
    {
      "id": "jsx-support",
      "title": "JSX Support in TypeScript",
      "description": "TypeScript provides excellent support for JSX (JavaScript XML), a syntax extension commonly used with React. TypeScript can type-check JSX syntax, validate props, and provide autocompletion, making it a robust choice for React development.",
      "difficulty": "intermediate",
      "category": "frameworks",
      "explanation": "JSX is a syntax extension that allows you to write HTML-like syntax within your JavaScript or TypeScript code, primarily used with UI libraries like React. TypeScript has built-in support for JSX, enabling you to write JSX code with full type safety. TypeScript can understand JSX syntax, validate the types of props passed to components, check for correct component usage, and provide autocompletion and error checking within JSX. To use JSX in TypeScript, you typically need to configure the `jsx` compiler option in `tsconfig.json` (e.g., to 'react' or 'react-jsx' for modern React). TypeScript's JSX support enhances the developer experience for React and other JSX-based libraries by bringing the benefits of static typing to component development, reducing runtime errors and improving code maintainability.",
      "example": "// --- Example React component in TypeScript (MyComponent.tsx) ---\ninterface MyComponentProps {\n  name: string;\n  age?: number;\n}\n\nconst MyComponent: React.FC<MyComponentProps> = ({ name, age }) => {\n  return (\n    <div>\n      <h1>Hello, {name}!</h1>\n      {age && <p>You are {age} years old.</p>}\n    </div>\n  );\n};\n\n// --- Example usage in another component or app ---\nimport React from 'react';\nimport ReactDOM from 'react-dom';\nimport MyComponent from './MyComponent';\n\nconst App = () => {\n  return (\n    <div>\n      <MyComponent name=\"Alice\" age={30} /> {/* Type-checked props */}\n      <MyComponent name=\"Bob\" /> {/* Optional 'age' prop is OK */}\n      {/* <MyComponent age={25} /> */} {/* Error: Missing 'name' prop (required) */}\n    </div>\n  );\n};\n\nReactDOM.render(<App />, document.getElementById('root'));",
      "keyPoints": [
        "TypeScript has built-in support for JSX syntax (commonly used with React).",
        "TypeScript type-checks JSX code, validating props and component usage.",
        "Configuration via `jsx` compiler option in `tsconfig.json` (e.g., 'react', 'react-jsx').",
        "Provides autocompletion and error checking within JSX.",
        "Enhances type safety and developer experience for React and JSX-based libraries.",
        "Reduces runtime errors and improves maintainability of React components in TypeScript."
      ],
      "quiz": [
        {
          "question": "What is JSX?",
          "options": ["A superset of JavaScript.", "A syntax extension that allows writing HTML-like syntax in JavaScript/TypeScript.", "A JavaScript runtime environment.", "A TypeScript-specific file extension."],
          "correctAnswer": 1,
          "explanation": "JSX (JavaScript XML) is a syntax extension for JavaScript and TypeScript that looks similar to HTML. It's primarily used with UI libraries like React to describe the structure of user interfaces in a declarative way within JavaScript code. JSX is not valid JavaScript itself and needs to be transformed into standard JavaScript by tools like Babel or the TypeScript compiler."
        },
        {
          "question": "Does TypeScript provide type checking for JSX syntax?",
          "options": ["No, JSX is dynamically typed even in TypeScript.", "Yes, TypeScript fully supports type checking for JSX code.", "Only basic syntax checking, not type checking of props.", "JSX is only supported in JavaScript, not in TypeScript."],
          "correctAnswer": 1,
          "explanation": "Yes, TypeScript provides robust type checking for JSX syntax. When you use JSX in TypeScript, the compiler can validate the types of props passed to components, ensure correct component usage, and provide compile-time errors if there are type mismatches or missing required props. This makes TypeScript a strong choice for developing React applications with type safety."
        },
        {
          "question": "Which `tsconfig.json` compiler option is typically used to enable JSX support in TypeScript?",
          "options": ["`jsxSupport`", "`enableJSX`", "`jsx`", "`reactJSX`"],
          "correctAnswer": 2,
          "explanation": "The `jsx` compiler option in `tsconfig.json` is used to enable JSX support in TypeScript projects. Common values for this option include 'react' (for classic React JSX transform) and 'react-jsx' or 'react-jsxdev' (for the new JSX transform introduced in React 17 and later). Setting this option tells the TypeScript compiler how to handle JSX syntax and transform it into standard JavaScript."
        }
      ]
    },
    {
      "id": "type-narrowing-techniques",
      "title": "Type Narrowing Techniques (More Examples)",
      "description": "Type narrowing in TypeScript is the process of refining a variable's type to a more specific type within a certain code block. Beyond `typeof` and `instanceof`, techniques like truthiness/falsiness checks and discriminant properties are also effective for type narrowing.",
      "difficulty": "intermediate",
      "category": "advanced-types",
      "explanation": "Type narrowing is crucial for working with union types and `unknown` types in TypeScript, allowing you to safely operate on values by ensuring TypeScript understands their specific type in different parts of your code. While `typeof` and `instanceof` are common type guards, other techniques are equally important. Truthiness and falsiness checks (e.g., `if (value) { ... }`) can narrow down types when dealing with nullable or optional values. Discriminant properties (or tagged unions) involve using a common property in union types to distinguish between them, enabling type narrowing based on the value of this property. These techniques, combined with type predicates and other type guards, provide a comprehensive toolkit for handling type uncertainty and writing robust, type-safe TypeScript code.",
      "example": "// Truthiness/Falsiness checks for type narrowing\nfunction processValue(value: string | null | undefined) {\n  if (value) { // Truthiness check: null and undefined are falsy\n    console.log(\"Value is likely a string:\", value.toUpperCase()); // 'value' narrowed to string | null | undefined, but falsy values are excluded in 'if'\n  } else {\n    console.log(\"Value is null or undefined:\", value); // 'value' narrowed to null | undefined\n  }\n}\n\nprocessValue(\"hello\");\nprocessValue(null);\nprocessValue(undefined);\n\n// Discriminant properties (Tagged Unions) for type narrowing\ninterface Circle {\n  kind: \"circle\"; // Discriminant property\n  radius: number;\n}\n\ninterface Square {\n  kind: \"square\"; // Discriminant property\n  sideLength: number;\n}\n\ntype Shape = Circle | Square;\n\nfunction getShapeArea(shape: Shape) {\n  switch (shape.kind) { // Narrowing based on discriminant property 'kind'\n    case \"circle\":\n      return Math.PI * shape.radius * shape.radius; // 'shape' narrowed to Circle\n    case \"square\":\n      return shape.sideLength * shape.sideLength;   // 'shape' narrowed to Square\n    default:\n      // Exhaustiveness check (optional, for safety)\n      const _exhaustiveCheck: never = shape; // Error if not all cases are handled\n      return _exhaustiveCheck;\n  }\n}\n\nconst circle: Circle = { kind: \"circle\", radius: 5 };\nconst square: Square = { kind: \"square\", sideLength: 10 };\n\nconsole.log(\"Circle area:\", getShapeArea(circle));\nconsole.log(\"Square area:\", getShapeArea(square));",
      "keyPoints": [
        "Type narrowing refines a variable's type to a more specific one.",
        "Truthiness/falsiness checks (e.g., `if (value)`) narrow types for nullable/optional values.",
        "Discriminant properties (tagged unions) use a common property to distinguish union types.",
        "`switch` statements and discriminant properties enable precise type narrowing.",
        "Exhaustiveness checks (`const _exhaustiveCheck: never = shape;`) can ensure all union cases are handled.",
        "Type narrowing techniques are essential for robust and type-safe TypeScript code with union and unknown types."
      ],
      "quiz": [
        {
          "question": "How can truthiness/falsiness checks be used for type narrowing in TypeScript?",
          "options": ["To convert a value to boolean type.", "To check if a value is strictly true or false.", "To narrow down types for nullable or optional values by checking if they are truthy or falsy.", "Truthiness checks cannot be used for type narrowing."],
          "correctAnswer": 2,
          "explanation": "Truthiness/falsiness checks (e.g., `if (value) { ... }`) can be used for type narrowing in TypeScript, especially for nullable or optional types like `string | null | undefined`. In an `if (value)` block, TypeScript understands that `value` cannot be `null` or `undefined` if the condition is truthy, thus narrowing down its type to exclude falsy values."
        },
        {
          "question": "What are discriminant properties (tagged unions) used for in type narrowing?",
          "options": ["To create union types of primitive types only.", "To narrow down types based on the value of a specific property common to all union members.", "To define the order of properties in object types.", "Discriminant properties are not related to type narrowing."],
          "correctAnswer": 1,
          "explanation": "Discriminant properties (also known as tagged unions) are used in type narrowing to distinguish between different members of a union type. By adding a common property (the discriminant) with different literal values to each member of the union, you can use a `switch` statement or `if/else if` chain to check the value of this property and narrow down the type to the specific union member within each case or condition."
        },
        {
          "question": "What is an exhaustiveness check in the context of type narrowing with discriminant properties?",
          "options": ["A runtime check to ensure all cases are handled.", "A compile-time check to ensure all cases of a union type are handled in a `switch` statement.", "A performance optimization technique for type guards.", "A method to bypass type narrowing when needed."],
          "correctAnswer": 1,
          "explanation": "An exhaustiveness check is a compile-time technique used in conjunction with discriminant properties and `switch` statements to ensure that all possible members of a union type are handled in the `switch` cases. Typically, this is done by assigning the narrowed variable to a variable of type `never` in the `default` case. If all cases are correctly handled, the `default` case should never be reached, and the assignment to `never` will not cause a type error. If a case is missing, the assignment will cause a type error, signaling a non-exhaustive switch."
        }
      ]
    },
    {
      "id": "overload-signatures",
      "title": "Overload Signatures (Function Overloads)",
      "description": "Overload signatures in TypeScript allow you to define multiple call signatures for a single function. This enables you to provide type-safe function calls with different argument types and return types based on the input.",
      "difficulty": "intermediate",
      "category": "advanced-types",
      "explanation": "Function overloads in TypeScript allow you to declare multiple function signatures for the same function name. Each signature specifies different parameter types and potentially different return types. When calling an overloaded function, TypeScript uses overload resolution to determine which signature matches the provided arguments and applies the corresponding type checking. Overload signatures are useful when a function can be called in multiple ways with different argument types or when the return type depends on the input types. They enhance type safety by providing specific type contracts for different function call patterns, making your APIs more flexible and easier to use correctly. The implementation signature (the last one without a function body) must be compatible with all overload signatures.",
      "example": "// Overload signatures for a function that can handle string or number input\nfunction convertToString(value: number): string;\nfunction convertToString(value: boolean): string;\nfunction convertToString(value: null): string;\nfunction convertToString(value: undefined): string;\nfunction convertToString(value: any): string; // Implementation signature (must be compatible with all overloads)\nfunction convertToString(value: any): string {\n  if (value === null) return 'null';\n  if (value === undefined) return 'undefined';\n  return String(value);\n}\n\nconsole.log(convertToString(123));     // Calls number overload\nconsole.log(convertToString(true));    // Calls boolean overload\nconsole.log(convertToString(null));    // Calls null overload\nconsole.log(convertToString(undefined)); // Calls undefined overload\nconsole.log(convertToString({}));      // Calls implementation signature (any overload)\n// console.log(convertToString(Symbol())); // Error: No overload matches this call.\n\n// Overload signatures for getLength function\nfunction getLength(s: string): number;\nfunction getLength<T>(arr: T[]): number;\nfunction getLength(arg: string | any[]): number { // Implementation signature\n  return arg.length;\n}\n\nconsole.log(\"String length:\", getLength(\"hello\")); // Calls string overload\nconsole.log(\"Array length:\", getLength([1, 2, 3])); // Calls generic array overload",
      "keyPoints": [
        "Overload signatures define multiple call signatures for a single function name.",
        "Each signature specifies different parameter and return types.",
        "TypeScript uses overload resolution to match function calls to signatures.",
        "Useful when functions can be called with different argument types or return different types based on input.",
        "Enhance type safety by providing specific type contracts for different call patterns.",
        "Implementation signature must be compatible with all overload signatures."
      ],
      "quiz": [
        {
          "question": "What is the purpose of function overload signatures in TypeScript?",
          "options": ["To improve runtime performance of functions.", "To define multiple implementations for a single function.", "To allow a function to be called with different sets of arguments and return types in a type-safe way.", "To create generic functions that can work with any type."],
          "correctAnswer": 2,
          "explanation": "Function overload signatures in TypeScript are used to define multiple ways a function can be called, each with potentially different argument types and return types. This allows TypeScript to provide type safety for various call patterns of the same function, ensuring that calls are made with correct arguments and that the return type is appropriately typed based on the call signature."
        },
        {
          "question": "How does TypeScript determine which overload signature to use when a function is called?",
          "options": ["Based on the order of overload signatures defined.", "Based on the function name only.", "Using overload resolution, which matches the call to the most appropriate signature based on argument types.", "TypeScript does not choose between overload signatures; it uses the implementation signature directly."],
          "correctAnswer": 2,
          "explanation": "TypeScript uses overload resolution to determine which overload signature to use when a function is called. It examines the types of the arguments provided in the function call and attempts to match them against the defined overload signatures. The overload signature that best matches the argument types is chosen, and the type checking and return type are based on that signature."
        },
        {
          "question": "What is the role of the implementation signature in function overloads?",
          "options": ["It is the only signature that is actually executed at runtime.", "It provides a fallback signature if no overload signatures match the function call.", "It must be compatible with all overload signatures and provides the actual function body.", "It is used only for documentation and has no impact on type checking."],
          "correctAnswer": 2,
          "explanation": "The implementation signature in function overloads is the one that contains the actual function body. It must be compatible with all the overload signatures defined for that function. TypeScript uses the overload signatures for type checking function calls, and the implementation signature provides the runtime behavior. It's a single implementation that must handle all cases described by the overload signatures."
        }
      ]
    }
  ]
}