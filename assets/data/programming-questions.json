{
  "questions": [
    {
      "id": "pq1",
      "title": "Two Sum",
      "category": "Arrays",
      "difficulty": "Easy",
      "description": "Given an array of integers nums and an integer target, return indices of the two numbers in the array that add up to target.",
      "methodology": {
        "approach": "Hash Table",
        "explanation": "There are two main approaches to solve this problem:\n\n1. Hash Table Approach:\n- We use a hash table to store each number and its index as we iterate through the array\n- For each number, we calculate its complement (target - current number)\n- If the complement exists in our hash table, we've found our pair\n- This gives us O(n) time complexity with O(n) space\n\n2. Brute Force Approach:\n- We can use nested loops to check every possible pair of numbers\n- For each number, we check all other numbers to find if they sum to target\n- This gives us O(nÂ²) time complexity but O(1) space\n\nThe Hash Table approach is preferred as it's more efficient in terms of time complexity.",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)"
      },
      "examples": [
        {
          "input": "nums = [2, 7, 11, 15], target = 9",
          "output": "[0, 1]",
          "explanation": "Because nums[0] + nums[1] = 2 + 7 = 9"
        }
      ],
      "solutions": [
        {
          "approach": "Hash Table",
          "code": "function twoSum(nums, target) {\n  const map = new Map();\n  \n  for (let i = 0; i < nums.length; i++) {\n    const complement = target - nums[i];\n    \n    if (map.has(complement)) {\n      return [map.get(complement), i];\n    }\n    \n    map.set(nums[i], i);\n  }\n  \n  return [];\n}",
          "explanation": "1. Create an empty hash map\n2. Iterate through the array\n3. For each number, calculate its complement\n4. If complement exists in map, return current index and complement's index\n5. Otherwise, add current number and its index to map"
        },
        {
          "approach": "Brute Force",
          "code": "function twoSum(nums, target) {\n  for (let i = 0; i < nums.length; i++) {\n    for (let j = i + 1; j < nums.length; j++) {\n      if (nums[i] + nums[j] === target) {\n        return [i, j];\n      }\n    }\n  }\n  return [];\n}",
          "explanation": "1. Use nested loops to check every possible pair\n2. For each number at index i, check all numbers at index j > i\n3. If any pair sums to target, return their indices\n4. If no solution is found, return empty array"
        }
      ]
    },
    {
      "id": "pq2",
      "title": "String Reversal",
      "category": "Strings",
      "difficulty": "Easy",
      "description": "Write a function that reverses a string without using the built-in reverse() method.",
      "methodology": {
        "approach": "Multiple Approaches",
        "explanation": "There are several ways to reverse a string:\n\n1. Two Pointers Approach:\n- Convert string to array (since strings are immutable in JavaScript)\n- Use two pointers starting from opposite ends\n- Swap characters until pointers meet in middle\n- Join array back to string\n- Time: O(n), Space: O(n)\n\n2. Array Methods Approach:\n- Split string into array of characters\n- Use array reverse method\n- Join back to string\n- Simpler but may be considered using built-in reverse\n- Time: O(n), Space: O(n)\n\n3. Recursive Approach:\n- Base case: empty string or single character\n- Recursive case: last character + recursive call with substring\n- Time: O(n), Space: O(n) due to call stack\n\nThe Two Pointers approach is often preferred as it's explicit and efficient.",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)"
      },
      "examples": [
        {
          "input": "hello",
          "output": "olleh",
          "explanation": "Swap 'h' with 'o', then 'e' with 'l', middle 'l' stays in place"
        }
      ],
      "solutions": [
        {
          "approach": "Two Pointers",
          "code": "function reverseString(str) {\n  const arr = str.split('');\n  let left = 0;\n  let right = arr.length - 1;\n  \n  while (left < right) {\n    [arr[left], arr[right]] = [arr[right], arr[left]];\n    left++;\n    right--;\n  }\n  \n  return arr.join('');\n}",
          "explanation": "1. Convert string to array of characters\n2. Initialize two pointers at start and end\n3. Swap characters at both pointers\n4. Move pointers towards center\n5. Join array back to string"
        },
        {
          "approach": "Recursive",
          "code": "function reverseString(str) {\n  if (str.length <= 1) return str;\n  return str[str.length - 1] + reverseString(str.slice(0, -1));\n}",
          "explanation": "1. Base case: return if string length <= 1\n2. Take last character\n3. Recursively reverse rest of string\n4. Concatenate last char with reversed substring"
        }
      ]
    },
    {
      "id": "pq3",
      "title": "Fibonacci Sequence",
      "category": "Dynamic Programming",
      "difficulty": "Medium",
      "description": "Write a function to generate the nth Fibonacci number using different approaches (recursive, iterative, and memoization).",
      "methodology": {
        "approach": "Multiple Approaches",
        "explanation": "There are several ways to solve this problem:\n\n1. Recursive Approach:\n- Base case: F(0) = 0, F(1) = 1\n- Recursive case: F(n) = F(n-1) + F(n-2)\n- Time: O(2^n), Space: O(n) due to call stack\n\n2. Memoization Approach:\n- Store previously calculated Fibonacci numbers in a cache\n- Before calculating F(n), check if it's in the cache\n- If not, calculate and store it in the cache\n- Time: O(n), Space: O(n)\n\n3. Iterative Approach:\n- Use two variables to track previous Fibonacci numbers\n- Update them in each iteration\n- Time: O(n), Space: O(1)\n\nThe Iterative approach is often preferred as it's efficient in terms of time and space complexity.",
        "timeComplexity": "O(n) for optimized solutions, O(2^n) for naive recursive",
        "spaceComplexity": "O(n) for memoization, O(1) for iterative"
      },
      "examples": [
        {
          "input": "n = 6",
          "output": "8",
          "explanation": "Fibonacci sequence: 0, 1, 1, 2, 3, 5, 8"
        }
      ],
      "solutions": [
        {
          "approach": "Iterative",
          "code": "function fibIterative(n) {\n  if (n <= 1) return n;\n  \n  let prev = 0, curr = 1;\n  for (let i = 2; i <= n; i++) {\n    [prev, curr] = [curr, prev + curr];\n  }\n  return curr;\n}",
          "explanation": "1. Use two variables to track previous numbers\n2. Update them in each iteration\n3. Return the nth Fibonacci number"
        },
        {
          "approach": "Memoization",
          "code": "function fibMemo(n, memo = {}) {\n  if (n in memo) return memo[n];\n  if (n <= 1) return n;\n  \n  memo[n] = fibMemo(n - 1, memo) + fibMemo(n - 2, memo);\n  return memo[n];\n}",
          "explanation": "1. Store previously calculated Fibonacci numbers in a cache\n2. Before calculating F(n), check if it's in the cache\n3. If not, calculate and store it in the cache\n4. Return the nth Fibonacci number"
        }
      ]
    },
    {
      "id": "pq4",
      "title": "Valid Palindrome",
      "category": "Strings",
      "difficulty": "Easy",
      "description": "Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.",
      "methodology": {
        "approach": "Two Pointers",
        "explanation": "We can use the two-pointer approach:\n\n1. Initialize two pointers, one at the beginning and one at the end of the string.\n2. Move pointers inwards, skipping non-alphanumeric characters and converting characters to lowercase for comparison.\n3. Compare characters at both pointers. If they are not equal, it's not a palindrome.\n4. If pointers meet or cross and all characters matched, it's a palindrome.\n\nTime Complexity: O(n), where n is the length of the string.\nSpace Complexity: O(1).",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)"
      },
      "examples": [
        {
          "input": "A man, a plan, a canal: Panama",
          "output": "true",
          "explanation": "After cleaning and lowercasing, it becomes 'amanaplanacanalpanama', which is a palindrome."
        },
        {
          "input": "race a car",
          "output": "false",
          "explanation": "After cleaning and lowercasing, it becomes 'raceacar', which is not a palindrome."
        }
      ],
      "solutions": [
        {
          "approach": "Two Pointers",
          "code": "function isPalindrome(s) {\n  let left = 0;\n  let right = s.length - 1;\n\n  while (left < right) {\n    while (left < right && !/[a-zA-Z0-9]/.test(s[left])) {\n      left++;\n    }\n    while (left < right && !/[a-zA-Z0-9]/.test(s[right])) {\n      right--;\n    }\n\n    if (s[left].toLowerCase() !== s[right].toLowerCase()) {\n      return false;\n    }\n\n    left++;\n    right--;\n  }\n  return true;\n}",
          "explanation": "1. Initialize left and right pointers at the start and end of the string.\n2. Iterate while left < right.\n3. Move left pointer to the right until it points to an alphanumeric character.\n4. Move right pointer to the left until it points to an alphanumeric character.\n5. Compare the characters at left and right pointers (case-insensitive).\n6. If characters are not equal, return false.\n7. Move pointers inwards.\n8. If loop completes, return true."
        }
      ]
    },
    {
      "id": "pq5",
      "title": "Merge Sorted Arrays",
      "category": "Arrays",
      "difficulty": "Easy",
      "description": "You are given two sorted integer arrays nums1 and nums2, merge nums2 into nums1 as one sorted array.\n\nNote:\n- The number of elements initialized in nums1 and nums2 are m and n respectively.\n- You may assume that nums1 has enough space (size greater or equal to m + n) to hold additional elements from nums2.",
      "methodology": {
        "approach": "Three Pointers (Merge from Back)",
        "explanation": "A efficient approach is to merge from the back to avoid overwriting elements in nums1 before they are processed.\n\n1. Initialize three pointers: `i` pointing to the last element of nums1 (initialized part), `j` pointing to the last element of nums2, and `k` pointing to the last position of the merged array in nums1.\n2. While both `i` and `j` are valid indices:\n   - Compare `nums1[i]` and `nums2[j]`.\n   - Place the larger element at `nums1[k]` and decrement the corresponding pointer (`i` or `j`) and `k`.\n3. After the loop, if there are any remaining elements in `nums2`, copy them to the beginning of `nums1`.\n\nTime Complexity: O(m + n), where m and n are the lengths of nums1 and nums2 respectively.\nSpace Complexity: O(1).",
        "timeComplexity": "O(m + n)",
        "spaceComplexity": "O(1)"
      },
      "examples": [
        {
          "input": "nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3",
          "output": "nums1 = [1,2,2,3,5,6]",
          "explanation": "The arrays we are merging are [1,2,3] and [2,5,6]. The result of the merge is [1,2,2,3,5,6] with nums1 as the destination."
        }
      ],
      "solutions": [
        {
          "approach": "Three Pointers (Merge from Back)",
          "code": "function mergeSortedArrays(nums1, m, nums2, n) {\n  let i = m - 1;\n  let j = n - 1;\n  let k = m + n - 1;\n\n  while (j >= 0) {\n    if (i >= 0 && nums1[i] > nums2[j]) {\n      nums1[k--] = nums1[i--];\n    } else {\n      nums1[k--] = nums2[j--];\n    }\n  }\n}",
          "explanation": "1. Initialize three pointers: i to the last element of nums1's initialized part, j to the last element of nums2, and k to the last position of nums1.\n2. Iterate while j is a valid index (elements in nums2 to merge).\n3. If i is also a valid index and nums1[i] > nums2[j], copy nums1[i] to nums1[k] and decrement i and k.\n4. Otherwise, copy nums2[j] to nums1[k] and decrement j and k.\n5. No need to handle remaining elements in nums1 as they are already in place."
        }
      ]
    },
    {
      "id": "pq6",
      "title": "Reverse Linked List",
      "category": "Linked Lists",
      "difficulty": "Medium",
      "description": "Reverse a singly linked list.",
      "methodology": {
        "approach": "Iterative",
        "explanation": "We can reverse a linked list iteratively by changing the `next` pointers of each node.\n\n1. Initialize `prev` to `null` and `curr` to `head`.\n2. Iterate through the list while `curr` is not `null`.\n3. For each node:\n   - Store the `next` node of `curr` in a temporary variable `nextNode`.\n   - Change the `next` pointer of `curr` to point to `prev`.\n   - Move `prev` to `curr` and `curr` to `nextNode`.\n4. After the loop, `prev` will be the new head of the reversed list.\n\nTime Complexity: O(n), where n is the number of nodes in the linked list.\nSpace Complexity: O(1).",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)"
      },
      "examples": [
        {
          "input": "1->2->3->4->5->NULL",
          "output": "5->4->3->2->1->NULL",
          "explanation": "The linked list is reversed."
        }
      ],
      "solutions": [
        {
          "approach": "Iterative",
          "code": "function reverseLinkedList(head) {\n  let prev = null;\n  let curr = head;\n\n  while (curr) {\n    const nextNode = curr.next;\n    curr.next = prev;\n    prev = curr;\n    curr = nextNode;\n  }\n  return prev;\n}",
          "explanation": "1. Initialize `prev` to null and `curr` to the head of the list.\n2. Iterate while `curr` is not null.\n3. Store the next node in `nextNode`.\n4. Reverse the `next` pointer of `curr` to point to `prev`.\n5. Move `prev` and `curr` one step forward.\n6. Return `prev` as the new head of the reversed list."
        },
        {
          "approach": "Recursive",
          "code": "function reverseLinkedListRecursive(head) {\n  if (!head || !head.next) {\n    return head;\n  }\n  const newHead = reverseLinkedListRecursive(head.next);\n  head.next.next = head;\n  head.next = null;\n  return newHead;\n}",
          "explanation": "1. Base case: If the list is empty or has only one node, return the head.\n2. Recursively reverse the rest of the list (from head.next).\n3. Let `newHead` be the head of the reversed rest of the list.\n4. Make the `next` of the next node of `head` point back to `head` (reversing the link).\n5. Set the `next` of `head` to `null` to terminate the reversed list at the original head.\n6. Return `newHead`."
        }
      ]
    },
    {
      "id": "pq7",
      "title": "Binary Tree Inorder Traversal",
      "category": "Trees",
      "difficulty": "Medium",
      "description": "Given a binary tree, return the inorder traversal of its nodes' values.",
      "methodology": {
        "approach": "Recursive",
        "explanation": "Inorder traversal of a binary tree visits nodes in the order: Left subtree, Root, Right subtree.\n\n1. If the root is `null`, return an empty list.\n2. Recursively traverse the left subtree.\n3. Add the value of the root node to the result list.\n4. Recursively traverse the right subtree.\n\nTime Complexity: O(n), where n is the number of nodes in the tree, as each node is visited once.\nSpace Complexity: O(h), where h is the height of the tree, due to recursive call stack. In the worst case (skewed tree), h can be n, and in the best case (balanced tree), h is log(n).",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(h)"
      },
      "examples": [
        {
          "input": "     1\n    / \\\n   null  2\n        / \n       3   null",
          "output": "[1, 3, 2]",
          "explanation": "Inorder traversal: Left, Root, Right. Null left subtree of 1, visit 1, Inorder traversal of right subtree of 1 (which is rooted at 2: null left subtree of 2, visit 3 from left subtree of 2, visit 2, null right subtree of 2)."
        }
      ],
      "solutions": [
        {
          "approach": "Recursive",
          "code": "function inorderTraversal(root) {\n  const result = [];\n\n  function traverse(node) {\n    if (!node) {\n      return;\n    }\n    traverse(node.left);\n    result.push(node.val);\n    traverse(node.right);\n  }\n\n  traverse(root);\n  return result;\n}",
          "explanation": "1. Initialize an empty array `result` to store the inorder traversal.\n2. Define a recursive function `traverse(node)`.\n3. Base case: If `node` is null, return.\n4. Recursively call `traverse` on the left child.\n5. Push the value of the current `node` to `result`.\n6. Recursively call `traverse` on the right child.\n7. Start the traversal from the root by calling `traverse(root)`.\n8. Return `result`."
        },
        {
          "approach": "Iterative",
          "code": "function inorderTraversalIterative(root) {\n  const result = [];\n  const stack = [];\n  let curr = root;\n\n  while (curr || stack.length) {\n    while (curr) {\n      stack.push(curr);\n      curr = curr.left;\n    }\n    curr = stack.pop();\n    result.push(curr.val);\n    curr = curr.right;\n  }\n  return result;\n}",
          "explanation": "1. Initialize an empty array `result` and a stack.\n2. Initialize `curr` to `root`.\n3. While `curr` is not null or stack is not empty:\n4. While `curr` is not null, push `curr` to stack and move to its left child.\n5. Pop the top node from the stack and set it as `curr`.\n6. Push the value of `curr` to `result`.\n7. Move `curr` to its right child.\n8. Return `result`."
        }
      ]
    },
    {
      "id": "pq8",
      "title": "Implement Queue using Stacks",
      "category": "Stacks & Queues",
      "difficulty": "Easy",
      "description": "Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all regular queue operations (push, peek, pop, empty).",
      "methodology": {
        "approach": "Two Stacks",
        "explanation": "We can use two stacks, `inputStack` and `outputStack`, to simulate a queue.\n\n- **push(x):** Always push the element `x` onto the `inputStack`.\n- **peek():** If `outputStack` is empty, transfer all elements from `inputStack` to `outputStack`. Then, peek from `outputStack`. If `outputStack` is still empty, the queue is empty.\n- **pop():** Same as peek, but pop from `outputStack` instead of just peeking.\n- **empty():** Return true if both `inputStack` and `outputStack` are empty, false otherwise.\n\nThis approach ensures FIFO order because the `outputStack` reverses the order of elements from `inputStack`, effectively simulating a queue when elements are transferred.",
        "timeComplexity": "O(1) for push and empty. Amortized O(1) for pop and peek. In the worst case (after many push operations and then pop/peek), pop and peek can be O(n), but on average it's close to O(1).",
        "spaceComplexity": "O(n), where n is the number of elements in the queue, as we store elements in stacks."
      },
      "examples": [
        {
          "input": "push(1), push(2), peek(), pop(), empty()",
          "output": "peek() -> 1, pop() -> 1, empty() -> false",
          "explanation": "Queue operations are simulated using two stacks. First element pushed is the first to be peeked and popped."
        }
      ],
      "solutions": [
        {
          "approach": "Two Stacks",
          "code": "class MyQueue {\n  constructor() {\n    this.inputStack = [];\n    this.outputStack = [];\n  }\n\n  push(x) {\n    this.inputStack.push(x);\n  }\n\n  peek() {\n    if (this.outputStack.length === 0) {\n      while (this.inputStack.length > 0) {\n        this.outputStack.push(this.inputStack.pop());\n      }\n    }\n    return this.outputStack[this.outputStack.length - 1];\n  }\n\n  pop() {\n    if (this.outputStack.length === 0) {\n      while (this.inputStack.length > 0) {\n        this.outputStack.push(this.inputStack.pop());\n      }\n    }\n    return this.outputStack.pop();\n  }\n\n  empty() {\n    return this.inputStack.length === 0 && this.outputStack.length === 0;\n  }\n}",
          "explanation": "1. Initialize two stacks, `inputStack` and `outputStack`.\n2. `push(x)`: Push element `x` to `inputStack`.\n3. `peek()`: If `outputStack` is empty, transfer elements from `inputStack` to `outputStack` in reversed order. Then, peek the top of `outputStack`.\n4. `pop()`: Similar to `peek()`, but pop from `outputStack` after transferring if necessary.\n5. `empty()`: Check if both stacks are empty."
        }
      ]
    },
    {
      "id": "pq9",
      "title": "Binary Search",
      "category": "Searching",
      "difficulty": "Easy",
      "description": "Given a sorted array of integers nums and an integer target, write a function to search target in nums. If target exists, then return its index, otherwise, return -1.",
      "methodology": {
        "approach": "Binary Search",
        "explanation": "Binary Search is an efficient algorithm for finding an item in a sorted list. It repeatedly divides the search interval in half.\n\n1. Initialize `left` to 0 and `right` to `nums.length - 1`.\n2. While `left <= right`:\n   - Calculate `mid = left + Math.floor((right - left) / 2)` to avoid overflow.\n   - If `nums[mid] === target`, return `mid`.\n   - If `nums[mid] < target`, target is in the right half, so set `left = mid + 1`.\n   - If `nums[mid] > target`, target is in the left half, so set `right = mid - 1`.\n3. If the loop finishes without finding the target, return -1.\n\nTime Complexity: O(log n), where n is the length of the array, as we halve the search space in each step.\nSpace Complexity: O(1).",
        "timeComplexity": "O(log n)",
        "spaceComplexity": "O(1)"
      },
      "examples": [
        {
          "input": "nums = [-1,0,3,5,9,12], target = 9",
          "output": "4",
          "explanation": "9 exists in nums and its index is 4"
        },
        {
          "input": "nums = [-1,0,3,5,9,12], target = 2",
          "output": "-1",
          "explanation": "2 does not exist in nums so return -1"
        }
      ],
      "solutions": [
        {
          "approach": "Binary Search",
          "code": "function binarySearch(nums, target) {\n  let left = 0;\n  let right = nums.length - 1;\n\n  while (left <= right) {\n    const mid = left + Math.floor((right - left) / 2);\n\n    if (nums[mid] === target) {\n      return mid;\n    } else if (nums[mid] < target) {\n      left = mid + 1;\n    } else {\n      right = mid - 1;\n    }\n  }\n  return -1;\n}",
          "explanation": "1. Initialize `left` and `right` pointers to the start and end of the array.\n2. Iterate while `left <= right`.\n3. Calculate the middle index `mid`.\n4. If `nums[mid]` is equal to `target`, return `mid`.\n5. If `nums[mid]` is less than `target`, move `left` to `mid + 1`.\n6. If `nums[mid]` is greater than `target`, move `right` to `mid - 1`.\n7. If the target is not found, return -1."
        }
      ]
    },
    {
      "id": "pq10",
      "title": "Climbing Stairs",
      "category": "Dynamic Programming",
      "difficulty": "Easy",
      "description": "You are climbing a staircase. It takes n steps to reach the top. Each time you can climb 1 or 2 steps. In how many distinct ways can you climb to the top?",
      "methodology": {
        "approach": "Dynamic Programming",
        "explanation": "This problem can be solved using dynamic programming. Let `dp[i]` be the number of ways to climb to the i-th step.\n\n1. Base cases: `dp[0] = 1` (one way to reach 0th step - start), `dp[1] = 1` (one way to reach 1st step - 1 step from 0).\n2. For `i > 1`, `dp[i] = dp[i-1] + dp[i-2]`. This is because to reach the i-th step, you can either come from the (i-1)-th step (taking 1 step) or from the (i-2)-th step (taking 2 steps).\n3. The final answer is `dp[n]`. This problem exhibits optimal substructure and overlapping subproblems, making it suitable for DP.\n\nTime Complexity: O(n), as we iterate from 2 to n to fill the dp array.\nSpace Complexity: O(n) to store the dp array.",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(n)"
      },
      "examples": [
        {
          "input": "n = 2",
          "output": "2",
          "explanation": "There are two ways to climb to the top.\n1. 1 step + 1 step\n2. 2 steps"
        },
        {
          "input": "n = 3",
          "output": "3",
          "explanation": "There are three ways to climb to the top.\n1. 1 step + 1 step + 1 step\n2. 1 step + 2 steps\n3. 2 steps + 1 step"
        }
      ],
      "solutions": [
        {
          "approach": "Dynamic Programming",
          "code": "function climbingStairs(n) {\n  if (n <= 1) return 1;\n  const dp = new Array(n + 1);\n  dp[0] = 1;\n  dp[1] = 1;\n\n  for (let i = 2; i <= n; i++) {\n    dp[i] = dp[i - 1] + dp[i - 2];\n  }\n  return dp[n];\n}",
          "explanation": "1. Handle base cases: if n is 0 or 1, return 1.\n2. Create a DP array `dp` of size n+1.\n3. Initialize `dp[0] = 1` and `dp[1] = 1`.\n4. Iterate from i = 2 to n.\n5. Calculate `dp[i] = dp[i-1] + dp[i-2]`.\n6. Return `dp[n]`."
        },
        {
          "approach": "Optimized DP (Constant Space)",
          "code": "function climbingStairsOptimized(n) {\n  if (n <= 1) return 1;\n  let prev = 1;\n  let curr = 1;\n\n  for (let i = 2; i <= n; i++) {\n    const next = prev + curr;\n    prev = curr;\n    curr = next;\n  }\n  return curr;\n}",
          "explanation": "1. Handle base cases: if n is 0 or 1, return 1.\n2. Initialize `prev = 1` and `curr = 1` to represent dp[0] and dp[1].\n3. Iterate from i = 2 to n.\n4. Calculate `next = prev + curr`.\n5. Update `prev = curr` and `curr = next` to simulate moving to the next step.\n6. Return `curr` which represents dp[n]."
        }
      ]
    },
    {
      "id": "pq11",
      "title": "Debounce Function",
      "category": "JavaScript",
      "difficulty": "Medium",
      "description": "Implement a debounce function in JavaScript. Debouncing limits the rate at which a function can fire. After a certain period of inactivity, the function is called.",
      "methodology": {
        "approach": "Closures and Timers",
        "explanation": "Debouncing can be achieved using closures and `setTimeout` in JavaScript.\n\n1. Create a function `debounce(func, delay)` that takes a function `func` and a delay `delay` as arguments.\n2. Inside `debounce`, declare a variable `timeoutId` using `let` to store the timeout ID.\n3. Return a new function (the debounced function).\n4. Inside the debounced function:\n   - Clear any existing timeout using `clearTimeout(timeoutId)`.\n   - Set a new timeout using `setTimeout` that will execute `func` after `delay` milliseconds.\n   - Store the new timeout ID in `timeoutId`.\n\nThis ensures that `func` is only called after `delay` milliseconds of inactivity.",
        "timeComplexity": "O(1) for each debounced call (excluding the actual function execution).",
        "spaceComplexity": "O(1) - constant space for the closure and timeout ID."
      },
      "examples": [
        {
          "input": "Call debouncedFunction multiple times rapidly within the delay period.",
          "output": "The original function 'myFunc' is executed only once after the period of inactivity.",
          "explanation": "The debounced function delays the execution of 'myFunc' until the user stops triggering the event for the specified delay."
        }
      ],
      "solutions": [
        {
          "approach": "Closures and Timers",
          "code": "function debounce(func, delay) {\n  let timeoutId;\n  return function(...args) {\n    clearTimeout(timeoutId);\n    timeoutId = setTimeout(() => {\n      func.apply(this, args);\n    }, delay);\n  };\n}",
          "explanation": "1. `debounce` function takes `func` and `delay`.\n2. `timeoutId` is declared in the closure scope.\n3. The returned function is the debounced function.\n4. Inside, `clearTimeout` cancels any previous timeout.\n5. `setTimeout` schedules `func` to be called after `delay`.\n6. `func.apply(this, args)` ensures correct context and arguments for `func`."
        }
      ]
    },
    {
      "id": "pq12",
      "title": "Throttle Function",
      "category": "JavaScript",
      "difficulty": "Medium",
      "description": "Implement a throttle function in JavaScript. Throttling ensures a function is called at most once in a specified time period.",
      "methodology": {
        "approach": "Closures and Timers",
        "explanation": "Throttling can be achieved using closures and `setTimeout` to control the function execution rate.\n\n1. Create a function `throttle(func, limit)` that takes a function `func` and a time limit `limit` as arguments.\n2. Inside `throttle`, declare a variable `inThrottle` using `let` and initialize it to `false` to track if the function is currently throttled.\n3. Return a new function (the throttled function).\n4. Inside the throttled function:\n   - If `inThrottle` is true, do nothing and return (function is already throttled).\n   - Set `inThrottle` to `true`.\n   - Execute `func` immediately.\n   - Set a timeout using `setTimeout` to reset `inThrottle` to `false` after `limit` milliseconds.\n\nThis ensures `func` is called at most once every `limit` milliseconds.",
        "timeComplexity": "O(1) for each throttled call (excluding the actual function execution).",
        "spaceComplexity": "O(1) - constant space for the closure and throttle flag."
      },
      "examples": [
        {
          "input": "Call throttledFunction multiple times rapidly.",
          "output": "The original function 'myFunc' is executed at most once within each 'limit' interval.",
          "explanation": "The throttled function ensures 'myFunc' is not called more often than every 'limit' milliseconds, even if the triggering event occurs more frequently."
        }
      ],
      "solutions": [
        {
          "approach": "Closures and Timers",
          "code": "function throttle(func, limit) {\n  let inThrottle = false;\n  return function(...args) {\n    if (!inThrottle) {\n      func.apply(this, args);\n      inThrottle = true;\n      setTimeout(() => {\n        inThrottle = false;\n      }, limit);\n    }\n  };\n}",
          "explanation": "1. `throttle` function takes `func` and `limit`.\n2. `inThrottle` flag is declared in the closure scope, initially false.\n3. The returned function is the throttled function.\n4. Inside, check if `inThrottle` is false.\n5. If false, execute `func` immediately using `apply` to maintain context and arguments.\n6. Set `inThrottle` to true.\n7. `setTimeout` resets `inThrottle` to false after `limit` milliseconds, allowing the function to be called again."
        }
      ]
    },
    {
      "id": "pq13",
      "title": "Promise.all Polyfill",
      "category": "JavaScript",
      "difficulty": "Hard",
      "description": "Implement a polyfill for `Promise.all` in JavaScript. It should take an array of promises and return a single promise that resolves when all input promises resolve, or rejects if any input promise rejects.",
      "methodology": {
        "approach": "Promise and Array Iteration",
        "explanation": "Implementing `Promise.all` requires handling an array of promises and managing their resolutions and rejections.\n\n1. Create a function `promiseAllPolyfill(promises)` that takes an array of promises as input.\n2. Return a new `Promise`.\n3. Inside the new promise's executor function:\n   - Initialize an empty array `results` to store the resolved values, and a counter `resolvedCount` to 0.\n   - Iterate through the `promises` array using `forEach`.\n   - For each promise:\n     - Resolve each promise using `.then()`.\n     - In the `.then()` callback:\n       - Store the resolved value in the `results` array at the correct index.\n       - Increment `resolvedCount`.\n       - If `resolvedCount` equals the length of `promises`, resolve the main promise with the `results` array.\n     - Reject the main promise immediately if any of the input promises reject using `.catch()`.\n4. Return the newly created promise.",
        "timeComplexity": "O(n), where n is the number of promises in the input array. Each promise is resolved once.",
        "spaceComplexity": "O(n) to store the `results` array and for the promise chains."
      },
      "examples": [
        {
          "input": "An array of promises that resolve after different times.",
          "output": "A promise that resolves with an array of resolved values in the same order as the input promises, after all input promises have resolved.",
          "explanation": "`promiseAllPolyfill` should behave like `Promise.all`, resolving when all promises in the input array resolve, and rejecting immediately if any promise rejects."
        }
      ],
      "solutions": [
        {
          "approach": "Promise and Array Iteration",
          "code": "function promiseAllPolyfill(promises) {\n  return new Promise((resolve, reject) => {\n    if (!promises || promises.length === 0) {\n      resolve([]); // Resolve immediately if no promises are provided.\n      return;\n    }\n\n    const results = [];\n    let resolvedCount = 0;\n    const numPromises = promises.length;\n\n    promises.forEach((promise, index) => {\n      Promise.resolve(promise)\n        .then((value) => {\n          results[index] = value;\n          resolvedCount++;\n          if (resolvedCount === numPromises) {\n            resolve(results);\n          }\n        })\n        .catch(reject);\n    });\n  });\n}",
          "explanation": "1. `promiseAllPolyfill` takes an array of `promises`.\n2. Returns a new `Promise`.\n3. Handles empty or null input by resolving with an empty array.\n4. `results` array and `resolvedCount` are initialized to track resolutions.\n5. Iterates through `promises` using `forEach`.\n6. `Promise.resolve(promise)` ensures each element is a promise.\n7. `.then()` handles resolution: stores value, increments count, resolves main promise when all are done.\n8. `.catch(reject)` rejects the main promise if any input promise rejects."
        }
      ]
    },
    {
      "id": "pq14",
      "title": "Deep Copy Object",
      "category": "JavaScript",
      "difficulty": "Medium",
      "description": "Write a JavaScript function to perform a deep copy of an object. This means creating a completely independent copy, where changes to the copied object do not affect the original, and vice versa, even for nested objects and arrays.",
      "methodology": {
        "approach": "Recursion and Type Checking",
        "explanation": "Deep copy can be achieved by recursively traversing the object and creating new objects and arrays for each level.  We need to handle different data types correctly.\n\n1. Create a function `deepCopy(obj)` that takes an object `obj` as input.\n2. Handle primitive types and null: If `obj` is not an object or is null, return `obj` directly (no need to copy primitives or null).\n3. Create a new object or array based on the type of `obj`.\n4. Iterate through the properties of `obj` (if it's an object) or elements (if it's an array).\n5. For each property/element, recursively call `deepCopy` to create a deep copy of the value.\n6. Assign the deep copied value to the corresponding property/element in the new object/array.\n7. Return the new object/array.",
        "timeComplexity": "O(N), where N is the total number of properties across all levels of the object, as we visit each property once.",
        "spaceComplexity": "O(D), where D is the maximum depth of the object. In the worst case (highly nested object), it could be O(N) if the object is essentially a linked list structure, due to recursion depth. In average cases, it's related to the nesting depth."
      },
      "examples": [
        {
          "input": "obj = { a: 1, b: { c: 2, d: [3, 4] } }",
          "output": "copiedObj = { a: 1, b: { c: 2, d: [3, 4] } }, where modifying `copiedObj` does not change `obj`.",
          "explanation": "After deep copying, changes to nested properties and arrays in `copiedObj` should not affect the original `obj`. For example, `copiedObj.b.c = 5` should not change `obj.b.c`."
        }
      ],
      "solutions": [
        {
          "approach": "Recursion and Type Checking",
          "code": "function deepCopy(obj) {\n  if (typeof obj !== 'object' || obj === null) {\n    return obj;\n  }\n\n  const copy = Array.isArray(obj) ? [] : {};\n\n  for (const key in obj) {\n    if (obj.hasOwnProperty(key)) { // Ensure we only copy own properties\n      copy[key] = deepCopy(obj[key]); // Recursive call for nested objects/arrays\n    }\n  }\n\n  return copy;\n}",
          "explanation": "1. `deepCopy` function takes an object `obj`.\n2. Base case: If `obj` is not an object or is null, return it directly.\n3. Create an empty array or object `copy` based on the type of `obj`.\n4. Iterate through `obj`'s properties using `for...in` loop.\n5. `hasOwnProperty(key)` ensures we copy only own properties, not inherited ones.\n6. Recursively call `deepCopy(obj[key])` to deep copy nested values.\n7. Assign the deep copied value to `copy[key]`.\n8. Return the `copy`."
        }
      ]
    },
    {
      "id": "pq15",
      "title": "Event Emitter",
      "category": "JavaScript",
      "difficulty": "Medium",
      "description": "Implement a simple Event Emitter class in JavaScript. It should have methods to `on(event, listener)`, `emit(event, ...args)`, and `off(event, listener)`.",
      "methodology": {
        "approach": "Object to Store Listeners",
        "explanation": "An Event Emitter manages event listeners and allows emitting events to trigger those listeners.\n\n1. Create a class `EventEmitter`.\n2. In the constructor, initialize a private property (using closure or symbol) `_listeners` as an empty object. This object will store event names as keys and arrays of listener functions as values.\n3. Implement `on(event, listener)` method:\n   - If `event` is not in `_listeners`, create a new empty array for it.\n   - Push the `listener` function into the array associated with the `event`.\n4. Implement `emit(event, ...args)` method:\n   - If `event` is in `_listeners`:\n     - Iterate through the array of listeners for the `event`.\n     - For each listener, call it with the provided `...args` using `apply` or `call` to maintain context.\n5. Implement `off(event, listener)` method:\n   - If `event` is in `_listeners`:\n     - Filter the array of listeners for the `event` to remove the specific `listener`.\n     - Update the `_listeners` object with the filtered array (or remove the event key if no listeners remain).",
        "timeComplexity": "O(1) for `on` and `emit` in most cases (assuming listener arrays are relatively small). O(n) for `off` and `emit` in the worst case where n is the number of listeners for a specific event, as we may need to iterate through or filter the listener array.",
        "spaceComplexity": "O(L), where L is the total number of listeners stored across all events. It depends on how many event listeners are registered.",
        "javascriptSpecific": true
      },
      "examples": [
        {
          "input": "emitter = new EventEmitter(); emitter.on('data', listener1); emitter.emit('data', 1, 2); emitter.off('data', listener1);",
          "output": "listener1 is called when 'data' event is emitted. After 'off', listener1 is no longer called for 'data' events.",
          "explanation": "The Event Emitter should allow registering listeners for events, emitting events to trigger listeners, and removing specific listeners."
        }
      ],
      "solutions": [
        {
          "approach": "Object to Store Listeners",
          "code": "class EventEmitter {\n  constructor() {\n    this._listeners = {}; // Using a plain object to store listeners\n  }\n\n  on(event, listener) {\n    if (!this._listeners[event]) {\n      this._listeners[event] = [];\n    }\n    this._listeners[event].push(listener);\n  }\n\n  emit(event, ...args) {\n    if (this._listeners[event]) {\n      this._listeners[event].forEach(listener => {\n        listener.apply(this, args); // Or listener(...args)\n      });\n    }\n  }\n\n  off(event, listenerToRemove) {\n    if (this._listeners[event]) {\n      this._listeners[event] = this._listeners[event].filter(listener => listener !== listenerToRemove);\n      if (this._listeners[event].length === 0) {\n        delete this._listeners[event]; // Clean up if no listeners left for event\n      }\n    }\n  }\n}",
          "explanation": "1. `EventEmitter` class is defined.\n2. `_listeners` object is initialized in the constructor.\n3. `on(event, listener)`: Adds a listener to the listeners array for the given event.\n4. `emit(event, ...args)`: Iterates through listeners for the event and calls each listener with provided arguments.\n5. `off(event, listenerToRemove)`: Filters the listeners array to remove the specified listener, and cleans up if no listeners remain for an event."
        }
      ]
    },
    {
      "id": "pq16",
      "title": "Implement Array.prototype.map",
      "category": "JavaScript",
      "difficulty": "Easy",
      "description": "Implement a polyfill for the `Array.prototype.map` method in JavaScript. It should take a callback function and return a new array with the results of calling the callback on every element in the original array.",
      "methodology": {
        "approach": "Iteration and Callback",
        "explanation": "Implementing `map` involves iterating over an array and applying a callback function to each element to create a new array.\n\n1. Extend `Array.prototype` by adding a new method `customMap`.\n2. Inside `customMap`, initialize an empty array `resultArray`.\n3. Iterate through the original array using a `for` loop.\n4. For each element in the original array, call the provided callback function with the element, index, and the original array as arguments.\n5. Push the return value of the callback function into `resultArray`.\n6. Return `resultArray` after iterating through all elements.",
        "timeComplexity": "O(n), where n is the length of the array, as we iterate through each element once.",
        "spaceComplexity": "O(n) to store the new `resultArray` of the same size as the input array.",
        "javascriptSpecific": true
      },
      "examples": [
        {
          "input": "[1, 2, 3].customMap(x => x * 2)",
          "output": "[2, 4, 6]",
          "explanation": "`customMap` should behave identically to `Array.prototype.map`, applying the callback function to each element and returning a new array with the results."
        }
      ],
      "solutions": [
        {
          "approach": "Iteration and Callback",
          "code": "if (!Array.prototype.customMap) {\n  Array.prototype.customMap = function(callback) {\n    if (typeof callback !== 'function') {\n      throw new TypeError('Callback is not a function');\n    }\n\n    const resultArray = [];\n    for (let i = 0; i < this.length; i++) {\n      if (i in this) { // Check if index is not empty (sparse arrays)\n        resultArray[i] = callback(this[i], i, this);\n      }\n    }\n    return resultArray;\n  };\n}",
          "explanation": "1. Check if `Array.prototype.customMap` already exists to avoid overwriting.\n2. Define `customMap` on `Array.prototype` as a function that takes a `callback`.\n3. Type check: Ensure `callback` is a function; throw `TypeError` if not.\n4. Initialize `resultArray`.\n5. Iterate through the array using a `for` loop.\n6. `if (i in this)` checks for sparse arrays, processing only existing indices.\n7. Call `callback` with current element, index, and the array itself.\n8. Push the callback's return value to `resultArray`.\n9. Return `resultArray`."
        }
      ]
    },
    {
      "id": "pq17",
      "title": "Implement Array.prototype.filter",
      "category": "JavaScript",
      "difficulty": "Easy",
      "description": "Implement a polyfill for the `Array.prototype.filter` method in JavaScript. It should take a callback function and return a new array containing only the elements for which the callback function returns true.",
      "methodology": {
        "approach": "Iteration and Predicate Callback",
        "explanation": "Implementing `filter` requires iterating over an array and using a callback function as a predicate to decide which elements to include in the new array.\n\n1. Extend `Array.prototype` with a new method `customFilter`.\n2. Inside `customFilter`, initialize an empty array `resultArray`.\n3. Iterate through the original array using a `for` loop.\n4. For each element, call the provided callback function (predicate) with the element, index, and the original array.\n5. If the callback function returns a truthy value, push the current element into `resultArray`.\n6. Return `resultArray` after iterating through all elements.",
        "timeComplexity": "O(n), where n is the length of the array, as we iterate through each element once.",
        "spaceComplexity": "O(n) in the worst case, if all elements pass the filter and are included in the new `resultArray`. In the best case (no elements pass), it's O(1). On average, it's proportional to the number of elements that pass the filter.",
        "javascriptSpecific": true
      },
      "examples": [
        {
          "input": "[1, 2, 3, 4].customFilter(x => x % 2 === 0)",
          "output": "[2, 4]",
          "explanation": "`customFilter` should behave like `Array.prototype.filter`, returning a new array with only the elements for which the callback returns true (even numbers in this case)."
        }
      ],
      "solutions": [
        {
          "approach": "Iteration and Predicate Callback",
          "code": "if (!Array.prototype.customFilter) {\n  Array.prototype.customFilter = function(callback) {\n    if (typeof callback !== 'function') {\n      throw new TypeError('Callback is not a function');\n    }\n\n    const resultArray = [];\n    for (let i = 0; i < this.length; i++) {\n      if (i in this) { // Handle sparse arrays\n        if (callback(this[i], i, this)) {\n          resultArray.push(this[i]);\n        }\n      }\n    }\n    return resultArray;\n  };\n}",
          "explanation": "1. Check if `Array.prototype.customFilter` exists.\n2. Define `customFilter` on `Array.prototype` taking a `callback`.\n3. Type check: Ensure `callback` is a function.\n4. Initialize `resultArray`.\n5. Iterate through the array.\n6. `if (i in this)` handles sparse arrays.\n7. Call `callback` (predicate) and check if it returns a truthy value.\n8. If truthy, push the current element to `resultArray`.\n9. Return `resultArray`."
        }
      ]
    },
     {
      "id": "pq18",
      "title": "Group Anagrams",
      "category": "Strings",
      "difficulty": "Medium",
      "description": "Given an array of strings strs, group the anagrams together. You can return the answer in any order.",
      "methodology": {
        "approach": "Hash Map and Sorting",
        "explanation": "To group anagrams, we can use a hash map where the key is the sorted version of a string, and the value is a list of anagrams that produce that sorted string.\n\n1. Create an empty hash map (JavaScript object or Map).\n2. Iterate through the input array of strings.\n3. For each string:\n   - Sort the characters of the string to create a canonical form (e.g., 'eat' becomes 'aet').\n   - Use the sorted string as the key in the hash map.\n   - If the key already exists in the map, append the current string to the list of anagrams associated with that key.\n   - If the key does not exist, create a new entry in the map with the sorted string as the key and a new list containing the current string as the value.\n4. After processing all strings, the values of the hash map will be lists of anagrams.\n5. Return the values of the hash map as an array of arrays.",
        "timeComplexity": "O(N * K log K), where N is the number of strings in the input array, and K is the maximum length of a string. For each string, we sort it, which takes O(K log K) time, and we do this for all N strings.",
        "spaceComplexity": "O(N * K) in the worst case, if all strings are anagrams of each other, we would store all strings in the hash map. The space is dominated by the storage of the anagram groups in the hash map.",
        "javascriptSpecific": false
      },
      "examples": [
        {
          "input": "strs = [\"eat\",\"tea\",\"tan\",\"ate\",\"nat\",\"bat\"]",
          "output": "[[\"bat\"],[\"nat\",\"tan\"],[\"ate\",\"eat\",\"tea\"]] ",
          "explanation": "The anagrams are grouped together. 'eat', 'tea', and 'ate' are anagrams, 'tan' and 'nat' are anagrams, and 'bat' is an anagram of itself."
        }
      ],
      "solutions": [
        {
          "approach": "Hash Map and Sorting",
          "code": "function groupAnagrams(strs) {\n  const anagramMap = new Map();\n\n  for (const str of strs) {\n    const sortedStr = str.split('').sort().join('');\n    if (!anagramMap.has(sortedStr)) {\n      anagramMap.set(sortedStr, []);\n    }\n    anagramMap.get(sortedStr).push(str);\n  }\n\n  return Array.from(anagramMap.values());\n}",
          "explanation": "1. Initialize an empty `anagramMap` (using JavaScript `Map`).\n2. Iterate through each string `str` in the input `strs` array.\n3. Sort the string `str` to get `sortedStr` (canonical form).\n4. Check if `sortedStr` is already a key in `anagramMap`.\n5. If not, create a new list for this `sortedStr` in the map.\n6. Push the original string `str` into the list associated with `sortedStr`.\n7. After processing all strings, convert the map's values (which are lists of anagrams) to an array and return it."
        }
      ]
    },
    {
      "id": "pq19",
      "title": "Memoized Factorial",
      "category": "Dynamic Programming",
      "difficulty": "Easy",
      "description": "Implement a memoized factorial function in JavaScript. Factorial of n is the product of all positive integers less than or equal to n.",
      "methodology": {
        "approach": "Memoization",
        "explanation": "Memoization is an optimization technique to speed up programs by storing the results of expensive function calls and returning the cached result when the same inputs occur again. For factorial, we can store the results in an object or Map.\n\n1. Create a function `memoizedFactorial(n, memo = {})` that takes an integer `n` and an optional `memo` object (cache).\n2. Base case: If `n` is 0 or 1, return 1.\n3. Check if the result for `n` is already in `memo`. If yes, return it directly.\n4. If not in memo, calculate factorial recursively: `factorial(n) = n * factorial(n - 1)`.\n5. Store the calculated result in `memo[n]` before returning it.\n6. Return the result.",
        "timeComplexity": "O(n) - each factorial value is computed only once and then retrieved from memo.",
        "spaceComplexity": "O(n) - to store the memoization cache, which can store up to n factorial values.",
        "javascriptSpecific": true
      },
      "examples": [
        {
          "input": "n = 5",
          "output": "120",
          "explanation": "5! = 5 * 4 * 3 * 2 * 1 = 120. The memoized function should efficiently calculate this and store intermediate results."
        }
      ],
      "solutions": [
        {
          "approach": "Memoization",
          "code": "function memoizedFactorial(n, memo = {}) {\n  if (n === 0 || n === 1) {\n    return 1;\n  }\n  if (memo[n]) {\n    return memo[n];\n  }\n\n  memo[n] = n * memoizedFactorial(n - 1, memo);\n  return memo[n];\n}",
          "explanation": "1. `memoizedFactorial(n, memo)` function.\n2. Base cases: `n=0` or `n=1` returns 1.\n3. Check `memo[n]`: if exists, return cached value.\n4. Recursive step: `memo[n] = n * memoizedFactorial(n-1, memo)`.\n5. Store and return the calculated factorial in `memo[n]`."
        }
      ]
    },
    {
      "id": "pq20",
      "title": "Check for Balanced Parentheses",
      "category": "Stacks & Queues",
      "difficulty": "Easy",
      "description": "Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid. An input string is valid if:\n1. Open brackets must be closed by the same type of brackets.\n2. Open brackets must be closed in the correct order.",
      "methodology": {
        "approach": "Stack",
        "explanation": "We can use a stack to solve this problem. Iterate through the string:\n\n1. If we encounter an opening bracket ('(', '{', '['), push it onto the stack.\n2. If we encounter a closing bracket (')', '}', ']'), pop from the stack and check if the popped bracket is the corresponding opening bracket. If not, or if the stack is empty, the string is invalid.\n3. After iterating through the entire string, if the stack is empty, the string is valid. Otherwise, it's invalid (unclosed brackets).",
        "timeComplexity": "O(n) - we iterate through the string once.",
        "spaceComplexity": "O(n) in the worst case - if the string contains only opening brackets, they will all be pushed onto the stack.",
        "javascriptSpecific": false
      },
      "examples": [
        {
          "input": "()[]{}{}",
          "output": "true",
          "explanation": "All brackets are correctly matched and ordered."
        },
        {
          "input": "(]",
          "output": "false",
          "explanation": "Opening '(' is not closed by a corresponding ')'."
        },
        {
          "input": "([)]",
          "output": "false",
          "explanation": "Brackets are not closed in the correct order. ')' should close before ']'."
        }
      ],
      "solutions": [
        {
          "approach": "Stack",
          "code": "function isValidParentheses(s) {\n  const stack = [];\n  const map = {\n    ')': '(',\n    '}': '{',\n    ']': '['\n  };\n\n  for (let char of s) {\n    if (map[char]) { // Closing bracket\n      const topElement = stack.pop() || '#'; // Pop or default value if stack is empty\n      if (topElement !== map[char]) {\n        return false; // Mismatched closing bracket\n      }\n    } else { // Opening bracket\n      stack.push(char);\n    }\n  }\n  return stack.length === 0; // Stack should be empty at the end for valid string\n}",
          "explanation": "1. Initialize an empty `stack` and a `map` for bracket pairs.\n2. Iterate through the input string `s`.\n3. If `char` is a closing bracket (in `map`):\n   - Pop from `stack` (or '#' if empty) as `topElement`.\n   - Check if `topElement` is the corresponding opening bracket from `map[char]`.\n   - If mismatch, return `false`.\n4. If `char` is an opening bracket, push it to `stack`.\n5. After loop, return `true` if `stack` is empty, `false` otherwise."
        }
      ]
    },
    {
      "id": "pq21",
      "title": "Implement Array.prototype.reduce",
      "category": "JavaScript",
      "difficulty": "Medium",
      "description": "Implement a polyfill for the `Array.prototype.reduce` method in JavaScript. It should execute a reducer function (that you provide) on each element of the array, resulting in single output value.",
      "methodology": {
        "approach": "Iteration and Accumulator",
        "explanation": "Implementing `reduce` requires iterating over an array and applying a reducer callback function to accumulate a single value. It takes a reducer function and an optional initial value.\n\n1. Extend `Array.prototype` with a new method `customReduce`.\n2. Inside `customReduce`, handle the initial value. If not provided, use the first element of the array as initial value and start iteration from the second element.\n3. Initialize an accumulator variable with the initial value.\n4. Iterate through the array (starting from the first or second element depending on initial value).\n5. In each iteration, call the reducer callback function with the accumulator, current element, current index, and the original array.\n6. Update the accumulator with the return value of the reducer function.\n7. Return the final accumulator value after iteration.",
        "timeComplexity": "O(n), where n is the length of the array, as we iterate through each element once.",
        "spaceComplexity": "O(1) - constant space, as we only use a few variables (accumulator, index, etc.).",
        "javascriptSpecific": true
      },
      "examples": [
        {
          "input": "[1, 2, 3, 4].customReduce((acc, curr) => acc + curr, 0)",
          "output": "10",
          "explanation": "`customReduce` should behave like `Array.prototype.reduce`, summing up all elements with an initial value of 0."
        },
        {
          "input": "[1, 2, 3].customReduce((acc, curr) => acc * curr)",
          "output": "6",
          "explanation": "If no initial value is provided, the first element is used as initial accumulator, and the reducer starts from the second element."
        }
      ],
      "solutions": [
        {
          "approach": "Iteration and Accumulator",
          "code": "if (!Array.prototype.customReduce) {\n  Array.prototype.customReduce = function(callback, initialValue) {\n    if (typeof callback !== 'function') {\n      throw new TypeError('Callback is not a function');\n    }\n    if (this === null || this === undefined) {\n      throw new TypeError('Cannot read property 'reduce' of null or undefined');\n    }\n\n    let accumulator = initialValue === undefined ? this[0] : initialValue;\n    let startIndex = initialValue === undefined ? 1 : 0;\n\n    for (let i = startIndex; i < this.length; i++) {\n      if (i in this) { // Handle sparse arrays\n        accumulator = callback(accumulator, this[i], i, this);\n      }\n    }\n    return accumulator;\n  };\n}",
          "explanation": "1. Check if `Array.prototype.customReduce` exists.\n2. Define `customReduce` on `Array.prototype`, taking `callback` and optional `initialValue`.\n3. Type check: Ensure `callback` is a function. Handle null/undefined `this`.\n4. Determine initial `accumulator` and `startIndex` based on `initialValue`.\n5. Iterate from `startIndex` to array length.\n6. `if (i in this)` handles sparse arrays.\n7. Call `callback` with `accumulator`, current element, index, and array.\n8. Update `accumulator` with callback's return value.\n9. Return final `accumulator`."
        }
      ]
    },
    {
      "id": "pq22",
      "title": "Find the Missing Number",
      "category": "Arrays",
      "difficulty": "Easy",
      "description": "Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array.",
      "methodology": {
        "approach": "Summation or XOR",
        "explanation": "There are a couple of efficient ways to solve this:\n\n1. Summation Approach:\n   - Calculate the expected sum of numbers from 0 to n using the formula `n*(n+1)/2`.\n   - Calculate the actual sum of numbers in the given array.\n   - The missing number is the difference between the expected sum and the actual sum.\n\n2. XOR Approach:\n   - Initialize a variable `xorSum` to 0.\n   - XOR `xorSum` with all numbers from 0 to n.\n   - XOR `xorSum` with all numbers in the input array.\n   - The final value of `xorSum` is the missing number.",
        "timeComplexity": "O(n) for both approaches - iterating through the array and range once.",
        "spaceComplexity": "O(1) for both approaches - constant extra space.",
        "javascriptSpecific": false
      },
      "examples": [
        {
          "input": "nums = [3, 0, 1]",
          "output": "2",
          "explanation": "n = 3, so the expected numbers are [0, 1, 2, 3]. 2 is missing from the input array."
        },
        {
          "input": "nums = [9, 6, 4, 2, 3, 5, 7, 0, 1]",
          "output": "8",
          "explanation": "n = 9, expected range [0, 9]. 8 is missing."
        }
      ],
      "solutions": [
        {
          "approach": "Summation",
          "code": "function missingNumberSum(nums) {\n  const n = nums.length;\n  const expectedSum = (n * (n + 1)) / 2;\n  let actualSum = 0;\n  for (let num of nums) {\n    actualSum += num;\n  }\n  return expectedSum - actualSum;\n}",
          "explanation": "1. Get `n` (length of `nums`).\n2. Calculate `expectedSum` of numbers from 0 to n.\n3. Calculate `actualSum` of numbers in `nums`.\n4. Return `expectedSum - actualSum` (missing number)."
        },
        {
          "approach": "XOR",
          "code": "function missingNumberXOR(nums) {\n  let xorSum = 0;\n  const n = nums.length;\n  for (let i = 0; i <= n; i++) { // XOR with range [0, n]\n    xorSum ^= i;\n  }\n  for (let num of nums) { // XOR with array elements\n    xorSum ^= num;\n  }\n  return xorSum;\n}",
          "explanation": "1. Initialize `xorSum = 0`.\n2. XOR `xorSum` with numbers from 0 to n.\n3. XOR `xorSum` with each number in `nums`.\n4. Return `xorSum` (missing number)."
        }
      ]
    },
    {
      "id": "pq23",
      "title": "Implement Promise.retry",
      "category": "JavaScript",
      "difficulty": "Hard",
      "description": "Implement a function `retry(fn, retries)` in JavaScript that takes a function `fn` (which returns a Promise) and a number of `retries`. The `retry` function should execute `fn` and if it rejects, it should retry executing `fn` up to `retries` times. If all retries fail, the promise should reject with the last error.",
      "methodology": {
        "approach": "Recursion and Promise Chaining",
        "explanation": "Implementing `promise.retry` involves recursively calling the function that returns a promise and handling rejections to attempt retries.\n\n1. Create a function `retry(fn, retries)` that takes a promise-returning function `fn` and number of `retries`.\n2. Inside `retry`, return a new Promise.\n3. In the promise executor, define a recursive helper function `attempt()`.\n4. Inside `attempt()`:\n   - Call `fn()`.\n   - Use `.then()` to handle successful resolution and resolve the main promise with the result.\n   - Use `.catch()` to handle rejection:\n     - If `retries` is greater than 0, decrement `retries` and recursively call `attempt()` to retry.\n     - If `retries` is 0 (no more retries left), reject the main promise with the error.\n5. Initiate the retry process by calling `attempt()` once.",
        "timeComplexity": "O(R * T), where R is the number of retries and T is the time complexity of the function `fn`. In the worst case, `fn` is called R+1 times.",
        "spaceComplexity": "O(R) in the worst case due to recursive call stack depth being proportional to the number of retries.",
        "javascriptSpecific": true
      },
      "examples": [
        {
          "input": "retry(() => fetch('api-endpoint'), 3)",
          "output": "A promise that resolves if fetch succeeds within 3 retries, or rejects if all retries fail.",
          "explanation": "`retry` should automatically retry the `fetch` call if it initially fails, up to 3 times. If it still fails after 3 retries, the error should be propagated."
        }
      ],
      "solutions": [
        {
          "approach": "Recursion and Promise Chaining",
          "code": "function retry(fn, retries) {\n  return new Promise((resolve, reject) => {\n    function attempt() {\n      fn()\n        .then(resolve)\n        .catch(err => {\n          if (retries > 0) {\n            retries--;\n            attempt(); // Retry\n          } else {\n            reject(err); // Reject after all retries failed\n          }\n        });\n    }\n    attempt(); // Initial attempt\n  });\n}",
          "explanation": "1. `retry(fn, retries)` returns a new `Promise`.\n2. `attempt()` is a recursive helper function within the promise executor.\n3. `attempt()` calls `fn()`.\n4. `.then(resolve)`: if `fn()` resolves, resolve the main promise.\n5. `.catch(err)`: if `fn()` rejects:\n   - If `retries > 0`, decrement `retries` and call `attempt()` again (retry).\n   - If `retries <= 0`, reject the main promise with the `err`.\n6. Initial call to `attempt()` starts the process."
        }
      ]
    },
    {
      "id": "pq24",
      "title": "Implement Array.prototype.flat",
      "category": "JavaScript",
      "difficulty": "Medium",
      "description": "Implement a polyfill for the `Array.prototype.flat` method in JavaScript. It should flatten a nested array up to a specified depth. If depth is not specified, it should flatten up to depth 1.",
      "methodology": {
        "approach": "Recursion and Array Concatenation",
        "explanation": "Implementing `flat` requires recursively traversing the array and flattening nested arrays up to a given depth.\n\n1. Extend `Array.prototype` with a new method `customFlat`.\n2. Inside `customFlat`, take an optional `depth` argument (default to 1 if not provided).\n3. Initialize an empty array `resultArray`.\n4. Iterate through the original array.\n5. For each element:\n   - If the element is an array and `depth > 0`, recursively call `customFlat` on the element with `depth - 1` and concatenate the result to `resultArray`.\n   - If the element is not an array or `depth` is 0, push the element directly to `resultArray`.\n6. Return `resultArray`.",
        "timeComplexity": "O(N*D), where N is the total number of elements in the nested array, and D is the depth of flattening. In the worst case, we might visit each element up to D times.",
        "spaceComplexity": "O(N*D) in the worst case, to store the flattened array and due to recursive call stack.",
        "javascriptSpecific": true
      },
      "examples": [
        {
          "input": "[1, 2, [3, 4, [5, 6]]].customFlat(2)",
          "output": "[1, 2, 3, 4, 5, 6]",
          "explanation": "Flattening up to depth 2 should completely flatten the array in this case."
        },
        {
          "input": "[1, 2, [3, 4, [5, 6]]].customFlat(1)",
          "output": "[1, 2, 3, 4, [5, 6]]",
          "explanation": "Flattening up to depth 1 only flattens the first level of nesting."
        },
        {
          "input": "[1, [2, 3], [4, [5, 6]]].customFlat()",
          "output": "[1, 2, 3, 4, [5, 6]]",
          "explanation": "Default depth is 1 if no depth is specified."
        }
      ],
      "solutions": [
        {
          "approach": "Recursion and Array Concatenation",
          "code": "if (!Array.prototype.customFlat) {\n  Array.prototype.customFlat = function(depth = 1) {\n    const resultArray = [];\n    for (let element of this) {\n      if (Array.isArray(element) && depth > 0) {\n        resultArray.push(...element.customFlat(depth - 1)); // Recursive call and spread\n      } else {\n        resultArray.push(element);\n      }\n    }\n    return resultArray;\n  };\n}",
          "explanation": "1. Check if `Array.prototype.customFlat` exists.\n2. Define `customFlat` on `Array.prototype` with optional `depth` (default 1).\n3. Initialize `resultArray`.\n4. Iterate through the array.\n5. If `element` is an array and `depth > 0`:\n   - Recursively call `customFlat(depth - 1)` on `element`.\n   - Spread the result and push into `resultArray`.\n6. Else (not array or depth 0), push `element` directly to `resultArray`.\n7. Return `resultArray`."
        }
      ]
    },
    {
      "id": "pq25",
      "title": "Implement Object.create",
      "category": "JavaScript",
      "difficulty": "Medium",
      "description": "Implement a polyfill for the `Object.create` method in JavaScript. It should create a new object with the specified prototype object and optional properties.",
      "methodology": {
        "approach": "Prototypal Inheritance",
        "explanation": "`Object.create` creates a new object with a specified prototype. If a prototype is provided, the new object will inherit properties and methods from it. If properties are also provided, they are added as own properties to the new object.\n\n1. Implement a function `objectCreatePolyfill(proto, propertiesObject)` that takes a `proto` object (prototype) and an optional `propertiesObject`.\n2. If `proto` is not an object and not null, throw a `TypeError`.\n3. Create a new constructor function `F`.\n4. Set `F.prototype` to `proto`.\n5. Create a new object by calling `new F()`. This object will inherit from `proto`.\n6. If `propertiesObject` is provided, use `Object.defineProperties` to add properties to the newly created object.\n7. Return the newly created object.",
        "timeComplexity": "O(P), where P is the number of properties in `propertiesObject` if provided, due to `Object.defineProperties`. Otherwise, it's O(1).",
        "spaceComplexity": "O(1) - constant space, mainly for the constructor function and the new object.",
        "javascriptSpecific": true
      },
      "examples": [
        {
          "input": "objectCreatePolyfill({ x: 1 })",
          "output": "A new object that inherits from { x: 1 }.",
          "explanation": "The created object should have { x: 1 } as its prototype."
        },
        {
          "input": "objectCreatePolyfill({ y: 2 }, { z: { value: 3, enumerable: true } })",
          "output": "A new object that inherits from { y: 2 } and has own property z: 3.",
          "explanation": "The created object should inherit from { y: 2 } and also have own property 'z' with value 3."
        }
      ],
      "solutions": [
        {
          "approach": "Prototypal Inheritance",
          "code": "function objectCreatePolyfill(proto, propertiesObject) {\n  if (typeof proto !== 'object' && typeof proto !== 'function' && proto !== null) {\n    throw new TypeError('Object prototype may only be an Object: ' + proto);\n  }\n\n  function F() {}\n  F.prototype = proto;\n  const obj = new F();\n\n  if (propertiesObject !== undefined) {\n    Object.defineProperties(obj, propertiesObject);\n  }\n\n  return obj;\n}",
          "explanation": "1. `objectCreatePolyfill(proto, propertiesObject)` function.\n2. Type check: `proto` must be object, function, or null.\n3. Define constructor `F`.\n4. Set `F.prototype = proto` to establish inheritance.\n5. Create `obj = new F()` â inherits from `proto`.\n6. If `propertiesObject` provided, use `Object.defineProperties` to add properties.\n7. Return `obj`."
        }
      ]
    },
    {
      "id": "pq26",
      "title": "Longest Common Prefix",
      "category": "Strings",
      "difficulty": "Easy",
      "description": "Write a function to find the longest common prefix string amongst an array of strings. If there is no common prefix, return an empty string \"\".",
      "methodology": {
        "approach": "Horizontal Scanning",
        "explanation": "One efficient approach is horizontal scanning. We compare the first string with the second to find the common prefix, then compare this prefix with the third string, and so on.\n\n1. If the input array is empty, return \"\".\n2. Initialize `prefix` to the first string in the array.\n3. Iterate through the rest of the strings in the array (starting from the second string).\n4. For each string, while the current string does not start with `prefix`, shorten `prefix` by removing the last character.\n5. If `prefix` becomes empty at any point, it means there is no common prefix, so return \"\".\n6. After iterating through all strings, return the final `prefix`.",
        "timeComplexity": "O(S), where S is the sum of all characters in all strings in the worst case. In the best case, where strings have very short common prefix or no common prefix, it can be closer to O(N*K) where N is the number of strings and K is the length of the shortest string.",
        "spaceComplexity": "O(1) - constant extra space.",
        "javascriptSpecific": false
      },
      "examples": [
        {
          "input": "strs = [\"flower\",\"flow\",\"flight\"]",
          "output": "\"fl\"",
          "explanation": "The longest common prefix is \"fl\"."
        },
        {
          "input": "strs = [\"dog\",\"racecar\",\"car\"]",
          "output": "\"\"",
          "explanation": "There is no common prefix."
        },
        {
          "input": "strs = [\"\"]",
          "output": "\"\"",
          "explanation": "Empty input array or array containing empty string results in empty prefix."
        }
      ],
      "solutions": [
        {
          "approach": "Horizontal Scanning",
          "code": "function longestCommonPrefix(strs) {\n  if (!strs || strs.length === 0) {\n    return \"\";\n  }\n\n  let prefix = strs[0];\n  for (let i = 1; i < strs.length; i++) {\n    while (strs[i].indexOf(prefix) !== 0) { // While current string doesn't start with prefix\n      prefix = prefix.substring(0, prefix.length - 1); // Shorten prefix\n      if (prefix === \"\") {\n        return \"\"; // No common prefix\n      }\n    }\n  }\n  return prefix;\n}",
          "explanation": "1. Handle empty or null input `strs`.\n2. Initialize `prefix` with the first string.\n3. Iterate from the second string onwards.\n4. `while (strs[i].indexOf(prefix) !== 0)`: While current string doesn't start with `prefix`.\n5. `prefix = prefix.substring(0, prefix.length - 1)`: Shorten prefix from the end.\n6. `if (prefix === \"\")`: If prefix becomes empty, return \"\".\n7. Return final `prefix` after checking all strings."
        }
      ]
    },
    {
      "id": "pq27",
      "title": "Implement Array.prototype.forEach",
      "category": "JavaScript",
      "difficulty": "Easy",
      "description": "Implement a polyfill for the `Array.prototype.forEach` method in JavaScript. It should execute a provided function once for each array element.",
      "methodology": {
        "approach": "Iteration and Callback",
        "explanation": "Implementing `forEach` involves iterating through an array and calling a provided callback function for each element.\n\n1. Extend `Array.prototype` with a new method `customForEach`.\n2. Inside `customForEach`, take a `callback` function as an argument.\n3. Iterate through the original array using a `for` loop.\n4. For each element in the array, call the `callback` function with the element, index, and the original array as arguments.\n5. `forEach` does not return a value, so `customForEach` should also not return anything (or implicitly return `undefined`).",
        "timeComplexity": "O(n), where n is the length of the array, as we iterate through each element once.",
        "spaceComplexity": "O(1) - constant space, as we only use a few variables for iteration.",
        "javascriptSpecific": true
      },
      "examples": [
        {
          "input": "[1, 2, 3].customForEach(x => console.log(x * 2))",
          "output": "Logs 2, 4, 6 to the console.",
          "explanation": "`customForEach` should behave like `Array.prototype.forEach`, executing the callback for each element without returning a new array."
        }
      ],
      "solutions": [
        {
          "approach": "Iteration and Callback",
          "code": "if (!Array.prototype.customForEach) {\n  Array.prototype.customForEach = function(callback) {\n    if (typeof callback !== 'function') {\n      throw new TypeError('Callback is not a function');\n    }\n    if (this === null || this === undefined) {\n      throw new TypeError('Cannot read property 'forEach' of null or undefined');\n    }\n\n    for (let i = 0; i < this.length; i++) {\n      if (i in this) { // Handle sparse arrays\n        callback(this[i], i, this);\n      }\n    }\n  };\n}",
          "explanation": "1. Check if `Array.prototype.customForEach` exists.\n2. Define `customForEach` on `Array.prototype`, taking `callback`.\n3. Type check: Ensure `callback` is a function. Handle null/undefined `this`.\n4. Iterate through the array using a `for` loop.\n5. `if (i in this)` handles sparse arrays.\n6. Call `callback` with current element, index, and the array.\n7. `customForEach` returns `undefined` implicitly, like native `forEach`."
        }
      ]
    },
    {
      "id": "pq28",
      "title": "Find First Non-Repeating Character",
      "category": "Strings",
      "difficulty": "Easy",
      "description": "Given a string, find the first non-repeating character in it and return its index. If it doesn't exist, return -1.",
      "methodology": {
        "approach": "Frequency Counting and Iteration",
        "explanation": "We can use a frequency count approach to solve this problem. First, count the frequency of each character in the string. Then, iterate through the string again and find the first character with a frequency of 1.\n\n1. Create a frequency map (object or Map) to store the count of each character in the string.\n2. Iterate through the string and update the frequency count in the map for each character.\n3. Iterate through the string again in order.\n4. For each character, check its frequency in the frequency map. If the frequency is 1, return the current index.\n5. If no character with frequency 1 is found after iterating through the entire string, return -1.",
        "timeComplexity": "O(n) - we iterate through the string twice in the worst case.",
        "spaceComplexity": "O(1) - constant space for the frequency map, as the alphabet size is constant (e.g., 26 for lowercase English letters, or 256 for ASCII).",
        "javascriptSpecific": false
      },
      "examples": [
        {
          "input": "leetcode",
          "output": "0",
          "explanation": "The first non-repeating character is 'l' at index 0."
        },
        {
          "input": "loveleetcode",
          "output": "2",
          "explanation": "The first non-repeating character is 'v' at index 2."
        },
        {
          "input": "aabbcc",
          "output": "-1",
          "explanation": "All characters are repeating."
        }
      ],
      "solutions": [
        {
          "approach": "Frequency Counting and Iteration",
          "code": "function firstNonRepeatingChar(s) {\n  const charFrequencyMap = {};\n  for (let char of s) { // Count character frequencies\n    charFrequencyMap[char] = (charFrequencyMap[char] || 0) + 1;\n  }\n\n  for (let i = 0; i < s.length; i++) { // Find first non-repeating char\n    if (charFrequencyMap[s[i]] === 1) {\n      return i;\n    }\n  }\n  return -1;\n}",
          "explanation": "1. Initialize `charFrequencyMap` (object) to count frequencies.\n2. First loop: iterate through `s`, count frequency of each char.\n3. Second loop: iterate through `s` again by index.\n4. `if (charFrequencyMap[s[i]] === 1)`: check if frequency is 1.\n5. If frequency is 1, return current index `i`.\n6. If loop finishes without finding, return -1."
        }
      ]
    },
    {
      "id": "pq29",
      "title": "Implement Promise.finally",
      "category": "JavaScript",
      "difficulty": "Medium",
      "description": "Implement a polyfill for the `Promise.prototype.finally` method in JavaScript. It should execute a provided callback function after a promise is settled (either resolved or rejected), regardless of the promise's outcome.",
      "methodology": {
        "approach": "Promise Chaining and Callback Execution",
        "explanation": "`Promise.finally` ensures a callback is executed after a promise settles. The callback is not supposed to affect the promise's value or rejection reason.\n\n1. Extend `Promise.prototype` with a new method `customFinally`.\n2. Inside `customFinally`, take a `callback` function as an argument.\n3. Return a new `Promise`.\n4. In the new promise's executor, use `.then()` and `.catch()` on the original promise to handle both resolution and rejection.\n5. In both `.then()` and `.catch()` handlers:\n   - Execute the `callback` function.\n   - If the original promise resolved, resolve the new promise with the original value.\n   - If the original promise rejected, reject the new promise with the original reason.\n   - Use `Promise.resolve()` and `Promise.reject()` to correctly propagate the original outcome after the callback execution.",
        "timeComplexity": "O(1) for `customFinally` itself. The execution time depends on the original promise and the callback function.",
        "spaceComplexity": "O(1) - constant space, mainly for the new promise and the callback.",
        "javascriptSpecific": true
      },
      "examples": [
        {
          "input": "fetchData().customFinally(() => console.log('Fetch operation completed'))",
          "output": "Logs 'Fetch operation completed' to the console after fetchData() promise resolves or rejects.",
          "explanation": "`customFinally` should execute the callback regardless of whether `fetchData()` resolves or rejects, and it should not change the final outcome of the promise."
        }
      ],
      "solutions": [
        {
          "approach": "Promise Chaining and Callback Execution",
          "code": "if (!Promise.prototype.customFinally) {\n  Promise.prototype.customFinally = function(callback) {\n    return this.then(\n      value => Promise.resolve(callback()).then(() => value),\n      reason => Promise.resolve(callback()).then(() => { throw reason; })\n    );\n  };\n}",
          "explanation": "1. Check if `Promise.prototype.customFinally` exists.\n2. Define `customFinally` on `Promise.prototype`, taking `callback`.\n3. Return `this.then(...)`: chain onto the original promise.\n4. `.then(value => ...)`: handle resolution:\n   - `Promise.resolve(callback()).then(() => value)`: execute callback, then resolve with original `value`.\n5. `.then(..., reason => ...)`: handle rejection:\n   - `Promise.resolve(callback()).then(() => { throw reason; })`: execute callback, then reject with original `reason`.\n   - `Promise.resolve(callback())` ensures callback completion before resolving/rejecting."
        }
      ]
    },
    {
      "id": "pq30",
      "title": "Implement a Basic Calculator",
      "category": "Stacks & Queues",
      "difficulty": "Hard",
      "description": "Implement a basic calculator to evaluate a simple expression string. The expression string may contain non-negative integers, '+', '-', '*', '/' operators and empty spaces. Integer division should truncate toward zero.",
      "methodology": {
        "approach": "Stack and Operator Precedence",
        "explanation": "To implement a basic calculator, we can use stacks and handle operator precedence. We can use one stack for numbers and implicitly manage operators based on precedence. For simplicity, we'll handle +, -, *, / in order of precedence (multiplication and division before addition and subtraction).\n\n1. Initialize a stack `stack` to store numbers.\n2. Initialize `currentNumber` to 0 and `operation` to '+'.\n3. Iterate through the input string `s` character by character.\n4. If the character is a digit, update `currentNumber`.\n5. If the character is an operator (+, -, *, /) or we reach the end of the string:\n   - Perform the operation based on the `operation` and `currentNumber` with the top of the stack (or push `currentNumber` if stack is empty or for '+' initially).\n     - '+': Push `currentNumber` to the stack.\n     - '-': Push `-currentNumber` to the stack.\n     - '*': Pop the top number, multiply by `currentNumber`, and push the result.\n     - '/': Pop the top number, integer divide by `currentNumber` (truncate toward zero), and push the result.\n   - Update `operation` to the current character.\n   - Reset `currentNumber` to 0.\n6. After iterating through the string, sum up all numbers in the stack to get the final result.",
        "timeComplexity": "O(n), where n is the length of the input string, as we iterate through the string once.",
        "spaceComplexity": "O(n) in the worst case, if the expression contains only additions and subtractions, and numbers are pushed onto the stack.",
        "javascriptSpecific": false
      },
      "examples": [
        {
          "input": "3+2*2",
          "output": "7",
          "explanation": "3 + (2 * 2) = 7"
        },
        {
          "input": " 3/2 ",
          "output": "1",
          "explanation": "Integer division 3 / 2 = 1"
        },
        {
          "input": " 3+5 / 2 ",
          "output": "5",
          "explanation": "3 + (5 / 2) = 3 + 2 = 5"
        }
      ],
      "solutions": [
        {
          "approach": "Stack and Operator Precedence",
          "code": "function calculateBasic(s) {\n  const stack = [];\n  let currentNumber = 0;\n  let operation = '+';\n\n  for (let i = 0; i < s.length; i++) {\n    const char = s[i];\n    if (!isNaN(parseInt(char))) { // Digit\n      currentNumber = (currentNumber * 10) + parseInt(char);\n    } else if (['+', '-', '*', '/'].includes(char)) { // Operator\n      if (operation === '+') {\n        stack.push(currentNumber);\n      } else if (operation === '-') {\n        stack.push(-currentNumber);\n      } else if (operation === '*') {\n        stack.push(stack.pop() * currentNumber);\n      } else if (operation === '/') {\n        stack.push(parseInt(stack.pop() / currentNumber)); // Integer division\n      }\n      operation = char;\n      currentNumber = 0;\n    }\n  }\n\n  // Last operation\n  if (operation === '+') {\n    stack.push(currentNumber);\n  } else if (operation === '-') {\n    stack.push(-currentNumber);\n  } else if (operation === '*') {\n    stack.push(stack.pop() * currentNumber);\n  } else if (operation === '/') {\n    stack.push(parseInt(stack.pop() / currentNumber));\n  }\n\n  let result = 0;\n  while (stack.length > 0) {\n    result += stack.pop();\n  }\n  return result;\n}",
          "explanation": "1. Initialize `stack`, `currentNumber`, `operation ('+')`.\n2. Iterate through string `s`.\n3. If digit, update `currentNumber`.\n4. If operator or end of string:\n   - Perform operation based on `operation` and `currentNumber` using `stack`.\n     - '+', '-': push directly (or negative for '-').\n     - '*', '/': pop, calculate, push result.\n   - Update `operation` to current char.\n   - Reset `currentNumber = 0`.\n5. After loop, handle last operation.\n6. Sum up elements in `stack` to get `result`."
        }
      ]
    },
    {
      "id": "pq31",
      "title": "Implement Array Chunking",
      "category": "Arrays",
      "difficulty": "Easy",
      "description": "Write a function that chunks an array into subarrays of a specified size.",
      "methodology": {
        "approach": "Iteration and Array Slicing",
        "explanation": "We can iterate through the array and create chunks of the specified size using array slicing or by building up chunks iteratively.\n\n1. Initialize an empty array `chunkedArray` to store the chunks.\n2. Iterate through the input array using a loop.\n3. For each element, check if a chunk already exists in `chunkedArray`.\n4. If no chunk exists or the last chunk is full (reached the specified size), create a new chunk (subarray) and push the current element into it.\n5. If a chunk exists and it's not full, push the current element into the last chunk.\n6. Return `chunkedArray`.",
        "timeComplexity": "O(n), where n is the length of the array, as we iterate through each element once.",
        "spaceComplexity": "O(n/k), where n is the length of the array and k is the chunk size, in the worst case where every chunk is filled. It's proportional to the number of chunks created.",
        "javascriptSpecific": true
      },
      "examples": [
        {
          "input": "array = [1, 2, 3, 4, 5, 6, 7, 8], size = 3",
          "output": "[[1, 2, 3], [4, 5, 6], [7, 8]]",
          "explanation": "The array is chunked into subarrays of size 3."
        },
        {
          "input": "array = [1, 2, 3, 4, 5], size = 2",
          "output": "[[1, 2], [3, 4], [5]]",
          "explanation": "The array is chunked into subarrays of size 2, with the last chunk having fewer elements."
        }
      ],
      "solutions": [
        {
          "approach": "Iterative Chunking",
          "code": "function chunkArray(array, size) {\n  const chunkedArray = [];\n  for (let i = 0; i < array.length; i++) {\n    const lastChunk = chunkedArray[chunkedArray.length - 1];\n    if (!lastChunk || lastChunk.length === size) {\n      chunkedArray.push([array[i]]);\n    } else {\n      lastChunk.push(array[i]);\n    }\n  }\n  return chunkedArray;\n}",
          "explanation": "1. Initialize `chunkedArray`.\n2. Iterate through the input `array`.\n3. Get `lastChunk` from `chunkedArray`.\n4. If no `lastChunk` or `lastChunk` is full, create a new chunk with current element and push to `chunkedArray`.\n5. Else, push the current element to `lastChunk`.\n6. Return `chunkedArray`."
        },
        {
          "approach": "Array Slice",
          "code": "function chunkArraySlice(array, size) {\n  const chunkedArray = [];\n  let index = 0;\n  while (index < array.length) {\n    chunkedArray.push(array.slice(index, index + size));\n    index += size;\n  }\n  return chunkedArray;\n}",
          "explanation": "1. Initialize `chunkedArray` and `index = 0`.\n2. `while (index < array.length)`: loop while index is within array bounds.\n3. `chunkedArray.push(array.slice(index, index + size))`: slice a chunk from `array` and push to `chunkedArray`.\n4. `index += size`: increment index by chunk `size`.\n5. Return `chunkedArray`."
        }
      ]
    },
    {
      "id": "pq32",
      "title": "Check if Object is Empty",
      "category": "JavaScript",
      "difficulty": "Easy",
      "description": "Write a JavaScript function to check if an object is empty (contains no own properties).",
      "methodology": {
        "approach": "Object.keys() and Length Check",
        "explanation": "We can use `Object.keys()` to get an array of the object's own enumerable property names. If this array is empty, the object is empty.\n\n1. Create a function `isObjectEmpty(obj)` that takes an object `obj` as input.\n2. Use `Object.keys(obj)` to get an array of keys.\n3. Check the `length` of the keys array. If it's 0, return `true` (object is empty).\n4. Otherwise, return `false` (object is not empty).",
        "timeComplexity": "O(1) on average, as `Object.keys` for empty or small objects is generally fast. In the worst case, it could be O(n) where n is the number of properties, but for this specific task (checking emptiness), it's efficient.",
        "spaceComplexity": "O(1) - constant space for the keys array (negligible for emptiness check).",
        "javascriptSpecific": true
      },
      "examples": [
        {
          "input": "obj1 = {}",
          "output": "true",
          "explanation": "obj1 is an empty object."
        },
        {
          "input": "obj2 = { a: 1 }",
          "output": "false",
          "explanation": "obj2 is not an empty object as it has property 'a'."
        }
      ],
      "solutions": [
        {
          "approach": "Object.keys() Length Check",
          "code": "function isObjectEmpty(obj) {\n  return Object.keys(obj).length === 0;\n}",
          "explanation": "1. `Object.keys(obj)`: Get array of object's own property names.\n2. `.length === 0`: Check if the array length is 0.\n3. Return `true` if length is 0 (empty object), `false` otherwise."
        },
        {
          "approach": "for...in Loop Check",
          "code": "function isObjectEmptyLoop(obj) {\n  for (let key in obj) {\n    if (obj.hasOwnProperty(key)) {\n      return false; // Found own property, not empty\n    }\n  }\n  return true; // No own properties found, empty\n}",
          "explanation": "1. `for (let key in obj)`: Iterate through object properties.\n2. `obj.hasOwnProperty(key)`: Check if property is own property.\n3. If own property found, return `false` (not empty).\n4. If loop completes without finding own properties, return `true` (empty)."
        }
      ]
    },
    {
      "id": "pq33",
      "title": "Currying Function",
      "category": "JavaScript",
      "difficulty": "Medium",
      "description": "Implement a currying function in JavaScript. Currying transforms a function with multiple arguments into a sequence of functions, each taking a single argument.",
      "methodology": {
        "approach": "Closures and Recursion",
        "explanation": "Currying can be implemented using closures and recursion. The curried function will return another function if not all arguments are provided, and finally execute the original function when all arguments are collected.\n\n1. Create a function `curry(func)` that takes the function `func` to be curried as input.\n2. Store the arguments of the original function `func` in an array.\n3. Return a new function (the curried function).\n4. Inside the curried function:\n   - Collect the arguments passed to the curried function.\n   - Concatenate these arguments with the previously stored arguments.\n   - If the total number of collected arguments is less than the original function's arity (number of expected arguments), return a new curried function that closes over the current arguments.\n   - If the total number of arguments is equal to or greater than the original function's arity, call the original function `func` with all collected arguments and return the result.",
        "timeComplexity": "O(1) for each curried function call until the final call. The final function execution depends on the complexity of the original function.",
        "spaceComplexity": "O(A), where A is the arity of the original function, to store the arguments in the closure.",
        "javascriptSpecific": true
      },
      "examples": [
        {
          "input": "function add(a, b, c) { return a + b + c; }  curriedAdd = curry(add); curriedAdd(1)(2)(3)",
          "output": "6",
          "explanation": "The `add` function is curried, allowing it to be called in a sequence, taking one argument at a time."
        },
        {
          "input": "curriedAdd(1, 2)(3)",
          "output": "6",
          "explanation": "Curried function can also accept multiple arguments at once in intermediate calls."
        }
      ],
      "solutions": [
        {
          "approach": "Closures and Argument Accumulation",
          "code": "function curry(func) {\n  const arity = func.length;\n  return function curried(...args) {\n    if (args.length >= arity) {\n      return func.apply(this, args);\n    } else {\n      return function(...nextArgs) {\n        return curried.apply(this, args.concat(nextArgs));\n      };\n    }\n  };\n}",
          "explanation": "1. `curry(func)` function.\n2. `arity = func.length`: Get expected arguments count.\n3. Returns `curried` function.\n4. `curried(...args)`: collects arguments.\n5. `if (args.length >= arity)`: If enough arguments, call original `func` with `apply`.\n6. `else`: Not enough arguments, return another function.\n7. Inner function `(...nextArgs)`: collects next arguments.\n8. Recursive call: `curried.apply(this, args.concat(nextArgs))` to accumulate arguments."
        }
      ]
    },
    {
      "id": "pq34",
      "title": "Implement a Promise",
      "category": "JavaScript",
      "difficulty": "Hard",
      "description": "Implement a simplified version of JavaScript Promises, including `then`, `catch`, and `resolve`, `reject` static methods.",
      "methodology": {
        "approach": "State Management and Asynchronous Queues",
        "explanation": "Implementing Promises involves managing states (pending, fulfilled, rejected), and asynchronous execution of callbacks. We'll use a basic state machine and queues for callbacks.\n\n1. Create a `MyPromise` class.\n2. Constructor should take an `executor` function with `resolve` and `reject` parameters.\n3. Initialize promise state to 'pending', value to `undefined`, and rejection reason to `undefined`.\n4. Initialize callback queues for `then` (onFulfilled, onRejected) and `catch`.\n5. Implement `resolve(value)` method:\n   - Change state to 'fulfilled', set value.\n   - Execute all 'onFulfilled' callbacks in the queue with the value.\n6. Implement `reject(reason)` method:\n   - Change state to 'rejected', set rejection reason.\n   - Execute all 'onRejected' callbacks in the queue with the reason.\n7. Implement `then(onFulfilled, onRejected)` method:\n   - If promise is 'fulfilled', execute `onFulfilled` immediately (or enqueue if async).\n   - If promise is 'rejected', execute `onRejected` immediately (or enqueue if async).\n   - If promise is 'pending', enqueue `onFulfilled` and `onRejected` callbacks.\n   - Return a new `MyPromise` to support chaining.\n8. Implement `catch(onRejected)` as sugar for `then(null, onRejected)`.\n9. Implement static methods `MyPromise.resolve(value)` and `MyPromise.reject(reason)` for convenience.",
        "timeComplexity": "O(1) for `resolve`, `reject`, `then`, `catch` themselves. Callback execution time depends on the callbacks.",
        "spaceComplexity": "O(C), where C is the number of callbacks enqueued, mainly for storing callback queues.",
        "javascriptSpecific": true
      },
      "examples": [
        {
          "input": "new MyPromise((resolve, reject) => { setTimeout(() => resolve(1), 100); }).then(val => console.log(val));",
          "output": "Logs '1' to the console after 100ms.",
          "explanation": "A basic promise example that resolves after a timeout and executes the `then` callback."
        }
      ],
      "solutions": [
        {
          "approach": "State Machine and Callback Queues (Simplified)",
          "code": "// Simplified Promise Implementation (Illustrative)\nclass MyPromise {\n  constructor(executor) {\n    this.state = 'pending';\n    this.value = undefined;\n    this.reason = undefined;\n    this.onFulfilledCallbacks = [];\n    this.onRejectedCallbacks = [];\n\n    const resolve = (value) => {\n      if (this.state === 'pending') {\n        this.state = 'fulfilled';\n        this.value = value;\n        this.onFulfilledCallbacks.forEach(fn => fn(this.value));\n      }\n    };\n\n    const reject = (reason) => {\n      if (this.state === 'pending') {\n        this.state = 'rejected';\n        this.reason = reason;\n        this.onRejectedCallbacks.forEach(fn => fn(this.reason));\n      }\n    };\n\n    try {\n      executor(resolve, reject);\n    } catch (err) {\n      reject(err);\n    }\n  }\n\n  then(onFulfilled, onRejected) {\n    onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : value => value;\n    onRejected = typeof onRejected === 'function' ? onRejected : reason => { throw reason; };\n\n    return new MyPromise((resolve, reject) => {\n      if (this.state === 'fulfilled') {\n        setTimeout(() => {\n          try {\n            const result = onFulfilled(this.value);\n            resolve(result);\n          } catch (err) {\n            reject(err);\n          }\n        }, 0);\n      } else if (this.state === 'rejected') {\n        setTimeout(() => {\n          try {\n            const result = onRejected(this.reason);\n            resolve(result);\n          } catch (err) {\n            reject(err);\n          }\n        }, 0);\n      } else {\n        this.onFulfilledCallbacks.push(() => {\n          setTimeout(() => {\n            try {\n              const result = onFulfilled(this.value);\n              resolve(result);\n            } catch (err) {\n              reject(err);\n            }\n          }, 0);\n        });\n        this.onRejectedCallbacks.push(() => {\n          setTimeout(() => {\n            try {\n              const result = onRejected(this.reason);\n              resolve(result);\n            } catch (err) {\n              reject(err);\n            }\n          }, 0);\n        });\n      }\n    });\n  }\n\n  catch(onRejected) {\n    return this.then(null, onRejected);\n  }\n\n  static resolve(value) {\n    return new MyPromise(resolve => resolve(value));\n  }\n\n  static reject(reason) {\n    return new MyPromise((resolve, reject) => reject(reason));\n  }\n}\n",
          "explanation": "This is a simplified illustrative implementation. A full Promise polyfill would be significantly more complex to fully adhere to Promise A+ specification."
        }
      ]
    },
    {
      "id": "pq35",
      "title": "Compose Functions",
      "category": "JavaScript",
      "difficulty": "Medium",
      "description": "Write a function `compose` in JavaScript that performs right-to-left function composition. That is, it should return a function that is the composition of the given functions, where each function consumes the return value of the function that follows.",
      "methodology": {
        "approach": "Higher-Order Function and ReduceRight",
        "explanation": "Function composition can be implemented using higher-order functions. `compose` will take functions as arguments and return a new function that applies them from right to left.\n\n1. Create a function `compose(...funcs)` that takes a variable number of functions as arguments.\n2. Return a new function that will be the composed function.\n3. Inside the composed function, take an initial argument `x`.\n4. Use `funcs.reduceRight()` to apply the functions from right to left.\n5. The `reduceRight` callback will take two parameters: `accumulator` (the result from the previous function application) and `currentFunction` (the current function in the composition chain).\n6. In each step of `reduceRight`, apply `currentFunction` to the `accumulator` and return the result as the new accumulator.\n7. The initial value for `reduceRight` will be the initial argument `x` passed to the composed function.",
        "timeComplexity": "O(n), where n is the number of functions being composed. The composed function application time depends on the complexity of the composed functions.",
        "spaceComplexity": "O(1) - constant space for the `compose` function itself. Space complexity of the composed function depends on the composed functions.",
        "javascriptSpecific": true
      },
      "examples": [
        {
          "input": "const add1 = x => x + 1; const double = x => x * 2; const composedFn = compose(double, add1); composedFn(3)",
          "output": "8",
          "explanation": "The composed function `composedFn` should first apply `add1` to 3 (resulting in 4), and then apply `double` to the result (resulting in 8)."
        }
      ],
      "solutions": [
        {
          "approach": "ReduceRight for Right-to-Left Composition",
          "code": "function compose(...funcs) {\n  if (funcs.length === 0) {\n    return arg => arg; // Return identity function if no functions provided\n  }\n  return funcs.reduceRight((composed, func) => {\n    return (...args) => func(composed(...args));\n  });\n}",
          "explanation": "1. `compose(...funcs)` function takes functions to compose.\n2. Handle empty `funcs` array: return identity function.\n3. `funcs.reduceRight(...)`: reduce from right to left.\n4. `(composed, func) => ...`: `composed` is accumulated function, `func` is current function.\n5. `(...args) => func(composed(...args))`: return a new function that:\n   - Applies `composed` to `...args`.\n   - Passes result to `func`.\n   - Returns result of `func`."
        }
      ]
    },
    {
      "id": "pq36",
      "title": "Implement Object.keys",
      "category": "JavaScript",
      "difficulty": "Easy",
      "description": "Implement a polyfill for the `Object.keys` method in JavaScript. It should return an array of a given object's own enumerable property names, iterated in the same order as a normal loop.",
      "methodology": {
        "approach": "for...in Loop and hasOwnProperty",
        "explanation": "Implementing `Object.keys` requires iterating over an object's properties and filtering for own enumerable properties.\n\n1. Implement a function `objectKeysPolyfill(obj)` that takes an object `obj` as input.\n2. Initialize an empty array `keysArray` to store the keys.\n3. Iterate through the object's properties using a `for...in` loop.\n4. For each property, use `Object.prototype.hasOwnProperty.call(obj, key)` to check if the property is an own property of the object (not inherited).\n5. If it's an own property, push the property name (key) into `keysArray`.\n6. Return `keysArray`.",
        "timeComplexity": "O(n), where n is the number of own enumerable properties in the object, as we iterate through them once.",
        "spaceComplexity": "O(n) to store the `keysArray` which will contain up to n keys.",
        "javascriptSpecific": true
      },
      "examples": [
        {
          "input": "obj = { a: 1, b: 2, c: 3 }",
          "output": "['a', 'b', 'c']",
          "explanation": "`objectKeysPolyfill` should return an array of the object's own property names in the order they would be iterated."
        },
        {
          "input": "function Person() { this.name = 'John'; } Person.prototype.age = 30; const person = new Person(); objectKeysPolyfill(person)",
          "output": "['name']",
          "explanation": "Only own properties ('name') should be included, not inherited properties ('age')."
        }
      ],
      "solutions": [
        {
          "approach": "for...in Loop and hasOwnProperty",
          "code": "function objectKeysPolyfill(obj) {\n  if (typeof obj !== 'object' && typeof obj !== 'function' || obj === null) {\n    throw new TypeError('Object.keys called on non-object');\n  }\n\n  const keysArray = [];\n  for (let key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) { // Check for own property\n      keysArray.push(key);\n    }\n  }\n  return keysArray;\n}",
          "explanation": "1. `objectKeysPolyfill(obj)` function.\n2. Type check: `obj` must be object or function, not null.\n3. Initialize `keysArray`.\n4. `for (let key in obj)`: Iterate through object properties.\n5. `Object.prototype.hasOwnProperty.call(obj, key)`: check if `key` is own property of `obj`.\n6. If own property, `keysArray.push(key)`.\n7. Return `keysArray`."
        }
      ]
    },
    {
      "id": "pq37",
      "title": "Implement Promise.race",
      "category": "JavaScript",
      "difficulty": "Medium",
      "description": "Implement a polyfill for `Promise.race` in JavaScript. It should take an iterable of promises and return a promise that resolves or rejects as soon as one of the promises in the iterable resolves or rejects, with the value or reason from that promise.",
      "methodology": {
        "approach": "Promise Iteration and Early Resolution/Rejection",
        "explanation": "`Promise.race` resolves or rejects as soon as the first promise in the iterable settles. We need to iterate through the promises and attach resolution/rejection handlers that resolve/reject the main promise immediately upon settlement of any input promise.\n\n1. Create a function `promiseRacePolyfill(promises)` that takes an iterable of promises as input.\n2. Return a new `Promise`.\n3. In the promise executor, iterate through the `promises` iterable.\n4. For each promise, use `.then()` to handle resolution and `.catch()` to handle rejection.\n5. In both `.then()` and `.catch()` handlers, immediately resolve or reject the main promise with the value or reason from the settled promise.\n6. The first promise to settle will determine the outcome of the main promise.",
        "timeComplexity": "O(n), where n is the number of promises in the iterable. We iterate through each promise once to attach handlers.",
        "spaceComplexity": "O(1) - constant space for the main promise and handlers.",
        "javascriptSpecific": true
      },
      "examples": [
        {
          "input": "[promise1, promise2, promise3] where promise2 resolves fastest.",
          "output": "A promise that resolves with the value of promise2 as soon as promise2 resolves.",
          "explanation": "`promiseRacePolyfill` should resolve or reject as soon as the *first* promise in the input array settles, mimicking `Promise.race`."
        }
      ],
      "solutions": [
        {
          "approach": "Iteration and Early Settlement",
          "code": "function promiseRacePolyfill(promises) {\n  return new Promise((resolve, reject) => {\n    if (!promises || promises.length === 0) {\n      return; // Promise never resolves or rejects if input is empty\n    }\n\n    for (const promise of promises) {\n      Promise.resolve(promise) // Ensure it's a promise\n        .then(resolve)\n        .catch(reject);\n    }\n  });\n}",
          "explanation": "1. `promiseRacePolyfill(promises)` function.\n2. Returns a new `Promise`.\n3. Handle empty `promises` input (no action, promise stays pending - native behavior is more complex but this is simplified).\n4. `for (const promise of promises)`: Iterate through promises.\n5. `Promise.resolve(promise)`: ensure each element is a promise.\n6. `.then(resolve)`: if promise resolves, immediately resolve the main promise.\n7. `.catch(reject)`: if promise rejects, immediately reject the main promise.\n8. First to settle wins the race."
        }
      ]
    },
    {
      "id": "pq38",
      "title": "Implement Array.prototype.find",
      "category": "JavaScript",
      "difficulty": "Easy",
      "description": "Implement a polyfill for the `Array.prototype.find` method in JavaScript. It should return the first element in the provided array that satisfies the provided testing function. If no elements satisfy the testing function, undefined is returned.",
      "methodology": {
        "approach": "Iteration and Predicate Callback",
        "explanation": "Implementing `find` requires iterating through an array and using a callback function as a predicate to test each element. It should return the first element that satisfies the predicate.\n\n1. Extend `Array.prototype` with a new method `customFind`.\n2. Inside `customFind`, take a `callback` function (predicate) as an argument.\n3. Iterate through the original array using a `for` loop.\n4. For each element, call the `callback` function with the element, index, and the original array.\n5. If the `callback` function returns a truthy value, return the current element immediately (first match found).\n6. If the loop completes without finding any element that satisfies the predicate, return `undefined`.",
        "timeComplexity": "O(n) in the worst case, where n is the length of the array, as we might need to check all elements. In the best case (first element matches), it's O(1).",
        "spaceComplexity": "O(1) - constant space, as we only use a few variables for iteration.",
        "javascriptSpecific": true
      },
      "examples": [
        {
          "input": "array = [10, 20, 30, 40].customFind(x => x > 25)",
          "output": "30",
          "explanation": "30 is the first element in the array that is greater than 25."
        },
        {
          "input": "array = [10, 20, 30, 40].customFind(x => x > 50)",
          "output": "undefined",
          "explanation": "No element in the array is greater than 50, so undefined is returned."
        }
      ],
      "solutions": [
        {
          "approach": "Iteration and Predicate Callback",
          "code": "if (!Array.prototype.customFind) {\n  Array.prototype.customFind = function(callback) {\n    if (typeof callback !== 'function') {\n      throw new TypeError('Callback is not a function');\n    }\n    if (this === null || this === undefined) {\n      throw new TypeError('Cannot read property 'find' of null or undefined');\n    }\n\n    for (let i = 0; i < this.length; i++) {\n      if (i in this) { // Handle sparse arrays\n        if (callback(this[i], i, this)) { // Predicate check\n          return this[i]; // Return element if predicate is true\n        }\n      }\n    }\n    return undefined; // Return undefined if no match found\n  };\n}",
          "explanation": "1. Check if `Array.prototype.customFind` exists.\n2. Define `customFind` on `Array.prototype`, taking `callback`.\n3. Type check: `callback` must be a function. Handle null/undefined `this`.\n4. Iterate through the array using a `for` loop.\n5. `if (i in this)`: handle sparse arrays.\n6. `if (callback(this[i], i, this))`: call predicate and check if truthy.\n7. If predicate is true, return `this[i]` (element found).\n8. If loop completes without match, return `undefined`."
        }
      ]
    },
    {
      "id": "pq39",
      "title": "Implement Promise.allSettled",
      "category": "JavaScript",
      "difficulty": "Medium",
      "description": "Implement a polyfill for `Promise.allSettled` in JavaScript. It should take an iterable of promises and return a promise that resolves after all of the given promises have either fulfilled or rejected, with an array of objects that each describe the outcome of each promise.",
      "methodology": {
        "approach": "Promise Mapping and Aggregation",
        "explanation": "`Promise.allSettled` waits for all promises to settle (resolve or reject) and returns an array of settlement descriptors. We need to map each promise to a descriptor promise and then use `Promise.all` to wait for all descriptors to be ready.\n\n1. Create a function `promiseAllSettledPolyfill(promises)` that takes an iterable of promises as input.\n2. Map each promise in the `promises` iterable to a new promise that always resolves.\n3. For each promise in the input iterable:\n   - Create a new promise that wraps the original promise.\n   - In the `.then()` handler of the wrapper promise, transform the resolved value into a settlement descriptor object `{ status: 'fulfilled', value: originalValue }`.\n   - In the `.catch()` handler of the wrapper promise, transform the rejection reason into a settlement descriptor object `{ status: 'rejected', reason: originalReason }`.\n4. Use `Promise.all` on the array of descriptor promises to wait for all of them to settle.\n5. Return the promise returned by `Promise.all`.",
        "timeComplexity": "O(n), where n is the number of promises in the iterable. We process each promise once to create a descriptor promise.",
        "spaceComplexity": "O(n) to store the array of descriptor promises and the final result array.",
        "javascriptSpecific": true
      },
      "examples": [
        {
          "input": "[promise1, promise2, promise3] where some resolve and some reject.",
          "output": "A promise that resolves with an array of settlement descriptors, one for each input promise, indicating status ('fulfilled' or 'rejected') and value or reason.",
          "explanation": "`promiseAllSettledPolyfill` should wait for all promises to settle and return detailed outcomes for each."
        }
      ],
      "solutions": [
        {
          "approach": "Promise Mapping to Descriptors and Promise.all",
          "code": "function promiseAllSettledPolyfill(promises) {\n  const descriptorPromises = Array.from(promises).map(promise => {\n    return Promise.resolve(promise)\n      .then(value => ({ status: 'fulfilled', value }))\n      .catch(reason => ({ status: 'rejected', reason }));\n  });\n  return Promise.all(descriptorPromises);\n}",
          "explanation": "1. `promiseAllSettledPolyfill(promises)` function.\n2. `descriptorPromises = Array.from(promises).map(...)`: map input promises to descriptor promises.\n3. `Promise.resolve(promise).then(...).catch(...)`: for each input promise:\n   - `.then(...)`: if resolved, create descriptor `{ status: 'fulfilled', value }`.\n   - `.catch(...)`: if rejected, create descriptor `{ status: 'rejected', reason }`.\n4. `Promise.all(descriptorPromises)`: wait for all descriptor promises to settle.\n5. Return the promise from `Promise.all` (resolving with array of descriptors)."
        }
      ]
    },
    {
      "id": "pq40",
      "title": "Implement Array.prototype.findIndex",
      "category": "JavaScript",
      "difficulty": "Easy",
      "description": "Implement a polyfill for the `Array.prototype.findIndex` method in JavaScript. It should return the index of the first element in the array that satisfies the provided testing function. Otherwise, it should return -1.",
      "methodology": {
        "approach": "Iteration and Predicate Callback",
        "explanation": "Implementing `findIndex` is similar to `find`, but instead of returning the element, it returns the index of the first element that satisfies the predicate. If no element satisfies the predicate, it returns -1.\n\n1. Extend `Array.prototype` with a new method `customFindIndex`.\n2. Inside `customFindIndex`, take a `callback` function (predicate) as an argument.\n3. Iterate through the original array using a `for` loop with index.\n4. For each element and index, call the `callback` function with the element, index, and the original array.\n5. If the `callback` function returns a truthy value, return the current index immediately (index of the first match).\n6. If the loop completes without finding any element that satisfies the predicate, return -1.",
        "timeComplexity": "O(n) in the worst case, where n is the length of the array. Best case O(1).",
        "spaceComplexity": "O(1) - constant space.",
        "javascriptSpecific": true
      },
      "examples": [
        {
          "input": "array = [10, 20, 30, 40].customFindIndex(x => x > 25)",
          "output": "2",
          "explanation": "The element 30 at index 2 is the first element greater than 25."
        },
        {
          "input": "array = [10, 20, 30, 40].customFindIndex(x => x > 50)",
          "output": "-1",
          "explanation": "No element is greater than 50, so -1 is returned."
        }
      ],
      "solutions": [
        {
          "approach": "Iteration and Predicate Callback",
          "code": "if (!Array.prototype.customFindIndex) {\n  Array.prototype.customFindIndex = function(callback) {\n    if (typeof callback !== 'function') {\n      throw new TypeError('Callback is not a function');\n    }\n    if (this === null || this === undefined) {\n      throw new TypeError('Cannot read property 'findIndex' of null or undefined');\n    }\n\n    for (let i = 0; i < this.length; i++) {\n      if (i in this) { // Handle sparse arrays\n        if (callback(this[i], i, this)) { // Predicate check\n          return i; // Return index if predicate is true\n        }\n      }\n    }\n    return -1; // Return -1 if no match found\n  };\n}",
          "explanation": "1. Check if `Array.prototype.customFindIndex` exists.\n2. Define `customFindIndex` on `Array.prototype`, taking `callback`.\n3. Type check: `callback` is function, handle null/undefined `this`.\n4. Iterate using `for` loop with index `i`.\n5. `if (i in this)`: handle sparse arrays.\n6. `if (callback(this[i], i, this))`: check predicate.\n7. If predicate is true, return index `i`.\n8. If loop finishes, return -1."
        }
      ]
    },
     {
      "id": "pq41",
      "title": "Implement LRU Cache",
      "category": "Design",
      "difficulty": "Medium",
      "description": "Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: `get(key)` - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1. `put(key, value)` - Set or insert the value if the key is not already present. When the cache reaches its capacity, it should invalidate the least recently used item before inserting a new item.",
      "methodology": {
        "approach": "Hash Map and Doubly Linked List",
        "explanation": "An LRU cache can be efficiently implemented using a combination of a hash map and a doubly linked list.\n\n1. **Hash Map:** Use a hash map to store key-value pairs for O(1) average time complexity for `get` and `put` operations. The keys of the hash map will be the cache keys, and the values will be pointers to nodes in the doubly linked list.\n2. **Doubly Linked List:** Use a doubly linked list to maintain the order of items based on their usage. The most recently used item will be at the head of the list, and the least recently used item will be at the tail.\n3. **Cache Node:** Each node in the doubly linked list will store the key, value, and pointers to the previous and next nodes.\n4. **get(key) operation:**\n   - Check if the key exists in the hash map. If not, return -1.\n   - If it exists, retrieve the corresponding node from the hash map.\n   - Move the retrieved node to the head of the doubly linked list (as it's now the most recently used).\n   - Return the value from the node.\n5. **put(key, value) operation:**\n   - Check if the key already exists in the hash map.\n   - If it exists, update the value in the node, and move the node to the head of the doubly linked list.\n   - If it does not exist:\n     - Create a new node with the key and value.\n     - Add the new node to the head of the doubly linked list.\n     - Add an entry to the hash map mapping the key to the new node.\n     - If the cache capacity is exceeded, remove the tail node from the doubly linked list (least recently used item) and remove its entry from the hash map.\n\nTime Complexity: O(1) for both `get` and `put` operations on average, due to hash map lookups and linked list operations.\nSpace Complexity: O(capacity), where capacity is the maximum number of items the cache can hold, for storing the hash map and doubly linked list.",
        "timeComplexity": "O(1)",
        "spaceComplexity": "O(capacity)"
      },
      "examples": [
        {
          "input": "LRUCache cache = new LRUCache(2); cache.put(1, 1); cache.put(2, 2); cache.get(1);       // returns 1 cache.put(3, 3);    // evicts key 2 cache.get(2);       // returns -1 (not found) cache.put(4, 4);    // evicts key 1 cache.get(1);       // returns -1 (not found) cache.get(3);       // returns 3 cache.get(4);       // returns 4",
          "output": "Operations as described in the input example, demonstrating LRU eviction policy.",
          "explanation": "The example shows how the LRU cache evicts the least recently used items when the capacity is reached, maintaining fast get and put operations."
        }
      ],
      "solutions": [
        {
          "approach": "Hash Map and Doubly Linked List",
          "code": "class LRUCache {\n    constructor(capacity) {\n        this.capacity = capacity;\n        this.cache = new Map(); // Hash map for O(1) access\n        this.head = null;      // Head of doubly linked list (most recent)\n        this.tail = null;      // Tail of doubly linked list (least recent)\n        this.size = 0;\n    }\n\n    get(key) {\n        if (!this.cache.has(key)) return -1;\n        const node = this.cache.get(key);\n        this.moveToHead(node); // Move to front as recently used\n        return node.value;\n    }\n\n    put(key, value) {\n        if (this.cache.has(key)) { // Key exists, update value and move to head\n            const node = this.cache.get(key);\n            node.value = value;\n            this.moveToHead(node);\n        } else { // Key doesn't exist, create new node\n            const newNode = { key, value, prev: null, next: null };\n            this.cache.set(key, newNode);\n            this.addToHead(newNode); // Add to head\n            this.size++;\n            if (this.size > this.capacity) { // Capacity exceeded, evict LRU (tail)\n                this.evictTail();\n            }\n        }\n    }\n\n    moveToHead(node) { // Move node to the head of DLL\n        if (node === this.head) return; // Already head\n        if (node === this.tail) { // If tail, update tail\n            this.tail = this.tail.prev;\n            this.tail.next = null;\n        } else { // Node in middle, re-link\n            node.prev.next = node.next;\n            node.next.prev = node.prev;\n        }\n        node.next = this.head; // Move to head\n        node.prev = null;\n        if (this.head) this.head.prev = node;\n        this.head = node;\n        if (!this.tail) this.tail = this.head; // If list was empty, tail becomes head\n    }\n\n    addToHead(node) { // Add node to head of DLL\n        node.next = this.head;\n        node.prev = null;\n        if (this.head) this.head.prev = node;\n        this.head = node;\n        if (!this.tail) this.tail = this.head; // If list was empty, tail becomes head\n    }\n\n    evictTail() { // Remove tail (LRU) node\n        const tailKey = this.tail.key;\n        this.cache.delete(tailKey); // Remove from hash map\n        this.tail = this.tail.prev; // Update tail\n        if (this.tail) this.tail.next = null; // Update new tail's next\n        this.size--;\n        if (this.size === 0) {\n            this.head = null;\n            this.tail = null;\n        }\n    }\n}",
          "explanation": "This code provides a basic implementation of LRUCache using Map and manual doubly linked list management within JavaScript.  For production, consider using more optimized or built-in data structures if available and performance is critical."
        }
      ]
    },
      {
      "id": "pq42",
      "title": "Implement a Rate Limiter",
      "category": "Design",
      "difficulty": "Medium",
      "description": "Design and implement a rate limiter that controls the rate at which clients can make requests to a server. Implement a `shouldAllow(clientId)` function that returns `true` if the request from `clientId` should be allowed, and `false` otherwise. Assume a fixed window rate limiting strategy where each client is allowed a maximum number of requests within a time window (e.g., 10 requests per minute per client).",
      "methodology": {
        "approach": "Fixed Window Counter",
        "explanation": "A fixed window counter rate limiter tracks the number of requests within fixed time intervals (windows). Each client has a counter that resets at the beginning of each window.\n\n1. Create a `RateLimiter` class with a constructor that takes `maxRequestsPerWindow` and `windowDurationInMinutes` as parameters.\n2. Inside the constructor, initialize a `requestCounts` Map to store request counts per client, and `windowStartTime` to track the start of the current window.\n3. Implement the `shouldAllow(clientId)` function:\n   - Get the current timestamp.\n   - Check if the current request timestamp is outside the current window (older than `windowStartTime + windowDuration`). If so, reset the `requestCounts` map and update `windowStartTime` to the start of the new window.\n   - Get the current request count for the `clientId` from `requestCounts`. If the client is new, initialize the count to 0.\n   - If the current request count is less than `maxRequestsPerWindow`, increment the count in `requestCounts` and return `true` (allow request).\n   - Otherwise, return `false` (rate limit exceeded, reject request).\n\nTime Complexity: O(1) for `shouldAllow` operation on average, as Map operations (get, set, has) are typically O(1) on average.\nSpace Complexity: O(C), where C is the number of active clients being tracked, for storing request counts in the `requestCounts` Map.",
        "timeComplexity": "O(1)",
        "spaceComplexity": "O(C)"
      },
      "examples": [
        {
          "input": "RateLimiter limiter = new RateLimiter(2, 1); // 2 requests per minute per client limiter.shouldAllow('client1'); // true limiter.shouldAllow('client1'); // true limiter.shouldAllow('client1'); // false (rate limited) Wait for > 1 minute. limiter.shouldAllow('client1'); // true (window reset)",
          "output": "Behavior as described, demonstrating rate limiting and window reset.",
          "explanation": "The example shows how the rate limiter allows requests within the limit and rejects requests exceeding the limit within a fixed time window, resetting the count after the window expires."
        }
      ],
      "solutions": [
        {
          "approach": "Fixed Window Counter",
          "code": "class RateLimiter {\n  constructor(maxRequestsPerWindow, windowDurationInMinutes) {\n    this.maxRequestsPerWindow = maxRequestsPerWindow;\n    this.windowDurationMs = windowDurationInMinutes * 60 * 1000; // Convert minutes to milliseconds\n    this.requestCounts = new Map(); // clientId -> requestCount\n    this.windowStartTime = Date.now(); // Start time of current window\n  }\n\n  shouldAllow(clientId) {\n    const currentTime = Date.now();\n    // Check if window expired, reset if needed\n    if (currentTime > this.windowStartTime + this.windowDurationMs) {\n      this.requestCounts.clear(); // Reset counts for new window\n      this.windowStartTime = currentTime; // Update window start time\n    }\n\n    const currentRequestCount = this.requestCounts.get(clientId) || 0;\n\n    if (currentRequestCount < this.maxRequestsPerWindow) {\n      this.requestCounts.set(clientId, currentRequestCount + 1);\n      return true; // Allow request\n    } else {\n      return false; // Rate limit exceeded, reject request\n    }\n  }\n}",
          "explanation": "This code implements a basic fixed window rate limiter. For production systems, consider more robust and distributed rate limiting strategies, especially in microservices architectures."
        }
      ]
    },
     {
      "id": "pq43",
      "title": "Implement Binary Search Tree (BST)",
      "category": "Trees",
      "difficulty": "Medium",
      "description": "Implement a Binary Search Tree (BST) data structure in JavaScript. It should support `insert(value)`, `search(value)`, `delete(value)`, `min()`, `max()`, and `inorderTraversal()` operations.",
      "methodology": {
        "approach": "Recursive Tree Structure",
        "explanation": "A Binary Search Tree (BST) is a tree-based data structure where each node has at most two children (left and right), and nodes are ordered in a way that for each node, all nodes in its left subtree have values less than the node's value, and all nodes in its right subtree have values greater than the node's value. We will implement BST operations recursively.\n\n1. Define a `Node` class or object to represent each node in the BST. Each node will have `value`, `left` child, and `right` child properties.\n2. Define a `BinarySearchTree` class.\n3. `insert(value)`: \n   - If the tree is empty, create a new root node with the value.\n   - Otherwise, recursively traverse the tree:\n     - If `value` is less than the current node's value, go to the left subtree.\n     - If `value` is greater than the current node's value, go to the right subtree.\n     - If you reach a null child pointer, insert a new node with the value at that position.\n4. `search(value)`: \n   - Start from the root.\n   - Recursively traverse:\n     - If `value` is equal to the current node's value, return `true` (found).\n     - If `value` is less than the current node's value, search in the left subtree.\n     - If `value` is greater than the current node's value, search in the right subtree.\n     - If you reach a null node, return `false` (not found).\n5. `min()`: \n   - Start from the root.\n   - Traverse all the way to the leftmost node (following left child pointers) to find the minimum value.\n6. `max()`: \n   - Start from the root.\n   - Traverse all the way to the rightmost node (following right child pointers) to find the maximum value.\n7. `inorderTraversal()`: \n   - Perform inorder traversal (Left, Root, Right) recursively. Collect the values in an array and return it. This will return sorted values if BST property is maintained.\n8. `delete(value)`: (More complex, involves handling different cases for node deletion - node with no children, one child, or two children.)\n    - Search for the node to delete.\n    - Cases:\n        - Node is leaf: Simply remove it by updating parent's pointer to null.\n        - Node has one child: Replace node with its child in the parent link.\n        - Node has two children: Find inorder successor (minimum in right subtree), replace node's value with successor value, and then delete the successor node (which will be in one of the simpler cases - leaf or one child).",
        "timeComplexity": "O(h) in average and best case for `insert`, `search`, `delete`, `min`, `max`, where h is the height of the tree. In the worst case (skewed tree), h can be O(n), making operations O(n). For a balanced BST, h is O(log n), so operations are O(log n).\nSpace Complexity: O(h) for recursive calls stack in `insert`, `search`, `delete`, `inorderTraversal`. In worst case O(n), average/best case O(log n).",
        "spaceComplexity": "O(h)"
      },
      "examples": [
        {
          "input": "BST operations: insert, search, delete, min, max, inorderTraversal.",
          "output": "BST should function correctly, maintaining BST properties and supporting all operations.",
          "explanation": "The example demonstrates the required functionalities of a Binary Search Tree, including insertion, search, deletion, and traversal, while keeping the tree ordered for efficient operations."
        }
      ],
      "solutions": [
        {
          "approach": "Recursive BST Implementation",
          "code": "class Node {\n    constructor(value) {\n        this.value = value;\n        this.left = null;\n        this.right = null;\n    }\n}\n\nclass BinarySearchTree {\n    constructor() {\n        this.root = null;\n    }\n\n    insert(value) {\n        const newNode = new Node(value);\n        if (!this.root) {\n            this.root = newNode;\n            return;\n        }\n        this.insertNode(this.root, newNode);\n    }\n\n    insertNode(node, newNode) {\n        if (newNode.value < node.value) {\n            if (!node.left) node.left = newNode;\n            else this.insertNode(node.left, newNode);\n        } else {\n            if (!node.right) node.right = newNode;\n            else this.insertNode(node.right, newNode);\n        }\n    }\n\n    search(value) {\n        return this.searchNode(this.root, value);\n    }\n\n    searchNode(node, value) {\n        if (!node) return false;\n        if (value === node.value) return true;\n        if (value < node.value) return this.searchNode(node.left, value);\n        return this.searchNode(node.right, value);\n    }\n\n    min() {\n        let current = this.root;\n        while (current && current.left) current = current.left;\n        return current ? current.value : null;\n    }\n\n    max() {\n        let current = this.root;\n        while (current && current.right) current = current.right;\n        return current ? current.value : null;\n    }\n\n    inorderTraversal() {\n        const result = [];\n        this.inorderNode(this.root, result);\n        return result;\n    }\n\n    inorderNode(node, result) {\n        if (node) {\n            this.inorderNode(node.left, result);\n            result.push(node.value);\n            this.inorderNode(node.right, result);\n        }\n    }\n\n    delete(value) {\n        this.root = this.deleteNode(this.root, value);\n    }\n\n    deleteNode(node, value) {\n        if (!node) return null; // Value not found\n        if (value < node.value) node.left = this.deleteNode(node.left, value); // Go left\n        else if (value > node.value) node.right = this.deleteNode(node.right, value); // Go right\n        else { // Node to delete found\n            if (!node.left && !node.right) return null; // Leaf node\n            if (!node.left) return node.right; // One child (right)\n            if (!node.right) return node.left;  // One child (left)\n\n            // Node with two children: find inorder successor (min in right subtree)\n            let successor = this.findMinNode(node.right);\n            node.value = successor.value; // Replace value\n            node.right = this.deleteNode(node.right, successor.value); // Delete successor\n        }\n        return node;\n    }\n\n    findMinNode(node) {\n        while (node && node.left) node = node.left;\n        return node;\n    }\n}\n",
          "explanation": "This code provides a basic recursive implementation of a Binary Search Tree with insert, search, delete, min, max, and inorder traversal operations. For real-world scenarios, consider balancing BSTs (like AVL or Red-Black trees) for better performance guarantees, especially for deletion and insertion in skewed cases."
        }
      ]
    },
    {
      "id": "pq44",
      "title": "Implement a Promise Queue",
      "category": "JavaScript, Asynchronous",
      "difficulty": "Hard",
      "description": "Implement a `PromiseQueue` class in JavaScript that allows you to add promises to a queue and execute them sequentially, one after another. The queue should ensure that the next promise in the queue only starts executing after the previous one has resolved.",
      "methodology": {
        "approach": "Promise Chaining and Queue",
        "explanation": "We can use a queue to store promises and chain them together to ensure sequential execution. When a promise in the queue resolves, it triggers the execution of the next promise in the queue.\n\n1. Create a `PromiseQueue` class.\n2. In the constructor, initialize a queue array to store promises and a `isRunning` flag to prevent concurrent execution.\n3. Implement an `enqueue(promiseFn)` method:\n   - This method should take a function `promiseFn` that returns a promise.\n   - Add `promiseFn` to the queue.\n   - Call a `dequeue` method to start processing the queue if it's not already running.\n4. Implement a `dequeue()` method:\n   - Check if the queue is empty or if a promise is already running (`isRunning` flag). If so, return.\n   - Set `isRunning` to `true`.\n   - Get the first `promiseFn` from the queue.\n   - Execute `promiseFn()` to get a promise.\n   - Use `.then()` to handle promise resolution:\n     - After resolution, set `isRunning` to `false`.\n     - Recursively call `dequeue()` to process the next promise in the queue.\n   - Use `.catch()` to handle promise rejection (and potentially continue queue processing or handle errors as needed).\n\nThis approach chains promises using `.then()` to ensure that the next promise only starts after the previous one is settled.",
        "timeComplexity": "O(N), where N is the total number of promises enqueued. Each promise in the queue is executed sequentially.",
        "spaceComplexity": "O(Q), where Q is the maximum size of the promise queue if promises are enqueued faster than they can be processed.",
        "javascriptSpecific": true
      },
      "examples": [
        {
          "input": "const queue = new PromiseQueue(); queue.enqueue(() => delayPromise(1000, 'Task 1')); queue.enqueue(() => delayPromise(500, 'Task 2'));",
          "output": "Tasks 'Task 1' and 'Task 2' are executed sequentially, with 'Task 2' starting only after 'Task 1' resolves.",
          "explanation": "The PromiseQueue ensures that promises are executed in the order they are enqueued and one at a time, waiting for each to resolve before starting the next."
        }
      ],
      "solutions": [
        {
          "approach": "Promise Chaining and Queue",
          "code": "class PromiseQueue {\n  constructor() {\n    this.queue = [];\n    this.isRunning = false;\n  }\n\n  enqueue(promiseFn) {\n    this.queue.push(promiseFn);\n    if (!this.isRunning) {\n      this.dequeue();\n    }\n  }\n\n  dequeue() {\n    if (this.queue.length === 0 || this.isRunning) {\n      return;\n    }\n\n    this.isRunning = true;\n    const promiseFn = this.queue.shift();\n\n    promiseFn()\n      .then(() => {\n        this.isRunning = false;\n        this.dequeue(); // Process next in queue\n      })\n      .catch(err => {\n        console.error('Promise in queue rejected:', err);\n        this.isRunning = false;\n        this.dequeue(); // Consider error handling strategy here\n      });\n  }\n}",
          "explanation": "This implementation uses a simple array as a queue and a boolean flag to control execution flow, ensuring sequential processing of promises."
        }
      ]
    },
    {
      "id": "pq45",
      "title": "Implement a Simple Pub/Sub (Publish-Subscribe) System",
      "category": "Design Patterns, JavaScript",
      "difficulty": "Medium",
      "description": "Design and implement a basic Publish-Subscribe (Pub/Sub) system in JavaScript. It should allow publishers to broadcast messages to topics, and subscribers to register to receive messages for specific topics.",
      "methodology": {
        "approach": "Event Emitter Pattern",
        "explanation": "A Pub/Sub system can be implemented using an Event Emitter pattern. We'll use an object to store topics and their subscribers (listeners).\n\n1. Create a `PubSub` class.\n2. In the constructor, initialize a `topics` object to store topics as keys and arrays of subscriber functions as values.\n3. Implement a `subscribe(topic, subscriber)` method:\n   - If the `topic` does not exist in `topics`, create a new empty array for it.\n   - Add the `subscriber` function to the array of subscribers for the given `topic`.\n4. Implement a `publish(topic, message)` method:\n   - If the `topic` exists in `topics`:\n     - Iterate through the array of subscribers for that `topic`.\n     - For each subscriber, call the subscriber function with the `message`.\n5. (Optional) Implement an `unsubscribe(topic, subscriber)` method to remove a specific subscriber from a topic.",
        "timeComplexity": "O(S) for `publish`, where S is the number of subscribers to a topic. O(1) for `subscribe` and `unsubscribe` on average.",
        "spaceComplexity": "O(L), where L is the total number of listeners (subscribers) across all topics.",
        "javascriptSpecific": true
      },
      "examples": [
        {
          "input": "const pubsub = new PubSub(); const sub1 = (msg) => console.log('Subscriber 1 received:', msg); pubsub.subscribe('news', sub1); pubsub.publish('news', 'Breaking news!');",
          "output": "Subscriber 1 receives 'Breaking news!' when it's published to the 'news' topic.",
          "explanation": "The Pub/Sub system allows subscribers to receive messages published to topics they have subscribed to."
        }
      ],
      "solutions": [
        {
          "approach": "Object-Based Topic and Subscriber Management",
          "code": "class PubSub {\n  constructor() {\n    this.topics = {}; // Topics and their subscribers\n  }\n\n  subscribe(topic, subscriber) {\n    if (!this.topics[topic]) {\n      this.topics[topic] = [];\n    }\n    this.topics[topic].push(subscriber);\n  }\n\n  publish(topic, message) {\n    if (this.topics[topic]) {\n      this.topics[topic].forEach(subscriber => {\n        subscriber(message);\n      });\n    }\n  }\n\n  unsubscribe(topic, subscriberToRemove) {\n    if (this.topics[topic]) {\n      this.topics[topic] = this.topics[topic].filter(subscriber => subscriber !== subscriberToRemove);\n      if (this.topics[topic].length === 0) {\n        delete this.topics[topic]; // Clean up if no subscribers left\n      }\n    }\n  }\n}",
          "explanation": "This code implements a basic Pub/Sub system using a JavaScript object to manage topics and subscriber lists. It allows for subscribing, publishing, and unsubscribing to topics."
        }
      ]
    },
    {
      "id": "pq46",
      "title": "Implement a Basic Promise Debounce",
      "category": "JavaScript, Asynchronous",
      "difficulty": "Medium",
      "description": "Implement a debounce function that works with Promises. It should delay the execution of a promise-returning function until after a certain period of inactivity. If the function is called again before the delay period ends, the previous pending promise should be cancelled or ignored, and a new delay timer should start.",
      "methodology": {
        "approach": "Promise Cancellation and Timers",
        "explanation": "Debouncing promises requires managing timers and potentially cancelling or ignoring pending promises when a new call is made within the delay period.\n\n1. Create a function `debouncePromise(func, delay)` that takes a promise-returning function `func` and a delay `delay` as arguments.\n2. Inside `debouncePromise`, use a closure to maintain a `timeoutId` and a `pendingPromise` variable.\n3. Return a new function (the debounced function).\n4. Inside the debounced function:\n   - Clear any existing `timeoutId` using `clearTimeout` to cancel any pending timeout.\n   - If there's a `pendingPromise`, potentially implement logic to cancel or ignore it (depending on requirements, for simplicity, we might just let it resolve/reject but ignore its result).\n   - Create a new promise that uses `setTimeout` to resolve after `delay` milliseconds.\n   - Store the new timeout ID in `timeoutId` and the new promise in `pendingPromise`.\n   - Return the new promise. When this promise resolves, it should actually call the original `func` and resolve with its result.",
        "timeComplexity": "O(1) for each debounced call (excluding the execution of `func`).",
        "spaceComplexity": "O(1) - constant space for closure variables (timeoutId, pendingPromise).",
        "javascriptSpecific": true
      },
      "examples": [
        {
          "input": "const debouncedFetch = debouncePromise(() => fetch('api-endpoint'), 500); debouncedFetch(); debouncedFetch(); setTimeout(debouncedFetch, 600);",
          "output": "The fetch call to 'api-endpoint' is made only once, approximately 600ms after the last call to `debouncedFetch`.",
          "explanation": "The debounced promise function ensures that the underlying promise-returning function (fetch in this example) is called only after a period of inactivity, even if `debouncedFetch` is called multiple times in quick succession."
        }
      ],
      "solutions": [
        {
          "approach": "Closures, Timers, and Promise Management",
          "code": "function debouncePromise(func, delay) {\n  let timeoutId;\n  let pendingPromise;\n\n  return function debouncedFunction(...args) {\n    clearTimeout(timeoutId);\n\n    return new Promise((resolve, reject) => {\n      timeoutId = setTimeout(() => {\n        pendingPromise = func.apply(this, args);\n        pendingPromise\n          .then(resolve)\n          .catch(reject);\n      }, delay);\n    });\n  };\n}",
          "explanation": "This implementation uses closures to manage `timeoutId` and `pendingPromise`. Each call clears the previous timeout and sets a new one, effectively debouncing the promise-returning function."
        }
      ]
    },
    {
      "id": "pq47",
      "title": "Implement a Simple Retry Mechanism with Delay",
      "category": "JavaScript, Asynchronous",
      "difficulty": "Medium",
      "description": "Write a function `retryWithDelay(fn, retries, delay)` in JavaScript that takes a function `fn` (returning a Promise), a number of `retries`, and a `delay` in milliseconds. The function should execute `fn`. If it rejects, it should wait for `delay` milliseconds and then retry executing `fn`, up to `retries` times. If all retries fail, the promise should finally reject with the last error.",
      "methodology": {
        "approach": "Recursion, Promises, and setTimeout",
        "explanation": "Implementing retry with delay involves recursion and `setTimeout` to introduce pauses between retries. We'll use a recursive function to manage retries.\n\n1. Create a function `retryWithDelay(fn, retries, delay)` that takes the promise-returning function `fn`, number of `retries`, and `delay` as arguments.\n2. Implement a recursive helper function `attempt(retriesRemaining)` inside `retryWithDelay`.\n3. Inside `attempt(retriesRemaining)`:\n   - Call `fn()`.\n   - Use `.then()` to handle successful resolution and resolve the main promise with the result.\n   - Use `.catch()` to handle rejection:\n     - If `retriesRemaining` is greater than 0:\n       - Use `setTimeout` to wait for `delay` milliseconds.\n       - After delay, recursively call `attempt(retriesRemaining - 1)` to retry.\n     - If `retriesRemaining` is 0 (no more retries), reject the main promise with the error.\n4. Start the retry process by calling `attempt(retries)` initially.",
        "timeComplexity": "O(R * (T + D)), where R is the number of retries, T is the time complexity of `fn`, and D is the delay time. In the worst case, `fn` is called R+1 times, with delay D between retries.",
        "spaceComplexity": "O(R) due to recursive call stack depth being proportional to the number of retries.",
        "javascriptSpecific": true
      },
      "examples": [
        {
          "input": "retryWithDelay(() => fetch('api-endpoint'), 3, 1000)",
          "output": "A promise that resolves if fetch succeeds within 3 retries (with 1-second delay between retries), or rejects if all retries fail.",
          "explanation": "`retryWithDelay` should retry the `fetch` call with a delay of 1 second between each retry, up to 3 times, if the initial call fails."
        }
      ],
      "solutions": [
        {
          "approach": "Recursive Retry with setTimeout Delay",
          "code": "function retryWithDelay(fn, retries, delay) {\n  return new Promise((resolve, reject) => {\n    function attempt(retriesRemaining) {\n      fn()\n        .then(resolve)\n        .catch(err => {\n          if (retriesRemaining > 0) {\n            setTimeout(() => {\n              attempt(retriesRemaining - 1); // Retry after delay\n            }, delay);\n          } else {\n            reject(err); // Reject after all retries\n          }\n        });\n    }\n    attempt(retries); // Initial attempt\n  });\n}",
          "explanation": "This implementation uses recursion and `setTimeout` to create a retry mechanism with a specified delay between retries. It ensures that retries are attempted only after the delay period."
        }
      ]
    },
    {
      "id": "pq48",
      "title": "Implement a Simple Memoization Function",
      "category": "JavaScript, Optimization",
      "difficulty": "Easy",
      "description": "Write a higher-order function `memoize` in JavaScript that takes a function as an argument and returns a memoized version of that function. The memoized function should cache the results of expensive function calls and return the cached result when the same inputs occur again.",
      "methodology": {
        "approach": "Closures and Cache Object",
        "explanation": "Memoization is a technique to optimize functions by caching results based on input arguments. We can use closures to create a cache that is associated with the memoized function.\n\n1. Create a function `memoize(func)` that takes the function `func` to be memoized as input.\n2. Inside `memoize`, create a `cache` object (or Map) to store results. Use arguments as keys and results as values.\n3. Return a new function (the memoized function).\n4. Inside the memoized function:\n   - Convert the arguments to a cache key (e.g., using `JSON.stringify` for simple arguments or a custom key generation for complex arguments).\n   - Check if the key exists in the `cache`.\n   - If the key exists, return the cached result from the `cache`.\n   - If the key does not exist, call the original function `func` with the arguments.\n   - Store the result in the `cache` using the generated key.\n   - Return the calculated result.",
        "timeComplexity": "O(1) for memoized calls (cache hit), excluding the original function's execution time. O(T) for first-time calls (cache miss), where T is the time complexity of the original function.",
        "spaceComplexity": "O(M), where M is the number of unique input argument sets for which the function is called and results are cached. Space is used to store the `cache` object.",
        "javascriptSpecific": true
      },
      "examples": [
        {
          "input": "const expensiveFunc = (n) => { console.log('Calculating...'); return n * n; }; const memoizedFunc = memoize(expensiveFunc); memoizedFunc(5); // Calculates and logs 'Calculating...' memoizedFunc(5); // Returns cached result, no 'Calculating...' log.",
          "output": "The first call to `memoizedFunc(5)` calculates and logs 'Calculating...'. Subsequent calls with the same argument '5' return the cached result without recalculating.",
          "explanation": "The `memoize` function efficiently caches results, avoiding redundant computations for the same inputs, especially beneficial for expensive functions."
        }
      ],
      "solutions": [
        {
          "approach": "Closures and Simple Cache Object",
          "code": "function memoize(func) {\n  const cache = {};\n  return function memoizedFunction(...args) {\n    const key = JSON.stringify(args); // Simple key generation\n    if (cache[key]) {\n      return cache[key]; // Return cached result\n    } else {\n      const result = func.apply(this, args);\n      cache[key] = result; // Cache result\n      return result;\n    }\n  };\n}",
          "explanation": "This basic `memoize` implementation uses a closure to create a `cache` object and JSON.stringify for simple argument-based caching. For more complex argument types or cache invalidation strategies, a more sophisticated approach might be needed."
        }
      ]
    },
    {
      "id": "pq49",
      "title": "Implement a Simple Scheduler (Task Runner)",
      "category": "JavaScript, Asynchronous",
      "difficulty": "Medium",
      "description": "Design and implement a basic task scheduler in JavaScript. It should allow adding tasks (functions returning Promises) with priorities, and execute them based on priority. Higher priority tasks should be executed before lower priority tasks.",
      "methodology": {
        "approach": "Priority Queue and Task Execution Loop",
        "explanation": "A priority task scheduler can be implemented using a priority queue to store tasks and an execution loop to process tasks from the queue based on priority.\n\n1. Create a `TaskScheduler` class.\n2. In the constructor, initialize a priority queue (you can use an array and implement priority queue logic, or use a specialized priority queue data structure if available). The priority queue should store tasks as objects with `priority` and `taskFn` (function returning promise) properties.\n3. Implement an `addTask(taskFn, priority)` method:\n   - Create a task object `{ taskFn, priority }`.\n   - Add the task object to the priority queue, maintaining priority order (e.g., using insertion sort or a heap-based priority queue). Higher priority values mean higher priority.\n   - If the scheduler is not currently running, start the scheduler's execution loop.\n4. Implement a scheduler execution loop (e.g., a `runTasks` method):\n   - Check if the priority queue is empty. If so, stop the loop.\n   - Dequeue the highest priority task from the priority queue.\n   - Execute the `taskFn` of the dequeued task.\n   - Use `.then()` to handle task completion:\n     - After task completion, recursively call `runTasks` to process the next task in the queue.\n   - Handle task rejection (`.catch()`) as needed (e.g., log error, continue with next task).",
        "timeComplexity": "O(N log N + M*T) if using a heap-based priority queue, where N is the number of tasks added, M is the number of tasks executed, and T is the average time complexity of task functions. Adding tasks is O(log N), and executing M tasks takes M * average task time.",
        "spaceComplexity": "O(N), where N is the number of tasks in the queue, to store the priority queue.",
        "javascriptSpecific": true
      },
      "examples": [
        {
          "input": "const scheduler = new TaskScheduler(); scheduler.addTask(() => delayPromise(100, 'Low Priority Task'), 1); scheduler.addTask(() => delayPromise(50, 'High Priority Task'), 5);",
          "output": "'High Priority Task' will be executed and resolved before 'Low Priority Task', even though it was added after.",
          "explanation": "The TaskScheduler prioritizes task execution based on the assigned priority, ensuring higher priority tasks are processed first."
        }
      ],
      "solutions": [
        {
          "approach": "Array-Based Priority Queue and Task Loop",
          "code": "class TaskScheduler {\n  constructor() {\n    this.taskQueue = []; // Array as priority queue (simple for example)\n    this.isProcessing = false;\n  }\n\n  addTask(taskFn, priority) {\n    this.taskQueue.push({ taskFn, priority });\n    this.taskQueue.sort((a, b) => b.priority - a.priority); // Sort by priority (descending)\n    if (!this.isProcessing) {\n      this.runTasks();\n    }\n  }\n\n  runTasks() {\n    if (this.taskQueue.length === 0) {\n      this.isProcessing = false;\n      return;\n    }\n\n    this.isProcessing = true;\n    const nextTask = this.taskQueue.shift(); // Get highest priority task\n\n    nextTask.taskFn()\n      .then(() => {\n        this.runTasks(); // Process next task\n      })\n      .catch(err => {\n        console.error('Task failed:', err);\n        this.runTasks(); // Continue with next task despite error\n      });\n  }\n}",
          "explanation": "This code uses a simple array and `.sort()` to implement a basic priority queue. For a large number of tasks, a more efficient priority queue data structure (like a heap) would be recommended for better performance."
        }
      ]
    },
    {
      "id": "pq50",
      "title": "Implement a Simple Rate Limiter using Token Bucket Algorithm",
      "category": "Design",
      "difficulty": "Hard",
      "description": "Design and implement a rate limiter using the Token Bucket algorithm. Implement a `shouldAllowRequest(clientId)` function that returns `true` if a request from `clientId` should be allowed, and `false` otherwise. Assume a token bucket with a fixed bucket size and a token refill rate.",
      "methodology": {
        "approach": "Token Bucket Algorithm",
        "explanation": "The Token Bucket algorithm is a common rate-limiting algorithm. It involves a bucket that holds tokens. Each request consumes a token. Tokens are refilled into the bucket at a constant rate. If there are enough tokens in the bucket for a request, the request is allowed, and tokens are removed. If not, the request is rate-limited.\n\n1. Create a `TokenBucketRateLimiter` class with a constructor that takes `bucketSize` (max tokens), `refillRatePerMinute` (tokens added per minute).\n2. Inside the constructor, initialize a `clientBuckets` Map to store token buckets for each client, and `lastRefillTimestamp` to track the last token refill time.\n3. Implement the `shouldAllowRequest(clientId)` function:\n   - Get the current timestamp.\n   - Calculate the time elapsed since the last refill.\n   - Calculate the number of tokens to refill based on the elapsed time and `refillRatePerMinute`. Add these tokens to the client's bucket (up to `bucketSize` limit).\n   - Update `lastRefillTimestamp` to the current time.\n   - Get the current token count for the `clientId` bucket from `clientBuckets`. If the client is new, initialize a new bucket with `bucketSize` tokens.\n   - If the client's bucket has at least one token (token count > 0):\n     - Decrement the token count in the client's bucket.\n     - Return `true` (allow request).\n   - Otherwise, return `false` (rate limit exceeded, reject request).",
        "timeComplexity": "O(1) for `shouldAllowRequest` operation, as token bucket operations (get, set, update) are typically O(1) on average with a hash map.",
        "spaceComplexity": "O(C), where C is the number of active clients being tracked, for storing token buckets in the `clientBuckets` Map.",
        "javascriptSpecific": false
      },
      "examples": [
        {
          "input": "TokenBucketRateLimiter limiter = new TokenBucketRateLimiter(5, 10); // Bucket size 5, 10 tokens refill per minute limiter.shouldAllowRequest('clientA'); // true (bucket has tokens) ...  After using up all initial tokens (5 requests). Wait for 6 seconds (1 token refill). limiter.shouldAllowRequest('clientA'); // true (1 token refilled)",
          "output": "Behavior as described, demonstrating token consumption and token refill over time.",
          "explanation": "The example shows how the Token Bucket rate limiter allows requests as long as there are tokens in the bucket, and tokens are refilled at a defined rate, allowing for burst traffic up to bucket capacity and then enforcing a steady rate."
        }
      ],
      "solutions": [
        {
          "approach": "Token Bucket Algorithm Implementation",
          "code": "class TokenBucketRateLimiter {\n  constructor(bucketSize, refillRatePerMinute) {\n    this.bucketSize = bucketSize;\n    this.refillRatePerMs = refillRatePerMinute / 60000; // Tokens per millisecond\n    this.clientBuckets = new Map(); // clientId -> tokenCount\n    this.lastRefillTimestamp = Date.now();\n  }\n\n  shouldAllowRequest(clientId) {\n    const currentTime = Date.now();\n    const timeElapsed = currentTime - this.lastRefillTimestamp;\n    const tokensToAdd = Math.floor(timeElapsed * this.refillRatePerMs);\n    this.lastRefillTimestamp = currentTime;\n\n    let clientBucket = this.clientBuckets.get(clientId) || this.bucketSize; // New client starts with full bucket\n    clientBucket = Math.min(this.bucketSize, clientBucket + tokensToAdd); // Refill, up to bucketSize\n\n    if (clientBucket >= 1) { // Enough tokens, allow request\n      this.clientBuckets.set(clientId, clientBucket - 1);\n      return true;\n    } else {\n      this.clientBuckets.set(clientId, clientBucket); // Update bucket even if rejected (for refill calc)\n      return false; // Rate limited\n    }\n  }\n}",
          "explanation": "This code provides a basic implementation of the Token Bucket rate limiting algorithm. It manages token refills based on time and allows requests as long as tokens are available in the bucket for each client."
        }
      ]
    },
     {
      "id": "pq51",
      "title": "Implement a Simple Trie (Prefix Tree)",
      "category": "Trees, Strings",
      "difficulty": "Medium",
      "description": "Implement a Trie (Prefix Tree) data structure. It should support `insert(word)`, `search(word)`, `startsWith(prefix)` operations.",
      "methodology": {
        "approach": "Tree Structure for Prefixes",
        "explanation": "A Trie (Prefix Tree) is a tree-like data structure used for efficient retrieval of keys in a dataset of strings. Each node in the trie represents a prefix of a string, and nodes are structured such that all descendants of a node share a common prefix.\n\n1. Define a `TrieNode` class or object. Each node should have:\n   - `children`: A Map or object to store children nodes, keyed by characters.\n   - `isEndOfWord`: A boolean flag to indicate if this node marks the end of a complete word.\n2. Define a `Trie` class.\n3. `insert(word)`:\n   - Start from the root node.\n   - Iterate through each character of the `word`.\n   - For each character:\n     - Check if the character is already a child of the current node.\n     - If not, create a new `TrieNode` for the character and add it as a child.\n     - Move to the child node (representing the prefix extended by the current character).\n   - After processing all characters of the `word`, mark the current node as `isEndOfWord = true`.\n4. `search(word)`:\n   - Start from the root node.\n   - Iterate through each character of the `word`.\n   - For each character:\n     - Check if the character is a child of the current node.\n     - If not, return `false` (word not found).\n     - Move to the child node.\n   - After processing all characters, return `true` if the current node is marked as `isEndOfWord = true` (word exists), otherwise `false` (prefix but not a complete word).\n5. `startsWith(prefix)`:\n   - Start from the root node.\n   - Iterate through each character of the `prefix`.\n   - For each character:\n     - Check if the character is a child of the current node.\n     - If not, return `false` (prefix not found).\n     - Move to the child node.\n   - If all characters of the `prefix` are found, return `true` (prefix exists).",
        "timeComplexity": "O(L) for `insert`, `search`, `startsWith`, where L is the length of the word or prefix. Trie operations are typically proportional to the length of the string being processed, not the number of words in the trie.",
        "spaceComplexity": "O(A*N*L) in the worst case, where A is the alphabet size, N is the number of words, and L is the average word length. In practice, space complexity is often less due to prefix sharing among words."
      },
      "examples": [
        {
          "input": "Trie trie = new Trie(); trie.insert('apple'); trie.search('apple');   // returns true trie.search('app');     // returns false trie.startsWith('app'); // returns true trie.insert('app'); trie.search('app');     // returns true",
          "output": "Behavior as described, demonstrating Trie operations: insert, search, startsWith.",
          "explanation": "The example shows how a Trie can be used to efficiently store and search for words and prefixes, leveraging the prefix-sharing structure of the Trie."
        }
      ],
      "solutions": [
        {
          "approach": "Trie Implementation with Map for Children",
          "code": "class TrieNode {\n  constructor() {\n    this.children = new Map(); // Map to store child nodes (character -> TrieNode)\n    this.isEndOfWord = false;\n  }\n}\n\nclass Trie {\n  constructor() {\n    this.root = new TrieNode(); // Root node of Trie\n  }\n\n  insert(word) {\n    let currentNode = this.root;\n    for (let char of word) {\n      if (!currentNode.children.has(char)) {\n        currentNode.children.set(char, new TrieNode());\n      }\n      currentNode = currentNode.children.get(char);\n    }\n    currentNode.isEndOfWord = true; // Mark end of word\n  }\n\n  search(word) {\n    let currentNode = this.root;\n    for (let char of word) {\n      if (!currentNode.children.has(char)) {\n        return false; // Character not found in Trie\n      }\n      currentNode = currentNode.children.get(char);\n    }\n    return currentNode.isEndOfWord; // Check if it's end of word\n  }\n\n  startsWith(prefix) {\n    let currentNode = this.root;\n    for (let char of prefix) {\n      if (!currentNode.children.has(char)) {\n        return false; // Prefix not found\n      }\n      currentNode = currentNode.children.get(char);\n    }\n    return true; // Prefix found\n  }\n}",
          "explanation": "This code implements a Trie data structure using JavaScript classes. It uses a Map to store children nodes, allowing efficient character-based traversal for insert, search, and startsWith operations."
        }
      ]
    },
    {
      "id": "pq52",
      "title": "Prototype Chaining in JavaScript",
      "category": "JavaScript, Concepts",
      "difficulty": "Medium",
      "description": "Explain the concept of prototype chaining in JavaScript. How does it enable inheritance and property lookup?",
      "methodology": {
        "approach": "Explanation and Example",
        "explanation": "Prototype chaining is the mechanism in JavaScript that allows objects to inherit properties and methods from other objects. Every object in JavaScript has a prototype, which is itself an object. When you try to access a property of an object, JavaScript first looks for the property directly on the object itself. If not found, it then searches the object's prototype, then the prototype of that prototype, and so on, up the chain until it finds the property or reaches the end of the chain (null prototype). This chain of prototypes is the 'prototype chain'. It's the foundation of inheritance and property delegation in JavaScript.\n\nTime Complexity: O(P) in the worst case, where P is the length of the prototype chain. In practice, chains are usually short.\nSpace Complexity: O(1) - constant space for lookup.",
        "timeComplexity": "O(P)",
        "spaceComplexity": "O(1)"
      },
      "examples": [
        {
          "input": "Illustrate with code example showing object inheriting properties from a prototype object.",
          "output": "Example code demonstrating inheritance and property access through the prototype chain.",
          "explanation": "Example should clearly show how properties are resolved through the chain and how methods are inherited."
        }
      ],
      "solutions": [
        {
          "approach": "Code Example and Explanation",
          "code": "// Constructor function\nfunction Animal(name) {\n  this.name = name;\n}\n\nAnimal.prototype.speak = function() {\n  console.log(this.name + ' makes a sound.');\n};\n\n// Another constructor function inheriting from Animal\nfunction Dog(name, breed) {\n  Animal.call(this, name); // Call Animal constructor to set 'name'\n  this.breed = breed;\n}\n\n// Set up prototype chain: Dog.prototype inherits from Animal.prototype\nDog.prototype = Object.create(Animal.prototype);\nDog.prototype.constructor = Dog; // Reset constructor property\n\nDog.prototype.bark = function() {\n  console.log(this.name + ' barks!');\n};\n\nconst animal = new Animal('Generic Animal');\nconst dog = new Dog('Buddy', 'Golden Retriever');\n\nanimal.speak(); // Generic Animal makes a sound.\ndog.speak();    // Buddy makes a sound. (Inherited from Animal)\ndog.bark();     // Buddy barks! (Defined in Dog)\n\nconsole.log(dog instanceof Animal); // true\nconsole.log(animal instanceof Dog); // false",
          "explanation": "This code demonstrates prototype chaining:\n1. `Animal` and `Dog` constructor functions.\n2. `Dog.prototype = Object.create(Animal.prototype)` sets up inheritance.\n3. `Dog` instances inherit `speak` from `Animal.prototype` and have their own `bark`.\n4. `instanceof` operator shows the prototype relationship."
        }
      ]
    },
    {
      "id": "pq53",
      "title": "Closures and Lexical Scope in JavaScript",
      "category": "JavaScript, Concepts",
      "difficulty": "Medium",
      "description": "Explain closures and lexical scope in JavaScript. Provide an example demonstrating how closures can access variables from their outer (enclosing) scope even after the outer function has returned.",
      "methodology": {
        "approach": "Explanation and Code Example",
        "explanation": "Lexical scope (or static scope) means that in JavaScript, the scope of a variable is determined by where it is declared in the source code. Closures are functions that remember their lexical scope even when they are executed outside that scope.  A closure gives you access to an outer function's scope from an inner function. In JavaScript, closures are created every time a function is created, at function creation time.\n\nTime Complexity: O(1) for closure creation and access. Execution time of the closure depends on the function's body.\nSpace Complexity: O(S), where S is the size of the variables captured in the closure from the outer scope. ",
        "timeComplexity": "O(1)",
        "spaceComplexity": "O(S)"
      },
      "examples": [
        {
          "input": "Illustrate closure with a function that returns another function, and the returned function accesses a variable from the outer function's scope.",
          "output": "Code example showing a closure accessing and 'remembering' variables from its lexical scope.",
          "explanation": "Example should clearly demonstrate how the inner function retains access to the outer function's variables even after the outer function completes."
        }
      ],
      "solutions": [
        {
          "approach": "Code Example and Explanation",
          "code": "function outerFunction(outerVar) {\n  const innerVar = 'Inner Variable';\n\n  function innerFunction() {\n    console.log('Outer variable:', outerVar); // Accessing outerVar\n    console.log('Inner variable:', innerVar); // Accessing innerVar\n  }\n\n  return innerFunction; // Returning the inner function\n}\n\nconst closureExample = outerFunction('Outer Scope Variable');\nclosureExample(); // Invoke the closure\n\n// Even after outerFunction has finished executing, \n// closureExample (innerFunction) still has access to outerVar and innerVar.",
          "explanation": "This code demonstrates closures:\n1. `outerFunction` defines `outerVar` and `innerVar`.\n2. `innerFunction` (closure) is defined inside `outerFunction` and accesses both variables.\n3. `outerFunction` returns `innerFunction`.\n4. `closureExample` holds the returned `innerFunction`.\n5. When `closureExample()` is called, it can still access `outerVar` and `innerVar` because of the closure, even though `outerFunction`'s execution context is gone."
        }
      ]
    },
    {
      "id": "pq54",
      "title": "Async/Await in JavaScript",
      "category": "JavaScript, Asynchronous",
      "difficulty": "Medium",
      "description": "Explain how async/await simplifies asynchronous JavaScript code. Show an example of using async/await to handle promises and make asynchronous code look and behave a bit more like synchronous code.",
      "methodology": {
        "approach": "Explanation and Code Comparison",
        "explanation": "Async/await is syntactic sugar built on top of promises in JavaScript that makes asynchronous code easier to write and read. `async` functions always return a promise. `await` can only be used inside an `async` function. It pauses the execution of the async function until the promise after `await` is resolved (or rejected). This makes asynchronous operations appear synchronous, simplifying error handling and control flow in asynchronous code.\n\nTime Complexity: Depends on the asynchronous operations being awaited. Async/await itself adds minimal overhead.\nSpace Complexity: Depends on the promise chain and call stack, similar to promises themselves.",
        "timeComplexity": "N/A",
        "spaceComplexity": "N/A"
      },
      "examples": [
        {
          "input": "Compare promise-based asynchronous code with its async/await equivalent for fetching data.",
          "output": "Code examples showing both promise-based and async/await approaches to asynchronous data fetching, highlighting the simplicity of async/await.",
          "explanation": "Examples should clearly contrast the code structure and readability benefits of async/await compared to traditional promise chaining."
        }
      ],
      "solutions": [
        {
          "approach": "Code Comparison - Promises vs. Async/Await",
          "code": "// Promise-based approach\nfunction fetchDataPromise() {\n  return fetch('https://jsonplaceholder.typicode.com/todos/1')\n    .then(response => {\n      if (!response.ok) {\n        throw new Error('Network response was not ok');\n      }\n      return response.json();\n    })\n    .then(data => {\n      console.log('Data fetched using Promises:', data);\n      return data;\n    })\n    .catch(error => {\n      console.error('Error fetching data (Promises):', error);\n      throw error;\n    });\n}\n\n// Async/Await approach\nasync function fetchDataAsyncAwait() {\n  try {\n    const response = await fetch('https://jsonplaceholder.typicode.com/todos/1');\n    if (!response.ok) {\n      throw new Error('Network response was not ok');\n    }\n    const data = await response.json();\n    console.log('Data fetched using Async/Await:', data);\n    return data;\n  } catch (error) {\n    console.error('Error fetching data (Async/Await):', error);\n    throw error;\n  }\n}\n\nfetchDataPromise();\nfetchDataAsyncAwait();",
          "explanation": "Comparison:\n1. **Promises:** Uses `.then()` chaining for sequential async operations and `.catch()` for error handling. Can become complex with multiple chained promises.\n2. **Async/Await:**\n   - `async` keyword makes `fetchDataAsyncAwait` return a promise.\n   - `await fetch(...)` pauses execution until fetch promise resolves.\n   - `await response.json()` pauses until JSON parsing is done.\n   - `try...catch` block handles errors synchronously, making error handling cleaner and more synchronous-looking.\n\nAsync/await makes the asynchronous code look more like synchronous code, improving readability and making it easier to reason about the flow and handle errors."
        }
      ]
    },
    {
      "id": "pq55",
      "title": "Detect Cycle in a Linked List",
      "category": "Linked Lists, Algorithms",
      "difficulty": "Medium",
      "description": "Given the head of a singly linked list, detect if the linked list has a cycle. Return true if there is a cycle, false otherwise.",
      "methodology": {
        "approach": "Floyd's Cycle-Finding Algorithm (Tortoise and Hare)",
        "explanation": "Floyd's Cycle-Finding Algorithm, also known as the Tortoise and Hare algorithm, is an efficient way to detect cycles in a linked list using two pointers moving at different speeds.\n\n1. Initialize two pointers, `slow` (tortoise) and `fast` (hare), both starting at the head of the linked list.\n2. Move `slow` pointer one step at a time, and `fast` pointer two steps at a time in each iteration.\n3. If there is a cycle, the `fast` pointer will eventually meet the `slow` pointer within the cycle.\n4. If there is no cycle, the `fast` pointer will reach the end of the list (null) before meeting the `slow` pointer.\n5. If `fast` pointer becomes null or `fast.next` becomes null, it means there is no cycle, return `false`.\n6. If `slow` and `fast` pointers meet at any point (`slow === fast`), it means there is a cycle, return `true`.\n\nTime Complexity: O(n), where n is the number of nodes in the linked list. In the worst case (cycle at the end or no cycle), both pointers traverse the list at most once.\nSpace Complexity: O(1) - constant space, as we only use two pointers.",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)"
      },
      "examples": [
        {
          "input": "Linked list with a cycle: 1->2->3->4->5->...->3 (node 3 points back to itself, creating a cycle)",
          "output": "true",
          "explanation": "The algorithm should detect the cycle and return true."
        },
        {
          "input": "Linear linked list: 1->2->3->4->5->NULL",
          "output": "false",
          "explanation": "The algorithm should correctly identify that there is no cycle and return false."
        }
      ],
      "solutions": [
        {
          "approach": "Floyd's Tortoise and Hare Algorithm",
          "code": "function hasCycle(head) {\n  if (!head || !head.next) {\n    return false; // No cycle in empty or single-node list\n  }\n\n  let slow = head;\n  let fast = head.next;\n\n  while (fast && fast.next) {\n    if (slow === fast) {\n      return true; // Cycle detected\n    }\n    slow = slow.next;      // Tortoise moves one step\n    fast = fast.next.next; // Hare moves two steps\n  }\n\n  return false; // No cycle found\n}",
          "explanation": "1. Initialize `slow` and `fast` pointers at head and head.next.\n2. `while (fast && fast.next)`: Iterate as long as `fast` and `fast.next` are valid nodes.\n3. `if (slow === fast)`: Check if pointers meet (cycle detected).\n4. `slow = slow.next`: Move `slow` one step.\n5. `fast = fast.next.next`: Move `fast` two steps.\n6. If loop ends without pointers meeting, return `false` (no cycle)."
        }
      ]
    },
    {
      "id": "pq56",
      "title": "Find Middle Node of a Linked List",
      "category": "Linked Lists, Algorithms",
      "difficulty": "Easy",
      "description": "Given the head of a singly linked list, find the middle node. If there are two middle nodes (in case of even length list), return the second middle node.",
      "methodology": {
        "approach": "Two Pointers (Tortoise and Hare)",
        "explanation": "Similar to cycle detection, we can use two pointers, 'slow' and 'fast', moving at different speeds to find the middle node of a linked list.\n\n1. Initialize two pointers, `slow` and `fast`, both starting at the head of the linked list.\n2. Move `slow` pointer one step at a time, and `fast` pointer two steps at a time in each iteration.\n3. When the `fast` pointer reaches the end of the list (or `fast.next` is null), the `slow` pointer will be at the middle node (or the second middle node in case of even length).\n4. Return the `slow` pointer.\n\nTime Complexity: O(n), where n is the number of nodes in the linked list. The fast pointer traverses the list at most once.\nSpace Complexity: O(1) - constant space, using only two pointers.",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)"
      },
      "examples": [
        {
          "input": "Linked list: 1->2->3->4->5->NULL",
          "output": "Node with value 3",
          "explanation": "The middle node in a 5-node list is the 3rd node (value 3)."
        },
        {
          "input": "Linked list: 1->2->3->4->5->6->NULL",
          "output": "Node with value 4",
          "explanation": "For an even length list (6 nodes), the second middle node is the 4th node (value 4)."
        }
      ],
      "solutions": [
        {
          "approach": "Tortoise and Hare Approach",
          "code": "function findMiddleNode(head) {\n  if (!head) {\n    return null; // Empty list\n  }\n\n  let slow = head;\n  let fast = head;\n\n  while (fast && fast.next) {\n    slow = slow.next;      // Slow pointer moves one step\n    fast = fast.next.next; // Fast pointer moves two steps\n  }\n\n  return slow; // Slow pointer is at the middle node\n}",
          "explanation": "1. Initialize `slow` and `fast` pointers at the head.\n2. `while (fast && fast.next)`: Iterate as long as `fast` and `fast.next` are valid.\n3. `slow = slow.next`: Move `slow` one step.\n4. `fast = fast.next.next`: Move `fast` two steps.\n5. Return `slow` pointer when `fast` reaches the end, `slow` will be at the middle."
        }
      ]
    },
    {
      "id": "pq57",
      "title": "Rotate Array",
      "category": "Arrays, Algorithms",
      "difficulty": "Medium",
      "description": "Given an array, rotate the array to the right by k steps, where k is non-negative.",
      "methodology": {
        "approach": "Reverse Array Segments",
        "explanation": "An efficient way to rotate an array in-place is by reversing segments of the array. We can reverse the entire array, then reverse the first k elements, and finally reverse the remaining elements from k to the end.\n\n1. Calculate the effective rotation steps `k = k % nums.length` to handle cases where k is larger than the array length.\n2. Reverse the entire array `nums`.\n3. Reverse the first `k` elements of the array (from index 0 to k-1).\n4. Reverse the remaining elements of the array (from index k to nums.length - 1).\n\nThis three-step reversal achieves the right rotation in-place.\n\nTime Complexity: O(n), where n is the length of the array, as we reverse the entire array and segments of it, each reversal taking O(n) time.\nSpace Complexity: O(1) - constant space, as the rotation is done in-place.",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)"
      },
      "examples": [
        {
          "input": "nums = [1,2,3,4,5,6,7], k = 3",
          "output": "[5,6,7,1,2,3,4]",
          "explanation": "Rotate 3 steps to the right: [7,1,2,3,4,5,6] -> [6,7,1,2,3,4,5] -> [5,6,7,1,2,3,4]"
        },
        {
          "input": "nums = [-1,-100,3,99], k = 2",
          "output": "[3,99,-1,-100]",
          "explanation": "Rotate 2 steps to the right: [99,-1,-100,3] -> [3,99,-1,-100]"
        }
      ],
      "solutions": [
        {
          "approach": "Reverse Segments",
          "code": "function rotateArray(nums, k) {\n  k = k % nums.length; // Effective rotations\n\n  function reverse(arr, start, end) {\n    while (start < end) {\n      [arr[start], arr[end]] = [arr[end], arr[start]];\n      start++;\n      end--;\n    }\n  }\n\n  reverse(nums, 0, nums.length - 1);         // Reverse entire array\n  reverse(nums, 0, k - 1);                   // Reverse first k elements\n  reverse(nums, k, nums.length - 1);        // Reverse remaining elements\n\n  return nums;\n}",
          "explanation": "1. `k = k % nums.length`: Normalize rotations.\n2. `reverse(arr, start, end)`: Helper function to reverse array segment.\n3. `reverse(nums, 0, nums.length - 1)`: Reverse the whole array.\n4. `reverse(nums, 0, k - 1)`: Reverse first k elements.\n5. `reverse(nums, k, nums.length - 1)`: Reverse elements from k to end.\n6. Return rotated `nums`."
        }
      ]
    },
    {
      "id": "pq58",
      "title": "Maximum Subarray",
      "category": "Arrays, Dynamic Programming",
      "difficulty": "Medium",
      "description": "Given an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.",
      "methodology": {
        "approach": "Kadane's Algorithm",
        "explanation": "Kadane's Algorithm is a dynamic programming approach to solve the maximum subarray problem efficiently in linear time. It iterates through the array, keeping track of the current maximum subarray sum ending at the current position (`currentMax`) and the overall maximum subarray sum found so far (`globalMax`).\n\n1. Initialize `globalMax` to negative infinity (or the first element of the array) and `currentMax` to 0.\n2. Iterate through the array `nums`.\n3. For each element `nums[i]`:\n   - Update `currentMax`: `currentMax = Math.max(nums[i], currentMax + nums[i])`. This means the maximum subarray ending at index `i` is either just `nums[i]` itself, or extends the previous maximum subarray (`currentMax + nums[i]`).\n   - Update `globalMax`: `globalMax = Math.max(globalMax, currentMax)`. Update the overall maximum sum if the current maximum is greater.\n4. After iterating through the entire array, `globalMax` will hold the maximum subarray sum.\n\nTime Complexity: O(n), where n is the length of the array, as we iterate through the array once.\nSpace Complexity: O(1) - constant space, as we only use a few variables (`globalMax`, `currentMax`).",
        "timeComplexity": "O(n)",
        "spaceComplexity": "O(1)"
      },
      "examples": [
        {
          "input": "nums = [-2,1,-3,4,-1,2,1,-5,4]",
          "output": "6",
          "explanation": "[4,-1,2,1] has the largest sum = 6."
        },
        {
          "input": "nums = [1]",
          "output": "1",
          "explanation": "The largest subarray sum is just the single element 1."
        },
        {
          "input": "nums = [-2, -3, -4]",
          "output": "-2",
          "explanation": "If all numbers are negative, the largest subarray sum is the largest single number, which is -2."
        }
      ],
      "solutions": [
        {
          "approach": "Kadane's Algorithm",
          "code": "function maxSubArray(nums) {\n  let globalMax = -Infinity; // Initialize with negative infinity\n  let currentMax = 0;\n\n  for (let i = 0; i < nums.length; i++) {\n    currentMax = Math.max(nums[i], currentMax + nums[i]); // Update currentMax\n    globalMax = Math.max(globalMax, currentMax);       // Update globalMax\n  }\n\n  return globalMax;\n}",
          "explanation": "1. Initialize `globalMax = -Infinity`, `currentMax = 0`.\n2. Iterate through `nums` array.\n3. `currentMax = Math.max(nums[i], currentMax + nums[i])`: Decide to start new subarray or extend current.\n4. `globalMax = Math.max(globalMax, currentMax)`: Update overall max sum.\n5. Return `globalMax` after iteration."
        }
      ]
    },
    {
      "id": "pq59",
      "title": "Check if Two Strings are Anagrams",
      "category": "Strings, Hash Tables",
      "difficulty": "Easy",
      "description": "Given two strings s and t, determine if they are anagrams. An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.",
      "methodology": {
        "approach": "Frequency Counting (Hash Map)",
        "explanation": "To check if two strings are anagrams, we can count the frequency of each character in both strings. If the frequency counts are identical for all characters, then the strings are anagrams.\n\n1. Create two frequency maps (objects or Maps), one for each string (`s` and `t`).\n2. Iterate through string `s` and count the frequency of each character in the first map.\n3. Iterate through string `t` and count the frequency of each character in the second map.\n4. Compare the two frequency maps. Iterate through the keys (characters) of the first map.\n5. For each key, check if it exists in the second map and if the frequencies are the same.\n6. If any character has different frequencies or is present in one map but not the other, return `false` (not anagrams).\n7. If all character frequencies match, return `true` (anagrams).\n\nAlternatively, we can use a single frequency map and increment counts for string `s` and decrement counts for string `t`. Finally check if all counts in the map are zero.\n\nTime Complexity: O(n + m) or effectively O(max(n, m)), where n and m are the lengths of strings s and t, as we iterate through both strings once to count frequencies and then compare them (or O(n) if lengths are assumed to be similar). \nSpace Complexity: O(1) - constant space, because the number of possible characters (alphabet size) is constant (e.g., 26 for lowercase English letters). In the worst case, the hash map will store counts for all unique characters in the alphabet.",
        "timeComplexity": "O(max(n, m))",
        "spaceComplexity": "O(1)"
      },
      "examples": [
        {
          "input": "s = \"anagram\", t = \"nagaram\"",
          "output": "true",
          "explanation": "'anagram' and 'nagaram' are anagrams."
        },
        {
          "input": "s = \"rat\", t = \"car\"",
          "output": "false",
          "explanation": "'rat' and 'car' are not anagrams."
        }
      ],
      "solutions": [
        {
          "approach": "Frequency Map Comparison",
          "code": "function isAnagram(s, t) {\n  if (s.length !== t.length) {\n    return false; // Anagrams must have same length\n  }\n\n  const sCharCounts = {};\n  const tCharCounts = {};\n\n  for (let char of s) {\n    sCharCounts[char] = (sCharCounts[char] || 0) + 1;\n  }\n  for (let char of t) {\n    tCharCounts[char] = (tCharCounts[char] || 0) + 1;\n  }\n\n  for (let char in sCharCounts) {\n    if (sCharCounts[char] !== tCharCounts[char]) {\n      return false; // Frequency mismatch\n    }\n  }\n\n  return true; // All frequencies match\n}",
          "explanation": "1. Check if lengths are different, return `false` if so.\n2. Initialize `sCharCounts`, `tCharCounts` (frequency maps).\n3. Count character frequencies for `s` and `t`.\n4. Iterate through `sCharCounts` keys (characters).\n5. `if (sCharCounts[char] !== tCharCounts[char])`: Check if frequencies match in both maps.\n6. If mismatch found, return `false`.\n7. If loop completes, return `true` (all frequencies match)."
        },
        {
          "approach": "Optimized Frequency Counting (Single Map)",
          "code": "function isAnagramOptimized(s, t) {\n    if (s.length !== t.length) return false;\n    const charCounts = {};\n\n    for (let i = 0; i < s.length; i++) {\n        charCounts[s[i]] = (charCounts[s[i]] || 0) + 1; // Increment for s\n        charCounts[t[i]] = (charCounts[t[i]] || 0) - 1; // Decrement for t\n    }\n\n    for (let char in charCounts) {\n        if (charCounts[char] !== 0) return false; // Counts should be zero\n    }\n\n    return true;\n}",
          "explanation": "Optimized version using a single frequency map. Increments counts for `s` and decrements for `t`.  Finally checks if all counts are zero."
        }
      ]
    },
    {
      "id": "pq60",
      "title": "Longest Palindromic Substring",
      "category": "Strings, Dynamic Programming",
      "difficulty": "Medium",
      "description": "Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.",
      "methodology": {
        "approach": "Dynamic Programming",
        "explanation": "We can use dynamic programming to solve this problem. Let `dp[i][j]` be a boolean value indicating whether the substring `s[i...j]` is a palindrome. \n\n1. Create a 2D boolean DP table `dp[n][n]`, where n is the length of the string `s`. `dp[i][j]` will be true if the substring `s[i...j]` is a palindrome, and false otherwise.\n2. Initialize DP table:\n   - All substrings of length 1 are palindromes: `dp[i][i] = true` for all `i`.\n   - Check for substrings of length 2: `dp[i][i+1] = (s[i] === s[i+1])`.\n3. Iterate for substring lengths `len` from 3 to n.\n4. For each length `len`, iterate through starting index `i` from 0 to `n - len + 1`.\n5. Calculate the ending index `j = i + len - 1`.\n6. Check if `s[i] === s[j]` and if the inner substring `s[i+1...j-1]` is a palindrome (`dp[i+1][j-1]`). If both are true, then `dp[i][j] = true`.\n7. While filling the DP table, keep track of the starting and ending indices of the longest palindromic substring found so far.\n8. After filling the table, extract the longest palindromic substring using the tracked indices.\n\nTime Complexity: O(nÂ²) - we fill an n x n DP table, and each cell calculation is O(1).\nSpace Complexity: O(nÂ²) - to store the DP table.",
        "timeComplexity": "O(nÂ²)",
        "spaceComplexity": "O(nÂ²)"
      },
      "examples": [
        {
          "input": "s = \"babad\"",
          "output": "\"bab\" or \"aba\"",
          "explanation": "\"bab\" and \"aba\" are both longest palindromic substrings."
        },
        {
          "input": "s = \"cbbd\"",
          "output": "\"bb\"",
          "explanation": "The longest palindromic substring is \"bb\"."
        },
        {
          "input": "s = \"a\"",
          "output": "\"a\"",
          "explanation": "Single character string is a palindrome."
        }
      ],
      "solutions": [
        {
          "approach": "Dynamic Programming",
          "code": "function longestPalindrome(s) {\n  const n = s.length;\n  if (n < 2) return s; // Base case: single char or empty string\n\n  const dp = Array(n).fill(null).map(() => Array(n).fill(false));\n  let start = 0;\n  let maxLength = 1;\n\n  for (let i = 0; i < n; i++) dp[i][i] = true; // Single chars are palindromes\n  for (let i = 0; i < n - 1; i++) {\n    if (s[i] === s[i + 1]) {\n      dp[i][i + 1] = true;\n      start = i;\n      maxLength = 2;\n    }\n  }\n\n  for (let len = 3; len <= n; len++) {\n    for (let i = 0; i <= n - len; i++) {\n      const j = i + len - 1;\n      if (s[i] === s[j] && dp[i + 1][j - 1]) {\n        dp[i][j] = true;\n        if (len > maxLength) {\n          maxLength = len;\n          start = i;\n        }\n      }\n    }\n  }\n\n  return s.substring(start, start + maxLength);\n}",
          "explanation": "1. Initialize DP table `dp[n][n]`, `start`, `maxLength`.\n2. Base cases: `dp[i][i] = true`, check length 2 substrings.\n3. Iterate for lengths `len = 3 to n`.\n4. Inner loop: iterate for start index `i`.\n5. Calculate end index `j = i + len - 1`.\n6. `if (s[i] === s[j] && dp[i + 1][j - 1])`: check for palindrome condition using DP result for inner substring.\n7. Update `dp[i][j]`, `maxLength`, `start` if palindrome found and it's longer.\n8. Return substring from `start` with `maxLength`."
        },
        {
          "approach": "Expand Around Center (More efficient in some cases)",
          "code": "// Expand Around Center approach (more efficient, often preferred in interviews)\nfunction longestPalindromeExpand(s) {\n    if (!s) return '';\n    let start = 0, end = 0;\n\n    function expandAroundCenter(left, right) {\n        while (left >= 0 && right < s.length && s[left] === s[right]) {\n            left--;\n            right++;\n        }\n        return right - left - 1; // Length of palindrome\n    }\n\n    for (let i = 0; i < s.length; i++) {\n        // Odd length palindrome\n        let len1 = expandAroundCenter(i, i);\n        // Even length palindrome\n        let len2 = expandAroundCenter(i, i + 1);\n        let maxLength = Math.max(len1, len2);\n        if (maxLength > (end - start + 1)) {\n            start = i - Math.floor((maxLength - 1) / 2);\n            end = i + Math.floor(maxLength / 2);\n        }\n    }\n    return s.substring(start, end + 1);\n}",
          "explanation": "More efficient 'Expand Around Center' approach is also provided as it is often preferred in interviews for this problem due to its conceptual simplicity and good performance."
        }
      ]
    },
    {
      "id": "pq61",
      "title": "`this` Keyword in JavaScript",
      "category": "JavaScript, Concepts",
      "difficulty": "Medium",
      "description": "Explain the behavior of the `this` keyword in JavaScript. Describe how its value is determined in different contexts such as global scope, function invocation, method invocation, and within arrow functions.",
      "methodology": {
        "approach": "Explanation and Contextual Examples",
        "explanation": "The `this` keyword in JavaScript refers to the context in which a function is executed. Its value is dynamic and depends on how the function is called. In the global scope, `this` refers to the global object (window in browsers, global in Node.js). In a regular function, the value of `this` depends on how the function is invoked: as a method of an object, `this` refers to the object; invoked as a standalone function, in strict mode `this` is undefined, otherwise it's the global object. In constructor functions, `this` refers to the newly created object. Arrow functions, unlike regular functions, do not have their own `this`. They lexically inherit `this` from the surrounding scope where they are defined.",
        "timeComplexity": "N/A - Conceptual question",
        "spaceComplexity": "N/A - Conceptual question"
      },
      "examples": [
        {
          "input": "Provide code examples demonstrating `this` in global scope, object method, regular function, and arrow function.",
          "output": "Code snippets illustrating different `this` contexts and their resulting values.",
          "explanation": "Examples should clearly show the different values of `this` based on the invocation context and function type."
        }
      ],
      "solutions": [
        {
          "approach": "Code Examples and Explanation",
          "code": "// 1. Global Scope\nconsole.log('Global this (outside function):', this === window); // true (in browser)\n\n// 2. Function Invocation\nfunction regularFunction() {\n  'use strict'; // Try with and without strict mode\n  console.log('Regular function this (strict mode):', this); // undefined in strict mode, global object otherwise\n}\nregularFunction();\n\n// 3. Method Invocation\nconst obj = {\n  method: function() {\n    console.log('Method this:', this === obj); // true\n  }\n};\nobj.method();\n\n// 4. Constructor Function\nfunction ConstructorFunc(name) {\n  this.name = name;\n  console.log('Constructor this:', this instanceof ConstructorFunc); // true\n}\nconst instance = new ConstructorFunc('Example');\n\n// 5. Arrow Function\nconst arrowObj = {\n  arrowMethod: () => {\n    console.log('Arrow function this:', this === window); // true - inherits from global scope\n  }\n};\narrowObj.arrowMethod();",
          "explanation": "This code demonstrates `this` in various contexts:\n1. **Global:** `this` in global scope (browser).\n2. **Regular Function:** `this` depends on strict mode.\n3. **Method:** `this` refers to the object.\n4. **Constructor:** `this` refers to the new instance.\n5. **Arrow Function:** `this` inherits from the surrounding scope (global in this case)."
        }
      ]
    },
    {
      "id": "pq62",
      "title": "`call`, `apply`, and `bind` Methods",
      "category": "JavaScript, Functions",
      "difficulty": "Medium",
      "description": "Explain the purpose and differences between `call`, `apply`, and `bind` methods in JavaScript. Provide examples to illustrate how each of them can be used to manipulate the `this` context and arguments of a function.",
      "methodology": {
        "approach": "Explanation and Comparative Examples",
        "explanation": "`call`, `apply`, and `bind` are function methods in JavaScript used to explicitly set the `this` value when invoking a function. `call` and `apply` both invoke the function immediately. `call` takes arguments individually, while `apply` takes arguments as an array. `bind` does not invoke the function immediately; instead, it returns a new function with the `this` value permanently bound to the provided object and optionally pre-set arguments.",
        "timeComplexity": "O(1) - for method invocation itself. Execution time of the function depends on its implementation.",
        "spaceComplexity": "O(1) - constant space overhead."
      },
      "examples": [
        {
          "input": "Provide code examples demonstrating the use of `call`, `apply`, and `bind` to set `this` and pass arguments to a function.",
          "output": "Code snippets showcasing each method and their distinct ways of handling `this` and arguments.",
          "explanation": "Examples should highlight the syntax and behavioral differences, especially in argument passing and function invocation timing."
        }
      ],
      "solutions": [
        {
          "approach": "Code Examples and Comparison",
          "code": "const person = {\n  name: 'John Doe',\n  greet: function(greeting, punctuation) {\n    console.log(greeting + ', ' + this.name + punctuation);\n  }\n};\n\nconst anotherPerson = {\n  name: 'Jane Smith'\n};\n\n// 1. call()\nperson.greet.call(anotherPerson, 'Hello', '!'); // Hello, Jane Smith!\n\n// 2. apply()\nperson.greet.apply(anotherPerson, ['Hi', '?']); // Hi, Jane Smith?\n\n// 3. bind()\nconst boundGreet = person.greet.bind(anotherPerson, 'Greetings');\nboundGreet('...'); // Greetings, Jane Smith...\nboundGreet('!');   // Greetings, Jane Smith!",
          "explanation": "Demonstration:\n1. **`call()`**: Invokes `greet` with `anotherPerson` as `this` and arguments 'Hello', '!'.\n2. **`apply()`**: Invokes `greet` with `anotherPerson` as `this` and arguments as an array `['Hi', '?']`.\n3. **`bind()`**: Creates `boundGreet` with `this` permanently set to `anotherPerson` and pre-set argument 'Greetings'. Subsequent calls to `boundGreet` use this bound context and argument."
        }
      ]
    },
    {
      "id": "pq63",
      "title": "Event Delegation in JavaScript",
      "category": "JavaScript, DOM Manipulation",
      "difficulty": "Medium",
      "description": "Explain event delegation in JavaScript. Describe its benefits and provide an example of how to implement event delegation to handle events on dynamically added elements within a container.",
      "methodology": {
        "approach": "Explanation and Implementation Example",
        "explanation": "Event delegation is a technique in JavaScript where you attach a single event listener to a parent element, rather than attaching listeners to each of its descendants. The listener function then checks the event target to determine which child element triggered the event and handles it accordingly. Benefits include improved performance (fewer event listeners), simplified code (especially for dynamically added elements, no need to attach new listeners), and reduced memory consumption.",
        "timeComplexity": "O(1) for event handling in delegated scenario, regardless of number of child elements. Actual handler complexity depends on implementation.",
        "spaceComplexity": "O(1) - constant space for single event listener on parent."
      },
      "examples": [
        {
          "input": "Implement event delegation for a list of dynamically added list items. Clicking on any list item should log its text content.",
          "output": "Code example demonstrating event delegation on a dynamically updated list, with click handling logic.",
          "explanation": "Example should show how a single listener on the parent (list container) can handle click events for all current and future list items."
        }
      ],
      "solutions": [
        {
          "approach": "Implementation and Explanation",
          "code": "<ul id=\"list-container\">\n  <!-- List items will be dynamically added here -->\n</ul>\n\n<button id=\"add-item\">Add Item</button>\n\n<script>\n  const listContainer = document.getElementById('list-container');\n  const addItemButton = document.getElementById('add-item');\n  let itemCounter = 0;\n\n  // Event delegation on the container\n  listContainer.addEventListener('click', function(event) {\n    if (event.target && event.target.nodeName === 'LI') { // Check if clicked element is an LI\n      console.log('List item clicked:', event.target.textContent);\n      // Handle click on list item (e.g., remove, edit etc.)\n    }\n  });\n\n  addItemButton.addEventListener('click', function() {\n    itemCounter++;\n    const newItem = document.createElement('li');\n    newItem.textContent = 'Item ' + itemCounter;\n    listContainer.appendChild(newItem);\n  });\n</script>",
          "explanation": "This code demonstrates event delegation:\n1. Listener attached to `list-container` (parent UL).\n2. On click, listener checks `event.target` to see if it's an `LI` (list item).\n3. If yes, it logs the text content of the clicked `LI`.\n4. Dynamically added list items automatically have click handling without attaching individual listeners, due to delegation."
        }
      ]
    },
    {
      "id": "pq64",
      "title": "Prototypal Inheritance vs. Class Inheritance",
      "category": "JavaScript, Object-Oriented Programming",
      "difficulty": "Hard",
      "description": "Compare and contrast prototypal inheritance and class-based inheritance models. Explain how JavaScript implements inheritance using prototypes and how it differs from class-based inheritance found in languages like Java or C++.",
      "methodology": {
        "approach": "Comparative Explanation",
        "explanation": "JavaScript uses prototypal inheritance, where objects inherit directly from other objects (prototypes). Inheritance is based on delegation: when a property is accessed on an object, if not found directly, the prototype chain is traversed. Class-based inheritance (like in Java, C++) uses classes as blueprints. Inheritance is based on class hierarchies and explicit 'extends' relationships. Key differences: Prototypal is more flexible, dynamic, and behavior-centric; Class-based is more structured, static, and type-centric. JavaScript's 'class' syntax (ES6) is syntactic sugar over prototypal inheritance, not true class-based inheritance.",
        "timeComplexity": "N/A - Conceptual question",
        "spaceComplexity": "N/A - Conceptual question"
      },
      "examples": [
        {
          "input": "Illustrate both prototypal and class-based inheritance with conceptual examples or code snippets.",
          "output": "Explanations and examples highlighting the core differences and characteristics of each inheritance model.",
          "explanation": "Examples should contrast how inheritance is set up and how objects inherit properties and behaviors in both paradigms."
        }
      ],
      "solutions": [
        {
          "approach": "Conceptual Explanation and Analogy",
          "code": "/* Prototypal Inheritance (JavaScript) */\n\n// 'Prototype' object acting as blueprint\nconst AnimalPrototype = {\n  speak: function() {\n    console.log(this.name + ' makes a sound.');\n  }\n};\n\n// Object creation inheriting from prototype\nfunction createAnimal(name) {\n  const animal = Object.create(AnimalPrototype);\n  animal.name = name;\n  return animal;\n}\n\nconst protoAnimal = createAnimal('Generic Animal');\nprotoAnimal.speak();\n\n/* Class-based Inheritance (Conceptual - e.g., Java) */\n\n// Conceptual Java-like Class example:\n/*\nclass Animal {\n  String name;\n  public Animal(String name) {\n    this.name = name;\n  }\n  public void speak() {\n    System.out.println(name + \" makes a sound.\");\n  }\n}\n\nclass Dog extends Animal {\n  String breed;\n  public Dog(String name, String breed) {\n    super(name); // Call Animal constructor\n    this.breed = breed;\n  }\n  public void bark() {\n    System.out.println(name + \" barks!\");\n  }\n}\n\nAnimal classAnimal = new Animal(\"Generic Animal\");\nDog classDog = new Dog(\"Buddy\", \"Golden Retriever\");\nclassAnimal.speak();\nclassDog.speak();\nclassDog.bark();\n*/",
          "explanation": "Comparison:\n1. **Prototypal (JavaScript):**\n   - Uses `Object.create` to link objects to prototypes.\n   - Inheritance is object-to-object delegation.\n   - Focus on behavior sharing via prototypes.\n   - Dynamic, can modify prototypes at runtime.\n2. **Class-based (Conceptual Java):**\n   - Uses `class` keyword as blueprint.\n   - Inheritance is class-to-class hierarchy.\n   - Focus on type hierarchy and class relationships.\n   - More static, less runtime flexibility.\n\nJavaScript's 'class' is primarily syntactic sugar for prototypal inheritance, not a fundamentally different inheritance model."
        }
      ]
    },
    {
      "id": "pq65",
      "title": "Hoisting in JavaScript",
      "category": "JavaScript, Concepts",
      "difficulty": "Easy",
      "description": "Explain hoisting in JavaScript, specifically for variable and function declarations. Describe how JavaScript hoists declarations and what are the implications for code execution and variable scope.",
      "methodology": {
        "approach": "Explanation and Code Examples",
        "explanation": "Hoisting is a JavaScript behavior where variable and function declarations are moved to the top of their scope before code execution. However, only declarations are hoisted, not initializations. For variables declared with `var`, they are hoisted and initialized with `undefined`. Functions declared using function declarations are fully hoisted (declaration and body). Let and const declarations are also hoisted but are not initialized, leading to a 'Temporal Dead Zone' until their declaration line is reached.",
        "timeComplexity": "N/A - Conceptual question",
        "spaceComplexity": "N/A - Conceptual question"
      },
      "examples": [
        {
          "input": "Provide code examples illustrating variable hoisting (with `var`, `let`, `const`) and function hoisting.",
          "output": "Code snippets demonstrating hoisting behavior for different types of declarations and their consequences.",
          "explanation": "Examples should clearly show how you can (or cannot) access variables and functions before their actual declaration in the code, due to hoisting."
        }
      ],
      "solutions": [
        {
          "approach": "Code Examples and Explanation",
          "code": "// 1. Variable Hoisting (var)\nconsole.log(varVariable); // Output: undefined (hoisted, but not initialized)\nvar varVariable = 'var hoisted';\nconsole.log(varVariable); // Output: var hoisted\n\n// 2. Variable Hoisting (let and const)\n// console.log(letVariable); // Error: Cannot access 'letVariable' before initialization (Temporal Dead Zone)\nlet letVariable = 'let hoisted';\nconsole.log(letVariable); // Output: let hoisted\n\n// 3. Function Hoisting (Function Declaration)\nfunctionDeclaration(); // Output: Function declaration hoisted! (works before declaration)\nfunction functionDeclaration() {\n  console.log('Function declaration hoisted!');\n}\n\n// 4. Function Hoisting (Function Expression - not hoisted)\n// functionExpression(); // Error: functionExpression is not a function (not hoisted as function declaration)\nvar functionExpression = function() {\n  console.log('Function expression not hoisted as declaration!');\n};\nfunctionExpression(); // Output: Function expression not hoisted as declaration!",
          "explanation": "Demonstration:\n1. **`var`:** Hoisted and initialized to `undefined` initially.\n2. **`let` & `const`:** Hoisted but not initialized (Temporal Dead Zone), causing error if accessed before declaration.\n3. **Function Declaration:** Fully hoisted (declaration + body), callable before its position in code.\n4. **Function Expression:** Variable declaration (`var functionExpression`) is hoisted (like `var`), but the function *definition* is not hoisted. So, you can't call it before the line where it's assigned the function."
        }
      ]
    },
    {
      "id": "pq66",
      "title": "Event Loop in JavaScript",
      "category": "JavaScript, Asynchronous",
      "difficulty": "Hard",
      "description": "Explain the JavaScript event loop and how it enables non-blocking asynchronous operations in a single-threaded environment. Describe the call stack, callback queue (task queue), and microtask queue, and their roles in the event loop process.",
      "methodology": {
        "approach": "Conceptual Explanation and Diagram",
        "explanation": "JavaScript is single-threaded, yet it can handle non-blocking asynchronous operations due to the event loop. The event loop continuously monitors the call stack and the callback/microtask queues. When the call stack is empty, the event loop checks the microtask queue first, then the callback queue. If there are tasks in these queues, it moves the first task to the call stack for execution. Call stack is LIFO, executes synchronous code. Callback queue (task queue) is FIFO, for general async tasks (setTimeout, events). Microtask queue is FIFO, for promise resolutions and mutations. Microtasks have higher priority than callbacks.",
        "timeComplexity": "N/A - Conceptual question",
        "spaceComplexity": "N/A - Conceptual question"
      },
      "examples": [
        {
          "input": "Illustrate the event loop process with an example involving `setTimeout`, promises, and synchronous code execution.",
          "output": "Explanation and conceptual diagram or steps showing how synchronous code, callbacks, and microtasks are processed by the event loop.",
          "explanation": "Example should clearly outline the order of execution and how the event loop manages tasks between call stack, callback queue, and microtask queue."
        }
      ],
      "solutions": [
        {
          "approach": "Explanation with Steps and Conceptual Diagram (Text-based)",
          "code": "/* Conceptual Diagram (Text-based): */\n/*\n  +------------------+\n  |     Call Stack     |\n  +------------------+\n          ^\n          |\n  +------------------+   +---------------------+\n  |  Callback Queue  |---|  Microtask Queue    |\n  +------------------+   +---------------------+\n  |  (e.g., setTimeout)|   |  (e.g., Promises)  |\n  +------------------+   +---------------------+\n          ^\n          |\n  +------------------+\n  |    Event Loop    |\n  +------------------+\n*/\n\n/* Execution Flow Example: */\n\nconsole.log('1. Synchronous task start');\n\nsetTimeout(() => {\n  console.log('4. Callback from setTimeout (Task Queue)');\n}, 0);\n\nPromise.resolve().then(() => {\n  console.log('3. Microtask from Promise (Microtask Queue)');\n});\n\nconsole.log('2. Synchronous task end');\n\n/* Expected Output Order (Event Loop in Action): */\n/*\n1. Synchronous task start\n2. Synchronous task end\n3. Microtask from Promise (Microtask Queue)  <-- Microtasks are processed first\n4. Callback from setTimeout (Task Queue)      <-- Callbacks are processed after Microtasks\n*/",
          "explanation": "Explanation:\n1. **Call Stack:** Executes synchronous code (`console.log('1')`, `console.log('2')`).\n2. **Callback Queue (Task Queue):** `setTimeout` callback is placed here after timer expires.\n3. **Microtask Queue:** Promise `.then()` callback is placed here after promise resolution.\n4. **Event Loop:**\n   - After call stack is empty (sync code done), Event Loop checks Microtask Queue *first*.\n   - Microtask (Promise callback) is moved to call stack and executed (logs '3').\n   - Event Loop checks Microtask Queue again (empty now).\n   - Event Loop checks Callback Queue.\n   - Callback (setTimeout callback) is moved to call stack and executed (logs '4').\n\nOrder: Synchronous -> Microtasks -> Callbacks, demonstrating Event Loop priority."
        }
      ]
    },
    {
      "id": "pq67",
      "title": "Higher-Order Functions in JavaScript",
      "category": "JavaScript, Functions",
      "difficulty": "Easy",
      "description": "Explain what higher-order functions are in JavaScript. Provide examples of built-in higher-order functions like `map`, `filter`, and `reduce`, and demonstrate their use cases.",
      "methodology": {
        "approach": "Explanation and Usage Examples",
        "explanation": "Higher-order functions are functions that can either take other functions as arguments or return functions as results, or both. They are a fundamental concept in functional programming and are heavily used in JavaScript. Examples: `map` transforms each element of an array, `filter` creates a new array with elements that pass a test, `reduce` reduces an array to a single value, `forEach` iterates over array elements, `sort` sorts an array using a comparison function.",
        "timeComplexity": "Depends on the higher-order function and the callback function provided to it. Generally, O(n) for `map`, `filter`, `forEach`, `reduce` where n is array length. `sort` is typically O(n log n).",
        "spaceComplexity": "Depends on the higher-order function. `map`, `filter` create new arrays (O(n)). `reduce` and `forEach` often O(1) extra space (excluding callback's space)."
      },
      "examples": [
        {
          "input": "Provide code examples demonstrating `map`, `filter`, and `reduce` for array manipulation.",
          "output": "Code snippets showing practical applications of these higher-order functions for transforming, filtering, and reducing arrays.",
          "explanation": "Examples should clearly illustrate how to use each function and the type of operations they are best suited for."
        }
      ],
      "solutions": [
        {
          "approach": "Code Examples and Usage Scenarios",
          "code": "// 1. map() - Transforming array elements\nconst numbers = [1, 2, 3, 4, 5];\nconst doubledNumbers = numbers.map(function(number) {\n  return number * 2;\n});\nconsole.log('map(): Doubled numbers:', doubledNumbers); // Output: [2, 4, 6, 8, 10]\n\n// 2. filter() - Filtering array elements\nconst evenNumbers = numbers.filter(number => {\n  return number % 2 === 0;\n});\nconsole.log('filter(): Even numbers:', evenNumbers); // Output: [2, 4]\n\n// 3. reduce() - Reducing array to a single value\nconst sumOfNumbers = numbers.reduce((accumulator, currentValue) => {\n  return accumulator + currentValue;\n}, 0); // 0 is initial accumulator value\nconsole.log('reduce(): Sum of numbers:', sumOfNumbers); // Output: 15\n\n// 4. forEach() - Iterating over array (side effects)\nnumbers.forEach(number => {\n  console.log('forEach(): Number:', number);\n});",
          "explanation": "Demonstration:\n1. **`map()`**: Doubles each number in `numbers` array, creating a new array `doubledNumbers`.\n2. **`filter()`**: Filters `numbers` to keep only even numbers, creating `evenNumbers` array.\n3. **`reduce()`**: Sums all numbers in `numbers` into a single value `sumOfNumbers`.\n4. **`forEach()`**: Iterates over `numbers` and logs each number (example of side effects, `forEach` primarily for side effects, not value transformation)."
        }
      ]
    },
    {
      "id": "pq68",
      "title": "Immutability in JavaScript",
      "category": "JavaScript, Concepts",
      "difficulty": "Medium",
      "description": "Explain the concept of immutability in JavaScript and why it is important, especially in functional programming and managing state in applications. Provide examples of how to achieve immutability with JavaScript objects and arrays.",
      "methodology": {
        "approach": "Explanation and Techniques",
        "explanation": "Immutability means that once an object is created, its state cannot be changed. In JavaScript, primitive values are immutable, but objects and arrays are mutable by default. Immutability is crucial for functional programming, predictability, easier debugging, and state management (e.g., in React, Redux). Techniques to achieve immutability: for objects - `Object.assign({}, originalObject)`, spread syntax `{...originalObject}`, libraries like Immutable.js; for arrays - `slice()`, `concat()`, spread syntax `[...originalArray]`, `map()`, `filter()`, `reduce()`, libraries like Immutable.js.",
        "timeComplexity": "Depends on the immutability technique. Creating shallow copies (Object.assign, spread) is often O(P) where P is number of properties. Deep copy can be O(N) where N is total number of properties in a nested object.",
        "spaceComplexity": "Depends on the immutability technique and size of copied object. Shallow copies create new object referencing original nested objects (O(1) extra space for shallow, O(N) for deep copy in worst case)."
      },
      "examples": [
        {
          "input": "Demonstrate how to create immutable objects and arrays in JavaScript using various techniques.",
          "output": "Code examples showing methods to achieve immutability for both objects and arrays, and contrasting with mutable operations.",
          "explanation": "Examples should showcase both mutable and immutable operations side-by-side to highlight the difference in behavior and how to maintain immutability."
        }
      ],
      "solutions": [
        {
          "approach": "Code Examples and Techniques",
          "code": "// 1. Immutability with Objects\nconst originalObject = { a: 1, b: 2 };\n\n// a) Object.assign() (Shallow copy)\nconst immutableObject1 = Object.assign({}, originalObject);\nimmutableObject1.c = 3; // Modifying copy\nconsole.log('Object.assign(): Original:', originalObject, 'Copy:', immutableObject1); // Original unchanged\n\n// b) Spread Syntax (Shallow copy)\nconst immutableObject2 = {...originalObject};\nimmutableObject2.c = 3;\nconsole.log('Spread Syntax: Original:', originalObject, 'Copy:', immutableObject2); // Original unchanged\n\n// 2. Immutability with Arrays\nconst originalArray = [1, 2, 3];\n\n// a) slice() (Shallow copy)\nconst immutableArray1 = originalArray.slice();\nimmutableArray1.push(4); // Modifying copy\nconsole.log('slice(): Original:', originalArray, 'Copy:', immutableArray1); // Original unchanged\n\n// b) Spread Syntax (Shallow copy)\nconst immutableArray2 = [...originalArray];\nimmutableArray2.push(4);\nconsole.log('Spread Syntax: Original:', originalArray, 'Copy:', immutableArray2); // Original unchanged\n\n// c) map(), filter(), reduce() - Transforming/Filtering (Return new arrays)\nconst mappedArray = originalArray.map(x => x * 2);\nconst filteredArray = originalArray.filter(x => x > 1);\nconsole.log('map(), filter(): Original:', originalArray, 'Mapped:', mappedArray, 'Filtered:', filteredArray); // Original unchanged",
          "explanation": "Demonstration:\n1. **Objects:**\n   - `Object.assign({}, originalObject)`: Creates a shallow copy. Modifying the copy doesn't affect the original.\n   - Spread syntax `{...originalObject}`: Also creates a shallow copy with similar immutability for top-level properties.\n2. **Arrays:**\n   - `slice()`: Creates a shallow copy. `push` on copy doesn't change original.\n   - Spread syntax `[...originalArray]`: Shallow copy, similar to `slice`.\n   - `map()`, `filter()`, `reduce()`: Array methods that inherently return *new* arrays, thus maintaining immutability of the original array."
        }
      ]
    },
    {
      "id": "pq69",
      "title": "Garbage Collection in JavaScript",
      "category": "JavaScript, Concepts",
      "difficulty": "Easy",
      "description": "Briefly explain garbage collection in JavaScript. What is its purpose, and how does JavaScript's garbage collector automatically manage memory?",
      "methodology": {
        "approach": "Concise Explanation",
        "explanation": "Garbage collection (GC) in JavaScript is an automatic memory management process. Its purpose is to reclaim memory occupied by objects that are no longer in use by the program, preventing memory leaks. JavaScript engines typically use algorithms like 'mark and sweep'. The GC periodically identifies which objects are still reachable from the root (global object) and marks them as 'live'. Unreachable objects are considered garbage and their memory is reclaimed. This process is automatic and largely invisible to developers.",
        "timeComplexity": "Garbage collection process itself can have varying time complexity depending on the algorithm and heap size. It's generally designed to be performant but can cause pauses.",
        "spaceComplexity": "Garbage collection aims to reclaim space, thus reducing memory footprint over time. However, GC process itself requires some overhead."
      },
      "examples": [
        {
          "input": "Conceptual explanation of how garbage collection works in a simplified scenario.",
          "output": "A brief, clear description of the garbage collection process and its benefits in JavaScript.",
          "explanation": "Explanation should focus on the automatic nature of GC and the key concepts like reachability and memory reclamation."
        }
      ],
      "solutions": [
        {
          "approach": "Simplified Explanation",
          "code": "/* Simplified Explanation of Garbage Collection: */\n\n// 1. Memory Allocation:\n// When you create objects, JavaScript engine allocates memory for them.\n\nlet myObject = { name: 'Example', value: 10 }; // Memory allocated for myObject\n\n// 2. Reachability Tracking (Simplified 'Mark and Sweep'):\n// GC periodically checks which objects are 'reachable' from the root (e.g., global object, variables in scope).\n\n// 'myObject' is reachable because it's referenced by 'myObject' variable.\n\n// 3. Unreachability Detection:\n// If an object is no longer reachable, GC identifies it as 'garbage'.\n\nmyObject = null; // 'myObject' is now unreachable (no references from root anymore)\n\n// 4. Memory Reclamation (Sweep):\n// Garbage Collector reclaims memory occupied by unreachable objects.\n// Memory used by the object that 'myObject' used to point to is now freed up.\n\n/* Key Points: */\n/*\n- Automatic: GC runs in background, developers don't manually free memory.\n- Prevents Memory Leaks: Reclaims memory from unused objects.\n- 'Mark and Sweep' (Simplified): Common GC algorithm (mark reachable, sweep unreachable).\n- Reachability: Key concept - object is garbage if not reachable from root.\n*/",
          "explanation": "Simplified GC explanation:\n1. **Allocation:** Memory is assigned when objects are created.\n2. **Reachability:** GC tracks reachable objects (starting from root).\n3. **Unreachability:** Objects not reachable are considered garbage.\n4. **Reclamation (Sweep):** Memory of unreachable objects is freed.\n\nKey aspects: Automatic, prevents leaks, uses reachability, employs algorithms like 'mark and sweep'."
        }
      ]
    },
    {
      "id": "pq70",
      "title": "Deep Copy vs. Shallow Copy in JavaScript",
      "category": "JavaScript, Concepts",
      "difficulty": "Easy",
      "description": "Explain the difference between deep copy and shallow copy in JavaScript, particularly in the context of objects and arrays. Provide examples to illustrate shallow copy and deep copy.",
      "methodology": {
        "approach": "Explanation and Comparative Examples",
        "explanation": "Shallow copy creates a new object or array, but for nested objects or arrays, it copies references, not the actual nested objects. So, changes to nested objects in the shallow copy affect the original and vice versa. Deep copy creates a completely independent copy, including all nested objects and arrays. Changes to the deep copy do not affect the original, and vice versa. Shallow copy is faster and less memory-intensive. Deep copy is slower and uses more memory but provides true independence.",
        "timeComplexity": "Shallow copy often O(1) or O(P) where P is number of top-level properties. Deep copy can be O(N) where N is total number of properties in a nested object.",
        "spaceComplexity": "Shallow copy often O(1) extra space (or negligible). Deep copy can be O(N) in worst case to store the completely copied object."
      },
      "examples": [
        {
          "input": "Provide code examples demonstrating shallow copy and deep copy of objects and arrays, and illustrate the difference in behavior when nested properties are modified.",
          "output": "Code snippets showing shallow and deep copy methods and the impact of modifications on original and copied structures.",
          "explanation": "Examples should clearly show how shallow copy shares nested references while deep copy creates independent copies of all levels."
        }
      ],
      "solutions": [
        {
          "approach": "Code Examples and Comparison",
          "code": "// 1. Shallow Copy Example (Objects)\nconst originalObject = { a: 1, b: { c: 2 } };\nconst shallowCopyObject = Object.assign({}, originalObject);\n\nshallowCopyObject.b.c = 3; // Modifying nested property in shallow copy\nconsole.log('Shallow Copy - Object: Original.b.c:', originalObject.b.c, 'Copy.b.c:', shallowCopyObject.b.c); // Both reflect change\n\n// 2. Deep Copy Example (Objects - using JSON.parse/stringify for simple cases)\nconst deepCopyObject = JSON.parse(JSON.stringify(originalObject));\ndeepCopyObject.b.c = 4; // Modifying nested property in deep copy\nconsole.log('Deep Copy - Object: Original.b.c:', originalObject.b.c, 'Copy.b.c:', deepCopyObject.b.c); // Original unchanged\n\n// 3. Shallow Copy Example (Arrays)\nconst originalArray = [1, [2, 3]];\nconst shallowCopyArray = originalArray.slice();\n\nshallowCopyArray[1].push(4); // Modifying nested array in shallow copy\nconsole.log('Shallow Copy - Array: Original[1]:', originalArray[1], 'Copy[1]:', shallowCopyArray[1]); // Both reflect change\n\n// 4. Deep Copy Example (Arrays - using recursion for general cases)\nfunction deepCopyArray(arr) {\n  return Array.isArray(arr) ? arr.map(deepCopyArray) : arr;\n}\n\nconst deepCopyArrayResult = deepCopyArray(originalArray);\ndeepCopyArrayResult[1].push(5);\nconsole.log('Deep Copy - Array: Original[1]:', originalArray[1], 'Copy[1]:', deepCopyArrayResult[1]); // Original unchanged",
          "explanation": "Comparison:\n1. **Shallow Copy (Objects & Arrays):**\n   - `Object.assign()`, spread syntax for objects; `slice()` for arrays.\n   - Copies top-level properties/elements by value, but nested objects/arrays by *reference*.\n   - Changes to nested properties in copy affect original.\n2. **Deep Copy (Objects & Arrays):**\n   - `JSON.parse(JSON.stringify())` (simple objects/arrays without functions/dates).\n   - Recursive `deepCopyArray` function (for arrays, can be extended for objects).\n   - Creates *completely independent* copies at all levels. Changes in copy don't affect original."
        }
      ]
    },
    {
      "id": "pq71",
      "title": "Difference between `let`, `const`, and `var`",
      "category": "JavaScript, Concepts",
      "difficulty": "Easy",
      "description": "Explain the key differences between `let`, `const`, and `var` keywords in JavaScript in terms of scope, hoisting, and re-declaration.",
      "methodology": {
        "approach": "Comparative Explanation Table",
        "explanation": "`var`, `let`, and `const` are used for variable declaration in JavaScript, but they differ significantly in scope, hoisting, and re-declaration behavior. `var` is function-scoped, hoisted and can be re-declared and re-assigned. `let` is block-scoped, hoisted but not initialized (Temporal Dead Zone), and can be re-assigned but not re-declared in the same scope. `const` is block-scoped, hoisted but not initialized (Temporal Dead Zone), and cannot be re-assigned or re-declared after initialization. Use `const` by default, then `let` if reassignment is needed, and avoid `var` in modern JavaScript.",
        "timeComplexity": "N/A - Conceptual question",
        "spaceComplexity": "N/A - Conceptual question"
      },
      "examples": [
        {
          "input": "Provide a table summarizing the differences and code examples illustrating scope, hoisting, and re-declaration for `var`, `let`, and `const`.",
          "output": "A table comparing the keywords and code snippets demonstrating each keyword's behavior in different scenarios.",
          "explanation": "Examples should clearly contrast how each keyword behaves with respect to scope, hoisting, and re-declaration, highlighting best practices for modern JavaScript."
        }
      ],
      "solutions": [
        {
          "approach": "Comparison Table and Code Examples",
          "code": "/* Comparison Table: */\n/*\n| Feature         | var                   | let                     | const                   |\n|-----------------|-----------------------|-------------------------|-------------------------|\n| Scope           | Function-scoped       | Block-scoped            | Block-scoped            |\n| Hoisting        | Yes (initialized: undefined) | Yes (not initialized - TDZ) | Yes (not initialized - TDZ) |\n| Re-declaration  | Yes                   | No (in same scope)      | No (in same scope)      |\n| Re-assignment   | Yes                   | Yes                     | No (after initialization)|\n*/\n\n/* Code Examples: */\n\n// 1. Scope\nfunction scopeExample() {\n  if (true) {\n    var varScoped = 'var';\n    let letScoped = 'let';\n    const constScoped = 'const';\n  }\n  console.log(varScoped); // Output: var (function-scoped)\n  // console.log(letScoped); // Error: letScoped is not defined (block-scoped)\n  // console.log(constScoped); // Error: constScoped is not defined (block-scoped)\n}\nscopeExample();\n\n// 2. Hoisting (Demonstrated in pq65 - Hoisting Question)\n\n// 3. Re-declaration\nvar varRedeclare = 'initial var';\nvar varRedeclare = 'redeclare var'; // No error\nconsole.log(varRedeclare); // Output: redeclare var\n\nlet letRedeclare = 'initial let';\n// let letRedeclare = 'redeclare let'; // Error: Identifier 'letRedeclare' has already been declared\n\nconst constRedeclare = 'initial const';\n// const constRedeclare = 'redeclare const'; // Error: Identifier 'constRedeclare' has already been declared\n\n// 4. Re-assignment\nvar varReassign = 'initial var';\nvarReassign = 'reassign var'; // No error\nconsole.log(varReassign); // Output: reassign var\n\nlet letReassign = 'initial let';\nletReassign = 'reassign let'; // No error\nconsole.log(letReassign); // Output: reassign let\n\nconst constReassign = 'initial const';\n// constReassign = 'reassign const'; // Error: Assignment to constant variable",
          "explanation": "Comparison table summarizes key differences. Code examples demonstrate:\n1. **Scope:** `var` function-scoped, `let`, `const` block-scoped.\n2. **Hoisting:** (Refer to pq65 example).\n3. **Re-declaration:** `var` allows, `let`, `const` don't in same scope.\n4. **Re-assignment:** `var`, `let` allow, `const` doesn't after initialization."
        }
      ]
    },
     {
      "id": "pq72",
      "title": "Implement Stack Data Structure in JavaScript",
      "category": "Data Structures, JavaScript",
      "difficulty": "Easy",
      "description": "Implement a Stack data structure in JavaScript using an array. Include `push`, `pop`, `peek`, `isEmpty`, and `size` methods.",
      "methodology": {
        "approach": "Array-Based Implementation",
        "explanation": "A Stack is a Last-In-First-Out (LIFO) data structure. We can implement a stack in JavaScript using an array. `push` adds an element to the top, `pop` removes and returns the top element, `peek` returns the top element without removing it, `isEmpty` checks if the stack is empty, and `size` returns the number of elements.",
        "timeComplexity": "O(1) for `push`, `pop`, `peek`, `isEmpty`, `size` - array operations are typically O(1) at the end of the array (for push/pop in this implementation).",
        "spaceComplexity": "O(n) to store n elements in the stack (array).",
        "javascriptSpecific": true
      },
      "examples": [
        {
          "input": "Perform stack operations: push elements, pop elements, peek, check isEmpty and size.",
          "output": "Demonstrate stack behavior with push, pop, peek, isEmpty, and size operations, showing LIFO principle.",
          "explanation": "Example should show typical stack operations and verify the LIFO behavior, emptiness check, and size tracking."
        }
      ],
      "solutions": [
        {
          "approach": "Array Implementation",
          "code": "class Stack {\n  constructor() {\n    this.items = []; // Using an array to store stack elements\n  }\n\n  push(element) {\n    this.items.push(element); // Add to the top\n  }\n\n  pop() {\n    if (this.isEmpty()) return 'Underflow'; // Handle empty stack\n    return this.items.pop(); // Remove and return top element\n  }\n\n  peek() {\n    if (this.isEmpty()) return 'Stack is empty'; // Handle empty stack\n    return this.items[this.items.length - 1]; // Return top element without removing\n  }\n\n  isEmpty() {\n    return this.items.length === 0; // Check if stack is empty\n  }\n\n  size() {\n    return this.items.length; // Return stack size\n  }\n\n  printStack() {\n    let str = '';\n    for (let i = 0; i < this.items.length; i++)\n      str += this.items[i] + ' '; \n    return str;\n  }\n}",
          "explanation": "Implementation:\n1. `items` array holds stack elements.\n2. `push(element)`: uses `Array.push()` to add to top.\n3. `pop()`: uses `Array.pop()` to remove and return top, handles underflow.\n4. `peek()`: returns last element of `items` (top), handles empty stack.\n5. `isEmpty()`: checks if `items.length === 0`.\n6. `size()`: returns `items.length`.\n7. `printStack()`: helper method to display stack content."
        }
      ]
    },
    {
      "id": "pq73",
      "title": "Implement Queue Data Structure in JavaScript",
      "category": "Data Structures, JavaScript",
      "difficulty": "Easy",
      "description": "Implement a Queue data structure in JavaScript using an array. Include `enqueue`, `dequeue`, `front`, `isEmpty`, and `size` methods.",
      "methodology": {
        "approach": "Array-Based Implementation",
        "explanation": "A Queue is a First-In-First-Out (FIFO) data structure. We can implement a queue in JavaScript using an array. `enqueue` adds an element to the back, `dequeue` removes and returns the front element, `front` returns the front element without removing it, `isEmpty` checks if the queue is empty, and `size` returns the number of elements.",
        "timeComplexity": "`enqueue` is O(1) using `push`. `dequeue` using `shift` is O(n) because of element shifting. `front`, `isEmpty`, `size` are O(1). For better dequeue performance, consider linked list or two-array based queue.",
        "spaceComplexity": "O(n) to store n elements in the queue (array).",
        "javascriptSpecific": true
      },
      "examples": [
        {
          "input": "Perform queue operations: enqueue elements, dequeue elements, front, check isEmpty and size.",
          "output": "Demonstrate queue behavior with enqueue, dequeue, front, isEmpty, and size operations, showing FIFO principle.",
          "explanation": "Example should show typical queue operations and verify the FIFO behavior, emptiness check, and size tracking."
        }
      ],
      "solutions": [
        {
          "approach": "Array Implementation",
          "code": "class Queue {\n  constructor() {\n    this.items = []; // Using an array to store queue elements\n  }\n\n  enqueue(element) {\n    this.items.push(element); // Add to the back\n  }\n\n  dequeue() {\n    if(this.isEmpty()) return 'Underflow'; // Handle empty queue\n    return this.items.shift(); // Remove and return front element (O(n) op)\n  }\n\n  front() {\n    if(this.isEmpty()) return 'No element in Queue'; // Handle empty queue\n    return this.items[0]; // Return front element without removing\n  }\n\n  isEmpty() {\n    return this.items.length == 0; // Check if queue is empty\n  }\n\n  size() {\n    return this.items.length; // Return queue size\n  }\n\n printQueue() {\n    let str = '';\n    for(let i = 0; i < this.items.length; i++)\n        str += this.items[i] + '  ';\n    return str;\n  }\n}",
          "explanation": "Implementation:\n1. `items` array holds queue elements.\n2. `enqueue(element)`: uses `Array.push()` to add to back.\n3. `dequeue()`: uses `Array.shift()` to remove and return front (note O(n) for shift), handles underflow.\n4. `front()`: returns first element of `items` (front), handles empty queue.\n5. `isEmpty()`: checks if `items.length == 0`.\n6. `size()`: returns `items.length`.\n7. `printQueue()`: helper method to display queue content."
        }
      ]
    },
     {
      "id": "pq74",
      "title": "Implement Promise-based Queue with Concurrency Control",
      "category": "JavaScript, Asynchronous, Concurrency",
      "difficulty": "Hard",
      "description": "Implement a `PromiseConcurrencyQueue` class in JavaScript that extends the basic PromiseQueue to add concurrency control. It should limit the number of promises that can be executed concurrently at any given time. New promises should only start execution when the number of running promises falls below the concurrency limit.",
      "methodology": {
        "approach": "Promise Chaining, Queue, and Semaphore-like Concurrency Control",
        "explanation": "To implement a promise queue with concurrency control, we need to limit the number of promises executing simultaneously. We can use a queue to store promises and a counter to track active promises. When a promise finishes, it signals to start the next promise if concurrency limit allows.\n\n1. Create a `PromiseConcurrencyQueue` class, constructor takes `concurrencyLimit`.\n2. Initialize a queue array for `taskQueue`, `activeCount` to 0.\n3. `enqueue(promiseFn)`: Add `promiseFn` to `taskQueue`, call `_dequeue` to start processing.\n4. `_dequeue()` (private method):\n   - While `taskQueue` is not empty AND `activeCount < concurrencyLimit`:\n     - Increment `activeCount`.\n     - Get `taskFn` from `taskQueue`.\n     - Execute `taskFn()` to get a promise.\n     - Use `.then()` for resolution:\n       - Decrement `activeCount`.\n       - Call `_dequeue` to check for next task.\n     - Use `.catch()` for rejection (similar decrement and `_dequeue`).\n\nThis approach uses a loop within `_dequeue` to start as many promises as allowed by `concurrencyLimit`, and promises self-trigger the next dequeue when they complete, maintaining concurrency limit.",
        "timeComplexity": "O(N), where N is the total number of promises enqueued. Each promise is processed once and enqueuing/dequeuing is efficient.",
        "spaceComplexity": "O(Q + C), where Q is max queue size, C is concurrency limit (for tracking active promises, though usually small constant).",
        "javascriptSpecific": true
      },
      "examples": [
        {
          "input": "const concurrentQueue = new PromiseConcurrencyQueue(2); concurrentQueue.enqueue(() => delayPromise(1000, 'Task 1')); concurrentQueue.enqueue(() => delayPromise(500, 'Task 2')); concurrentQueue.enqueue(() => delayPromise(700, 'Task 3'));",
          "output": "Tasks 'Task 1' and 'Task 2' start concurrently. 'Task 3' starts only after either 'Task 1' or 'Task 2' completes, ensuring concurrency limit of 2.",
          "explanation": "The queue should execute at most 2 promises concurrently. New promises should wait until a slot opens up within the concurrency limit."
        }
      ],
      "solutions": [
        {
          "approach": "Promise Chaining and Concurrency Counter",
          "code": "class PromiseConcurrencyQueue {\n  constructor(concurrencyLimit) {\n    this.concurrencyLimit = concurrencyLimit;\n    this.taskQueue = [];\n    this.activeCount = 0;\n  }\n\n  enqueue(promiseFn) {\n    this.taskQueue.push(promiseFn);\n    this._dequeue(); // Try to dequeue if possible\n  }\n\n  _dequeue() {\n    while (this.taskQueue.length > 0 && this.activeCount < this.concurrencyLimit) {\n      this.activeCount++;\n      const taskFn = this.taskQueue.shift();\n\n      taskFn()\n        .then(() => {\n          this.activeCount--;\n          this._dequeue(); // Try to dequeue next after completion\n        })\n        .catch(err => {\n          console.error('Task failed:', err);\n          this.activeCount--;\n          this._dequeue(); // Try to dequeue next even on failure\n        });\n    }\n  }\n}",
          "explanation": "Implementation:\n1. `concurrencyLimit`, `taskQueue`, `activeCount` initialized.\n2. `enqueue(promiseFn)`: Adds to `taskQueue`, calls `_dequeue`.\n3. `_dequeue()`: Loop while queue not empty AND below concurrency limit:\n   - Increment `activeCount`.\n   - Get `taskFn` from queue.\n   - Execute `taskFn()` (promise).\n   - `.then()` & `.catch()`: Decrement `activeCount`, call `_dequeue` again to process next."
        }
      ]
    },
     {
      "id": "pq75",
      "title": "Implement a Simple Caching Mechanism in JavaScript",
      "category": "JavaScript, Optimization",
      "difficulty": "Easy",
      "description": "Implement a simple caching mechanism in JavaScript using a plain object as a cache store. The cache should have `get(key)` and `set(key, value)` methods. `get(key)` should return the cached value if it exists, otherwise `undefined`. `set(key, value)` should store the value in the cache under the given key.",
      "methodology": {
        "approach": "Object-Based Cache Store",
        "explanation": "A simple caching mechanism can be implemented using a JavaScript object as a key-value store. The object will act as our cache, where keys are strings and values are the cached data. `get(key)` will retrieve values from the object, and `set(key, value)` will store values in it.",
        "timeComplexity": "O(1) for `get` and `set` operations on average, due to object property access being typically O(1) on average in hash-based object implementations.",
        "spaceComplexity": "O(M), where M is the number of items stored in the cache. Space is used to store the cache object and its entries.",
        "javascriptSpecific": true
      },
      "examples": [
        {
          "input": "Use the cache to store and retrieve simple key-value pairs.",
          "output": "Demonstrate storing and retrieving values from the cache using `set` and `get` methods, showing cache hits and misses.",
          "explanation": "Example should show how `set` stores data and `get` retrieves it when available, and returns undefined when not cached."
        }
      ],
      "solutions": [
        {
          "approach": "Object as Cache Store",
          "code": "class SimpleCache {\n  constructor() {\n    this.cacheStore = {}; // Plain object as cache store\n  }\n\n  get(key) {\n    return this.cacheStore[key]; // Direct object property access for retrieval\n  }\n\n  set(key, value) {\n    this.cacheStore[key] = value; // Direct object property assignment for storage\n  }\n}",
          "explanation": "Implementation:\n1. `cacheStore` object initialized in constructor.\n2. `get(key)`: Returns `this.cacheStore[key]`, which is `value` if key exists, `undefined` if not.\n3. `set(key, value)`: Sets `this.cacheStore[key] = value`, storing the value in the cache."
        }
      ]
    },
    {
      "id": "pq76",
      "title": "Implement LRU Cache with Time Expiration",
      "category": "Design, JavaScript",
      "difficulty": "Hard",
      "description": "Extend the LRU Cache implementation (pq41) to add time-based expiration for cached items. Each item should have a Time-To-Live (TTL). If an item is accessed after its TTL, it should be considered expired and evicted from the cache.",
      "methodology": {
        "approach": "LRU Cache with Timestamp-Based Expiration",
        "explanation": "To add time expiration to LRU cache, we need to store a timestamp with each cached item, indicating its creation or last access time. When getting an item, we check if it's expired based on its TTL and current time. Expired items are treated as not found and should be evicted.\n\n1. Extend the `LRUCache` class from pq41 or reimplement with expiration.\n2. In the `CacheNode`, add a property `expiryTime` to store the timestamp when the item expires (creation time + TTL).\n3. In `put(key, value, ttl)` method:\n   - When creating a new node, calculate `expiryTime = Date.now() + ttl` and store it in the node.\n   - In existing `put` logic (update value), also update `expiryTime` if TTL is provided, or keep the original expiry if TTL is not updated.\n4. In `get(key)` method:\n   - Before returning the cached value, check if the current `Date.now()` is greater than the node's `expiryTime`.\n   - If expired, remove the node from the cache (both hash map and linked list), and return -1 (cache miss).\n   - If not expired, proceed with LRU update (move to head) and return the value as in the base LRU cache.",
        "timeComplexity": "O(1) for `get` and `put` operations, similar to base LRU cache, with added time check which is also O(1).",
        "spaceComplexity": "O(capacity), same as base LRU cache, with a small overhead for storing `expiryTime` in each node.",
        "javascriptSpecific": true
      },
      "examples": [
        {
          "input": "LRUCacheWithTTL cache = new LRUCacheWithTTL(2); cache.put(1, 1, 1000); // TTL 1 second cache.get(1);       // returns 1 Wait for > 1 second. cache.get(1);       // returns -1 (expired)",
          "output": "Behavior as described, showing LRU eviction and time-based expiration.",
          "explanation": "Example should demonstrate that items expire and are evicted from the cache after their TTL, in addition to LRU eviction."
        }
      ],
      "solutions": [
        {
          "approach": "LRU Cache with Expiry Timestamp",
          "code": "class LRUCacheWithTTL {\n    constructor(capacity) {\n        this.capacity = capacity;\n        this.cache = new Map();\n        this.head = null;\n        this.tail = null;\n        this.size = 0;\n    }\n\n    get(key) {\n        if (!this.cache.has(key)) return -1;\n        const node = this.cache.get(key);\n        if (Date.now() > node.expiryTime) { // Check for expiry\n            this.evictNode(node); // Evict expired node\n            return -1; // Cache miss due to expiry\n        }\n        this.moveToHead(node);\n        return node.value;\n    }\n\n    put(key, value, ttlMs) {\n        if (this.cache.has(key)) {\n            const node = this.cache.get(key);\n            node.value = value;\n            node.expiryTime = Date.now() + ttlMs; // Update expiry time\n            this.moveToHead(node);\n        } else {\n            const newNode = {\n                key,\n                value,\n                expiryTime: Date.now() + ttlMs, // Set expiry time\n                prev: null,\n                next: null\n            };\n            this.cache.set(key, newNode);\n            this.addToHead(newNode);\n            this.size++;\n            if (this.size > this.capacity) {\n                this.evictTail();\n            }\n        }\n    }\n\n    moveToHead(node) { /* ... (same as in pq41 LRU Cache) ... */ }\n    addToHead(node) { /* ... (same as in pq41 LRU Cache) ... */ }\n    evictTail() {     /* ... (same as in pq41 LRU Cache) ... */ }\n\n    evictNode(node) { // Evict specific node (e.g., on expiry)\n        if (node === this.head && node === this.tail) {\n            this.head = this.tail = null; // Single node case\n        } else if (node === this.head) {\n            this.head = this.head.next;\n            this.head.prev = null;\n        } else if (node === this.tail) {\n            this.tail = this.tail.prev;\n            this.tail.next = null;\n        } else {\n            node.prev.next = node.next;\n            node.next.prev = node.prev;\n        }\n        this.cache.delete(node.key);\n        this.size--;\n    }\n}",
          "explanation": "Extended LRUCache with TTL:\n- `CacheNode` now includes `expiryTime`.\n- `put(key, value, ttlMs)`: Calculates and sets `expiryTime`.\n- `get(key)`: Checks for expiry using `Date.now() > node.expiryTime` before returning value. If expired, evicts node using `evictNode`.\n- `evictNode(node)`: Added method to evict any given node (used for expiry eviction and could be used in `evictTail` for LRU eviction if refactored)."
        }
      ]
    },
    {
      "id": "pq77",
      "title": "Memoization with Arguments in JavaScript",
      "category": "JavaScript, Optimization",
      "difficulty": "Medium",
      "description": "Extend the simple memoization function (pq48) to handle functions with multiple arguments and ensure that the cache key is correctly generated based on all arguments passed to the function.",
      "methodology": {
        "approach": "Argument-Based Cache Keys",
        "explanation": "To memoize functions with multiple arguments, we need to create a cache key that uniquely represents the set of arguments. `JSON.stringify` can be used for simple argument types. For more complex arguments or to handle function/object identity, a more robust key generation might be needed.\n\n1. Extend the `memoize(func)` function from pq48.\n2. In the memoized function, generate a cache key based on all arguments passed.\n   - Use `JSON.stringify(arguments)` to convert arguments object to a string key for simple argument types (numbers, strings, booleans, simple objects/arrays).\n   - For functions, symbols, or objects with circular references, `JSON.stringify` may not work or produce desired keys. Consider custom key generation for those cases (not covered in basic example).\n3. Use the generated key to check the cache and store/retrieve results as in the base memoization implementation.",
        "timeComplexity": "O(1) for memoized calls (cache hit). O(T + K) for cache miss, where T is original function time, K is time to generate cache key (JSON.stringify can be O(L) where L is length of stringified args).",
        "spaceComplexity": "O(M), where M is number of unique argument sets, for storing cache.",
        "javascriptSpecific": true
      },
      "examples": [
        {
          "input": "Memoize a function that takes multiple arguments, ensuring cache works correctly for different combinations of arguments.",
          "output": "Demonstrate memoization working for a function with multiple inputs, showing that different argument sets are cached separately.",
          "explanation": "Example should show that cache correctly distinguishes between different argument combinations and reuses cached results only for identical argument sets."
        }
      ],
      "solutions": [
        {
          "approach": "JSON.stringify for Cache Key Generation",
          "code": "function memoizeMultiArgs(func) {\n  const cache = {};\n  return function memoizedFunction(...args) {\n    const key = JSON.stringify(args); // Generate key from all arguments\n    if (cache[key]) {\n      console.log('Cache hit for key:', key);\n      return cache[key]; // Return cached result\n    } else {\n      console.log('Cache miss for key:', key);\n      const result = func.apply(this, args);\n      cache[key] = result; // Store result in cache\n      return result;\n    }\n  };\n}\n\n// Example usage:\nconst add = (a, b, c) => {\n  console.log('Calculating sum:', a, b, c);\n  return a + b + c;\n};\n\nconst memoizedAdd = memoizeMultiArgs(add);\n\nconsole.log(memoizedAdd(1, 2, 3)); // Calculates, logs 'Calculating sum', Cache miss\nconsole.log(memoizedAdd(1, 2, 3)); // Returns cached result, Cache hit\nconsole.log(memoizedAdd(3, 2, 1)); // Calculates (different args), Cache miss\nconsole.log(memoizedAdd(3, 2, 1)); // Returns cached result, Cache hit\nconsole.log(memoizedAdd(1, 2, 3)); // Returns cached result, Cache hit (original args again)",
          "explanation": "Implementation:\n- `memoizeMultiArgs(func)`: Memoization function.\n- `cache = {}`: Cache store.\n- `key = JSON.stringify(args)`: Generates cache key from all arguments using `JSON.stringify`.\n- Cache lookup and storage logic same as basic memoization (pq48), but using the argument-based key.\n- Example usage with `add(a, b, c)` function demonstrates caching for different argument combinations."
        }
      ]
    },
    {
      "id": "pq78",
      "title": "Implement a Simple Promise Throttler",
      "category": "JavaScript, Asynchronous, Concurrency",
      "difficulty": "Hard",
      "description": "Implement a `PromiseThrottler` class in JavaScript that ensures that promises are executed no more than a specified number of times within a given time window. It should queue up promises and execute them respecting the throttle limit.",
      "methodology": {
        "approach": "Queue, Timers, and Throttling Logic",
        "explanation": "To implement a promise throttler, we need to queue promises and control their execution rate within a time window. We can use a queue, a timer, and track the number of requests made in the current window. When a request comes in, we check if we are within the throttle limit and time window. If yes, execute immediately; otherwise, queue it and execute later when the window resets or limit allows.\n\n1. Create a `PromiseThrottler` class, constructor takes `maxRequestsPerWindow` and `windowDurationMs`.\n2. Initialize a `taskQueue` array, `requestsInWindow` counter, and `throttleWindowStartTime`.\n3. `throttle(promiseFn)` method:\n   - Check if `requestsInWindow < maxRequestsPerWindow` and if current time is within `throttleWindowStartTime + windowDurationMs`.\n   - If within limit and window:\n     - Increment `requestsInWindow`.\n     - Execute `promiseFn()` immediately.\n     - Use `.finally()` to decrement `requestsInWindow` after promise settles.\n     - Return the promise from `promiseFn()`.\n   - If limit or window exceeded:\n     - Queue `promiseFn` in `taskQueue`.\n     - Return a new promise that resolves when `promiseFn` is eventually executed (needs queue management and deferred resolution). Need to manage queue processing and window reset.\n4. Implement window reset logic: when current time exceeds `throttleWindowStartTime + windowDurationMs`, reset `requestsInWindow = 0` and `throttleWindowStartTime = now`.",
        "timeComplexity": "O(N), where N is the total number of throttled calls. Each promise is eventually executed. Throttling logic itself is O(1) per call.",
        "spaceComplexity": "O(Q), where Q is the max size of `taskQueue` - if requests come in faster than they are allowed by the throttle, they queue up.",
        "javascriptSpecific": true
      },
      "examples": [
        {
          "input": "const throttler = new PromiseThrottler(2, 1000); // Max 2 requests per second. Call throttler.throttle(() => fetch(...)) multiple times quickly.",
          "output": "Fetch requests are made at a throttled rate, no more than 2 per second, even if throttler.throttle() is called more frequently.",
          "explanation": "The throttler should limit the rate of promise executions, ensuring no more than the specified number of requests within the time window, queuing up excess requests."
        }
      ],
      "solutions": [
        {
          "approach": "Queue and Time Window-Based Throttling",
          "code": "class PromiseThrottler {\n  constructor(maxRequestsPerWindow, windowDurationMs) {\n    this.maxRequestsPerWindow = maxRequestsPerWindow;\n    this.windowDurationMs = windowDurationMs;\n    this.taskQueue = [];\n    this.requestsInWindow = 0;\n    this.throttleWindowStartTime = Date.now();\n  }\n\n  throttle(promiseFn) {\n    return new Promise((resolve, reject) => {\n      const requestTime = Date.now();\n      if (requestTime > this.throttleWindowStartTime + this.windowDurationMs) { // Window expired, reset\n        this.requestsInWindow = 0;\n        this.throttleWindowStartTime = requestTime;\n      }\n\n      if (this.requestsInWindow < this.maxRequestsPerWindow) { // Within limit\n        this.requestsInWindow++;\n        promiseFn()\n          .then(resolve)\n          .catch(reject)\n          .finally(() => {\n            this.requestsInWindow--; // Decrement after completion\n            this._dequeue();         // Check queue for next\n          });\n      } else { // Rate limited, queue task\n        this.taskQueue.push({ promiseFn, resolve, reject });\n      }\n    });\n  }\n\n  _dequeue() {\n    if (this.taskQueue.length === 0) return;\n    const nextTask = this.taskQueue.shift();\n    this.throttle(nextTask.promiseFn)\n      .then(nextTask.resolve)\n      .catch(nextTask.reject);\n  }\n}",
          "explanation": "Implementation:\n- `maxRequestsPerWindow`, `windowDurationMs`, `taskQueue`, `requestsInWindow`, `throttleWindowStartTime` initialized.\n- `throttle(promiseFn)`: Main method to throttle promise execution.\n  - Checks if within rate limit and time window.\n  - If allowed, executes `promiseFn`, increments `requestsInWindow`, uses `.finally` to decrement count and call `_dequeue`.\n  - If rate-limited, queues task.\n- `_dequeue()`: Processes task queue, called after promise completion to check for queued tasks."
        }
      ]
    },
    {
      "id": "pq79",
      "title": "Implement a Simple Promise Scheduler with Delay",
      "category": "JavaScript, Asynchronous",
      "difficulty": "Hard",
      "description": "Implement a `PromiseDelayScheduler` class in JavaScript that allows you to add promise-returning functions to a queue and execute them sequentially with a fixed delay between each promise execution.",
      "methodology": {
        "approach": "Promise Queue and Fixed Delay using `setTimeout`",
        "explanation": "To implement a promise scheduler with delay, we need to execute promises sequentially from a queue, introducing a fixed delay between the completion of one promise and the start of the next. We can use a queue and `setTimeout` to achieve this.\n\n1. Create a `PromiseDelayScheduler` class.\n2. Initialize a `taskQueue` array and `isProcessing` flag in the constructor.\n3. Implement `enqueue(promiseFn)` method: add `promiseFn` to `taskQueue`, call `_dequeue` if not already processing.\n4. Implement `_dequeue()` method (private):\n   - If `taskQueue` is empty or `isProcessing` is true, return.\n   - Set `isProcessing = true`.\n   - Get `promiseFn` from `taskQueue`.\n   - Execute `promiseFn()`.\n   - Use `.then()` for resolution:\n     - After resolution, use `setTimeout` to introduce a delay.\n     - After delay, set `isProcessing = false` and recursively call `_dequeue` to process next task.\n   - Use `.catch()` for rejection (handle error, then proceed with delay and next task).",
        "timeComplexity": "O(N * D), where N is number of tasks, D is delay duration. Total time depends on sum of task execution times + total delay time.",
        "spaceComplexity": "O(Q), where Q is max queue size, for storing queued tasks.",
        "javascriptSpecific": true
      },
      "examples": [
        {
          "input": "const delayScheduler = new PromiseDelayScheduler(500); // 500ms delay between tasks. delayScheduler.enqueue(() => delayPromise(200, 'Task A')); delayScheduler.enqueue(() => delayPromise(300, 'Task B'));",
          "output": "Tasks 'Task A' and 'Task B' are executed sequentially with approximately 500ms delay between the completion of 'Task A' and the start of 'Task B'. Total execution time will include task times + delays.",
          "explanation": "The scheduler should execute tasks one after another, with a noticeable delay inserted between each task's completion and the next task's start."
        }
      ],
      "solutions": [
        {
          "approach": "Promise Queue with setTimeout Delay",
          "code": "class PromiseDelayScheduler {\n  constructor(delayMs) {\n    this.delayMs = delayMs;\n    this.taskQueue = [];\n    this.isProcessing = false;\n  }\n\n  enqueue(promiseFn) {\n    this.taskQueue.push(promiseFn);\n    if (!this.isProcessing) {\n      this._dequeue();\n    }\n  }\n\n  _dequeue() {\n    if (this.taskQueue.length === 0 || this.isProcessing) {\n      return;\n    }\n\n    this.isProcessing = true;\n    const taskFn = this.taskQueue.shift();\n\n    taskFn()\n      .then(() => {\n        setTimeout(() => { // Introduce delay\n          this.isProcessing = false;\n          this._dequeue(); // Process next task after delay\n        }, this.delayMs);\n      })\n      .catch(err => {\n        console.error('Task failed:', err);\n        setTimeout(() => { // Delay even after failure\n          this.isProcessing = false;\n          this._dequeue(); // Continue to next task\n        }, this.delayMs);\n      });\n  }\n}",
          "explanation": "Implementation:\n- `delayMs`, `taskQueue`, `isProcessing` initialized.\n- `enqueue(promiseFn)`: Adds task, calls `_dequeue`.\n- `_dequeue()`: Checks queue and `isProcessing`.\n  - Gets `taskFn` from queue.\n  - Executes `taskFn()`.\n  - `.then()`: On resolution, uses `setTimeout` for delay, then resets `isProcessing` and calls `_dequeue` again.\n  - `.catch()`: Handles error, still applies delay before next task."
        }
      ]
    },
    {
      "id": "pq80",
      "title": "Implement a Simple Promise Cancellation",
      "category": "JavaScript, Asynchronous",
      "difficulty": "Hard",
      "description": "Implement a mechanism to cancel a running Promise in JavaScript. Create a function `cancellablePromise(promiseFn)` that takes a promise-returning function and returns an object with a `promise` and a `cancel` method. Calling `cancel()` should prevent the promise from resolving or rejecting and trigger a cancellation callback.",
      "methodology": {
        "approach": "Promise Wrapping and Cancellation Flag",
        "explanation": "Native Promises in JavaScript are not directly cancellable. To implement cancellation, we need to wrap the original promise and introduce a cancellation mechanism using a flag and a new Promise that controls the original promise's fate.\n\n1. Create a function `cancellablePromise(promiseFn)` that takes a promise-returning function `promiseFn`.\n2. Inside `cancellablePromise`, create a `cancelled` flag initialized to `false`.\n3. Return an object with two properties: `promise` and `cancel`.\n4. The `promise` property should be a new Promise that wraps the execution of `promiseFn`.\n5. In the executor of the new Promise:\n   - Call `promiseFn()` to get the original promise.\n   - Use `.then()` and `.catch()` on the original promise.\n   - Before resolving or rejecting in `.then()` or `.catch()`, check the `cancelled` flag.\n   - If `cancelled` is true, do not resolve or reject; instead, potentially resolve with a cancellation indicator or simply do nothing (effectively cancelling).\n   - If `cancelled` is false, proceed with resolving or rejecting the new promise based on the original promise's outcome.\n6. The `cancel` method should set the `cancelled` flag to `true`.",
        "timeComplexity": "O(1) for `cancel()` itself. The wrapped promise's time complexity depends on `promiseFn`.",
        "spaceComplexity": "O(1) - constant space for the closure and cancellation flag.",
        "javascriptSpecific": true
      },
      "examples": [
        {
          "input": "const { promise, cancel } = cancellablePromise(() => delayPromise(2000, 'Long Task')); setTimeout(cancel, 1000);",
          "output": "The 'Long Task' promise is cancelled after 1 second, and it should not resolve or reject after cancellation is called.",
          "explanation": "The `cancellablePromise` should provide a way to prevent the original promise from completing its normal resolution or rejection flow after `cancel()` is invoked."
        }
      ],
      "solutions": [
        {
          "approach": "Promise Wrapper and Cancellation Flag",
          "code": "function cancellablePromise(promiseFn) {\n  let cancelled = false;\n\n  const wrappedPromise = new Promise((resolve, reject) => {\n    const originalPromise = promiseFn();\n\n    originalPromise\n      .then(value => {\n        if (!cancelled) {\n          resolve(value); // Resolve only if not cancelled\n        }\n      })\n      .catch(reason => {\n        if (!cancelled) {\n          reject(reason); // Reject only if not cancelled\n        }\n      });\n  });\n\n  return {\n    promise: wrappedPromise,\n    cancel: () => {\n      cancelled = true; // Set cancellation flag\n    }\n  };\n}",
          "explanation": "Implementation:\n- `cancellablePromise(promiseFn)`: Wraps promise for cancellation.\n- `cancelled` flag in closure.\n- `wrappedPromise`: New promise returned.\n  - Executes `promiseFn()` to get `originalPromise`.\n  - `.then()` & `.catch()`: Check `cancelled` flag before resolving/rejecting.\n- `cancel()`: Sets `cancelled = true` to prevent resolution/rejection in wrapped promise."
        }
      ]
    },
    {
      "id": "pq81",
      "title": "Implement a Simple Retry Decorator for Functions",
      "category": "JavaScript, Decorators, Error Handling",
      "difficulty": "Medium",
      "description": "Implement a higher-order function `retryDecorator(fn, maxRetries)` in JavaScript that takes a function `fn` and a maximum number of `maxRetries`. It should return a new function that, when called, executes `fn`. If `fn` throws an error, the decorated function should retry calling `fn` up to `maxRetries` times before finally throwing the last error.",
      "methodology": {
        "approach": "Higher-Order Function and Error Handling",
        "explanation": "A retry decorator enhances a function by adding retry logic in case of errors. We can use a higher-order function to wrap the original function and implement the retry mechanism.\n\n1. Create a function `retryDecorator(fn, maxRetries)` that takes the function `fn` to decorate and `maxRetries` as arguments.\n2. Return a new function (the decorated function).\n3. Inside the decorated function:\n   - Implement a loop that iterates up to `maxRetries` times (or `maxRetries + 1` for initial attempt + retries).\n   - In each iteration, use a `try...catch` block to execute `fn()`.\n   - If `fn()` executes successfully (no error thrown), return the result immediately (no further retries needed).\n   - If `fn()` throws an error in the `try` block, catch the error in the `catch` block.\n   - After the loop completes (all retries failed), throw the last caught error to propagate the failure.",
        "timeComplexity": "O(R * T), where R is `maxRetries` and T is the time complexity of `fn`. In the worst case, `fn` is called up to `maxRetries + 1` times.",
        "spaceComplexity": "O(1) - constant space for the decorator itself. Space for recursive calls (if recursion used, though iterative approach is shown) depends on `fn`.",
        "javascriptSpecific": true
      },
      "examples": [
        {
          "input": "const flakyFunction = () => { ... // Function that sometimes throws error }; const retryableFunction = retryDecorator(flakyFunction, 3); retryableFunction();",
          "output": "The `retryableFunction` should attempt to execute `flakyFunction` up to 4 times (initial attempt + 3 retries) if it throws errors, before giving up and throwing the last error.",
          "explanation": "The decorator should add retry behavior to any function it wraps, automatically retrying on errors up to the specified retry limit."
        }
      ],
      "solutions": [
        {
          "approach": "Higher-Order Function with Iterative Retry Logic",
          "code": "function retryDecorator(fn, maxRetries) {\n  return function decoratedFunction(...args) {\n    let lastError;\n    for (let attempt = 0; attempt <= maxRetries; attempt++) {\n      try {\n        return fn.apply(this, args); // Try executing the function\n      } catch (error) {\n        lastError = error; // Store the error\n        console.log(`Attempt ${attempt + 1} failed, retrying...`);\n      }\n    }\n    throw lastError; // Throw the last error if all retries failed\n  };\n}",
          "explanation": "Implementation:\n- `retryDecorator(fn, maxRetries)`: Decorator function.\n- Returns `decoratedFunction(...args)`: The decorated version of `fn`.\n- `for` loop: Iterates up to `maxRetries + 1` times.\n- `try...catch`: Executes `fn()` in `try`.\n  - `return fn.apply(this, args)`: If success, return result immediately.\n  - `catch (error)`: If error, store `lastError`, log retry attempt.\n- `throw lastError`: After loop (all retries failed), throw the stored `lastError`."
        }
      ]
    },
    {
      "id": "pq82",
      "title": "Implement a Simple Promise Semaphore",
      "category": "JavaScript, Asynchronous, Concurrency",
      "difficulty": "Hard",
      "description": "Implement a `PromiseSemaphore` class in JavaScript. A semaphore is used to control access to a shared resource by multiple promises, limiting the number of concurrent promises that can access the resource at any time. Implement `acquire()` to request access (returns a Promise) and `release()` to signal completion of access.",
      "methodology": {
        "approach": "Promise-Based Queue and Concurrency Control",
        "explanation": "A Promise Semaphore manages concurrent access to a resource. `acquire()` requests access and returns a Promise that resolves when access is granted (semaphore slot available). `release()` signals that a process has finished using the resource, freeing up a semaphore slot for others.\n\n1. Create a `PromiseSemaphore` class, constructor takes `permits` (max concurrent access slots).\n2. Initialize `permitsAvailable` to `permits`, `waitingQueue` array for waiting promises.\n3. `acquire()` method:\n   - If `permitsAvailable > 0`:\n     - Decrement `permitsAvailable`.\n     - Return `Promise.resolve()` (access granted immediately).\n   - If `permitsAvailable <= 0`:\n     - Create a new Promise that will resolve later when a permit is released.\n     - Enqueue this promise's `resolve` function into `waitingQueue`.\n     - Return the new promise (access pending).\n4. `release()` method:\n   - Increment `permitsAvailable`.\n   - If `waitingQueue` is not empty:\n     - Dequeue a `resolve` function from `waitingQueue`.\n     - Call the dequeued `resolve` function to grant access to a waiting promise.",
        "timeComplexity": "O(1) for `acquire()` and `release()` operations on average, assuming queue operations are O(1).",
        "spaceComplexity": "O(W), where W is the maximum number of promises waiting in the queue, in the worst case when all permits are in use and many promises are waiting to acquire the semaphore.",
        "javascriptSpecific": true
      },
      "examples": [
        {
          "input": "const semaphore = new PromiseSemaphore(2); // Allow 2 concurrent promises. Use semaphore.acquire() before async task and semaphore.release() after.",
          "output": "Promises acquire semaphore permits sequentially, ensuring no more than 2 execute concurrently at any time. Promises waiting for permit are queued and get access when permits are released.",
          "explanation": "The semaphore should control concurrency, allowing a limited number of promises to proceed concurrently while others wait in a queue until a permit becomes available."
        }
      ],
      "solutions": [
        {
          "approach": "Promise Queue for Waiting and Permit Counter",
          "code": "class PromiseSemaphore {\n  constructor(permits) {\n    this.permitsAvailable = permits;\n    this.waitingQueue = []; // Queue of resolve functions for waiting promises\n  }\n\n  acquire() {\n    if (this.permitsAvailable > 0) {\n      this.permitsAvailable--;\n      return Promise.resolve(); // Permit available, resolve immediately\n    } else {\n      return new Promise(resolve => {\n        this.waitingQueue.push(resolve); // Enqueue resolve for later\n      });\n    }\n  }\n\n  release() {\n    this.permitsAvailable++;\n    if (this.waitingQueue.length > 0) {\n      const nextResolve = this.waitingQueue.shift();\n      nextResolve(); // Resolve the next waiting promise, granting permit\n    }\n  }\n}",
          "explanation": "Implementation:\n- `permitsAvailable`, `waitingQueue` initialized.\n- `acquire()`:\n  - If `permitsAvailable > 0`, decrement, return resolved Promise (permit granted).\n  - Else, create new Promise, enqueue its `resolve` function to `waitingQueue`, return pending Promise.\n- `release()`:\n  - Increment `permitsAvailable`.\n  - If `waitingQueue` not empty, dequeue `resolve` function and call it to resolve a waiting promise."
        }
      ]
    },
    {
      "id": "pq83",
      "title": "Implement a Function to Flatten an Object",
      "category": "JavaScript, Objects, Recursion",
      "difficulty": "Medium",
      "description": "Write a JavaScript function `flattenObject(obj)` that flattens a nested JavaScript object into a single-level object. The keys of the flattened object should be the path to the leaf values in the original object, joined by dots ('.').",
      "methodology": {
        "approach": "Recursion and Object Traversal",
        "explanation": "Flattening an object involves recursively traversing its properties. For each nested object, we recursively flatten it and prepend the current key to the flattened keys. Leaf values are directly added to the flattened object with their path as the key.\n\n1. Create a function `flattenObject(obj, prefix = '', result = {})` that takes the object `obj`, an optional `prefix` string (initially empty), and a `result` object (to accumulate flattened key-value pairs).\n2. Iterate through the keys of the input `obj`.\n3. For each key:\n   - Construct the current path by appending the key to the `prefix` (e.g., `prefix ? prefix + '.' + key : key`).\n   - If the value is an object and not null:\n     - Recursively call `flattenObject` with the value, current path, and `result` object.\n   - If the value is not an object (primitive value):\n     - Add the key-value pair to the `result` object, where the key is the current path and the value is the primitive value.\n4. Return the `result` object.",
        "timeComplexity": "O(N), where N is the total number of properties (including nested ones) in the object, as we visit each property once.",
        "spaceComplexity": "O(D), where D is the maximum depth of nesting in the object, due to recursive call stack. In the worst case (deeply nested object), it could approach O(N). Also, O(M) to store the flattened object where M is the number of leaf nodes.",
        "javascriptSpecific": true
      },
      "examples": [
        {
          "input": "obj = { a: 1, b: { c: 2, d: { e: 3 } }, f: 4 }",
          "output": "{ 'a': 1, 'b.c': 2, 'b.d.e': 3, 'f': 4 }",
          "explanation": "The nested object is flattened, and keys represent paths to the values."
        }
      ],
      "solutions": [
        {
          "approach": "Recursive Object Traversal",
          "code": "function flattenObject(obj, prefix = '', result = {}) {\n  for (const key in obj) {\n    if (obj.hasOwnProperty(key)) { // Ensure own properties\n      const currentPath = prefix ? prefix + '.' + key : key;\n      if (typeof obj[key] === 'object' && obj[key] !== null) {\n        flattenObject(obj[key], currentPath, result); // Recursive call for nested objects\n      } else {\n        result[currentPath] = obj[key]; // Add leaf value to result\n      }\n    }\n  }\n  return result;\n}",
          "explanation": "Implementation:\n- `flattenObject(obj, prefix, result)`: Recursive function.\n- Iterates through `obj` keys using `for...in`.\n- `hasOwnProperty(key)`: Copies own properties only.\n- `currentPath`: Constructs dot-separated path for key.\n- `if (typeof obj[key] === 'object' && obj[key] !== null)`: If value is nested object, recursive call.\n- `else`: If leaf value, `result[currentPath] = obj[key]` adds to flattened object.\n- Returns `result` (flattened object)."
        }
      ]
    },
    {
      "id": "pq84",
      "title": "Implement Object.entries Polyfill",
      "category": "JavaScript, Objects",
      "difficulty": "Easy",
      "description": "Implement a polyfill for `Object.entries` method in JavaScript. It should return an array of a given object's own enumerable string-keyed property `[key, value]` pairs, in the same order as is provided by a `for...in` loop.",
      "methodology": {
        "approach": "Iteration and Array Creation",
        "explanation": "`Object.entries` returns an array of [key, value] pairs for an object's own enumerable string properties. We can polyfill this by iterating through the object using `for...in` and `hasOwnProperty` to get own properties, then construct and return the array of pairs.\n\n1. Implement a function `objectEntriesPolyfill(obj)` that takes an object `obj`.\n2. Initialize an empty array `entriesArray` to store [key, value] pairs.\n3. Iterate through the object's properties using a `for...in` loop.\n4. For each key, check if it's an own property using `Object.prototype.hasOwnProperty.call(obj, key)`.\n5. If it's an own property, create a [key, value] pair array `[key, obj[key]]` and push it to `entriesArray`.\n6. Return `entriesArray`.",
        "timeComplexity": "O(n), where n is the number of own enumerable properties in the object, as we iterate through them once.",
        "spaceComplexity": "O(n) to store the `entriesArray` which contains n key-value pairs.",
        "javascriptSpecific": true
      },
      "examples": [
        {
          "input": "obj = { one: 1, two: 2, three: 3 }",
          "output": "[['one', 1], ['two', 2], ['three', 3]]",
          "explanation": "`objectEntriesPolyfill` should return an array of key-value pairs as arrays, mirroring `Object.entries` behavior."
        }
      ],
      "solutions": [
        {
          "approach": "Iteration and Array Construction",
          "code": "function objectEntriesPolyfill(obj) {\n  if (typeof obj !== 'object' && typeof obj !== 'function' || obj === null) {\n    throw new TypeError('Object.entries called on non-object');\n  }\n\n  const entriesArray = [];\n  for (const key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      entriesArray.push([key, obj[key]]); // Create and push [key, value] pair\n    }\n  }\n  return entriesArray;\n}",
          "explanation": "Implementation:\n- `objectEntriesPolyfill(obj)` function.\n- Type check: `obj` must be object or function, not null.\n- `entriesArray`: Initialize empty array.\n- `for...in` loop: Iterate through object properties.\n- `Object.prototype.hasOwnProperty.call(obj, key)`: Check for own property.\n- `entriesArray.push([key, obj[key]])`: Create [key, value] pair array and push to `entriesArray`.\n- Return `entriesArray`."
        }
      ]
    },
    {
      "id": "pq85",
      "title": "Implement a Simple Rate Limiter using Sliding Window Log",
      "category": "Design, JavaScript",
      "difficulty": "Hard",
      "description": "Design and implement a rate limiter using the Sliding Window Log algorithm. Implement a `shouldAllowRequest(clientId)` function. This rate limiter should allow a maximum number of requests within a sliding time window. For example, allow 5 requests per minute, sliding window.",
      "methodology": {
        "approach": "Sliding Window Log Algorithm",
        "explanation": "The Sliding Window Log algorithm rate limiter keeps a log of timestamps for each request within a time window. To check if a new request should be allowed, it removes outdated timestamps from the log and checks the log size against the request limit.\n\n1. Create a `SlidingWindowLogRateLimiter` class, constructor takes `maxRequestsPerWindow` and `windowDurationMs`.\n2. Initialize a `requestLogs` Map to store request timestamps (as arrays) for each `clientId`.\n3. `shouldAllowRequest(clientId)` method:\n   - Get current timestamp `now = Date.now()`.\n   - Get the request log for `clientId` from `requestLogs`. If none exists, create an empty array.\n   - Remove outdated timestamps from the beginning of the log array. Outdated timestamps are those older than `now - windowDurationMs`.\n   - If the current log size is less than `maxRequestsPerWindow`, add the `now` timestamp to the end of the log array, update `requestLogs` with the new log, and return `true` (allow request).\n   - If the log size is not less than `maxRequestsPerWindow`, return `false` (rate limit exceeded).\n\nThis algorithm provides a more accurate rate limiting over time compared to fixed window, as the window slides with each request.",
        "timeComplexity": "O(L) for `shouldAllowRequest`, where L is the number of requests logged in the window for a client. In worst case (many requests close to limit), L can approach `maxRequestsPerWindow`. Amortized cost is closer to O(1) if not many requests exceed limit frequently.",
        "spaceComplexity": "O(C * R), where C is number of clients, R is `maxRequestsPerWindow`. Space to store request logs for each client.",
        "javascriptSpecific": true
      },
      "examples": [
        {
          "input": "const limiter = new SlidingWindowLogRateLimiter(5, 60000); // 5 requests per minute. Call limiter.shouldAllowRequest('clientX') multiple times.",
          "output": "Requests are allowed up to 5 per minute within a sliding window. Requests exceeding the limit within the minute are rejected. After a minute has passed since older requests, new requests are allowed.",
          "explanation": "The rate limiter should accurately limit requests to 5 per minute using a sliding window, ensuring a rolling minute window for rate limiting."
        }
      ],
      "solutions": [
        {
          "approach": "Sliding Window Log Implementation",
          "code": "class SlidingWindowLogRateLimiter {\n  constructor(maxRequestsPerWindow, windowDurationMs) {\n    this.maxRequestsPerWindow = maxRequestsPerWindow;\n    this.windowDurationMs = windowDurationMs;\n    this.requestLogs = new Map(); // clientId -> [timestamps]\n  }\n\n  shouldAllowRequest(clientId) {\n    const now = Date.now();\n    const requestLog = this.requestLogs.get(clientId) || [];\n\n    // Remove outdated timestamps (older than window)\n    while (requestLog.length > 0 && requestLog[0] <= now - this.windowDurationMs) {\n      requestLog.shift();\n    }\n\n    if (requestLog.length < this.maxRequestsPerWindow) {\n      requestLog.push(now); // Add current request timestamp\n      this.requestLogs.set(clientId, requestLog);\n      return true; // Allow request\n    } else {\n      this.requestLogs.set(clientId, requestLog); // Update log even if rejected\n      return false; // Rate limit exceeded\n    }\n  }\n}",
          "explanation": "Implementation:\n- `maxRequestsPerWindow`, `windowDurationMs`, `requestLogs` initialized.\n- `shouldAllowRequest(clientId)`:\n  - Gets current timestamp `now`.\n  - Gets client's `requestLog` (or empty array if new client).\n  - `while` loop: Removes timestamps older than `windowDurationMs` from log.\n  - `if (requestLog.length < this.maxRequestsPerWindow)`: Check if within limit.\n    - If yes, push `now` to `requestLog`, update `requestLogs`, return `true`.\n    - If no, update `requestLogs`, return `false`."
        }
      ]
    },
    {
      "id": "pq86",
      "title": "Implement a Function to Check if a Number is Prime",
      "category": "Algorithms, Math",
      "difficulty": "Easy",
      "description": "Write a JavaScript function `isPrime(num)` that checks if a given number `num` is a prime number. A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself.",
      "methodology": {
        "approach": "Optimized Iteration for Divisibility Check",
        "explanation": "To check if a number is prime, we need to determine if it has any divisors other than 1 and itself. We can optimize this by only checking for divisors up to the square root of the number. If a number has a divisor greater than its square root, it must also have a divisor smaller than its square root.\n\n1. Create a function `isPrime(num)` that takes a number `num` as input.\n2. Handle base cases:\n   - If `num` is less than or equal to 1, it's not prime, return `false`.\n   - If `num` is less than or equal to 3, it's prime, return `true` (2 and 3 are prime).\n   - If `num` is divisible by 2 or 3, it's not prime, return `false`.\n3. Iterate from `i = 5` up to the square root of `num` (incrementing `i` by 6 in each step - optimization based on prime distribution).\n4. In each iteration, check if `num` is divisible by `i` or `i + 2`. If divisible by either, return `false` (not prime).\n5. If the loop completes without finding any divisors, return `true` (prime).",
        "timeComplexity": "O(sqrt(n)), where n is the input number. We iterate up to the square root of n.",
        "spaceComplexity": "O(1) - constant space, using only a few variables.",
        "javascriptSpecific": false
      },
      "examples": [
        {
          "input": "isPrime(7)",
          "output": "true",
          "explanation": "7 is a prime number."
        },
        {
          "input": "isPrime(12)",
          "output": "false",
          "explanation": "12 is not a prime number (divisible by 2, 3, 4, 6)."
        },
        {
          "input": "isPrime(2)",
          "output": "true",
          "explanation": "2 is a prime number."
        }
      ],
      "solutions": [
        {
          "approach": "Optimized Divisibility Check",
          "code": "function isPrime(num) {\n  if (num <= 1) return false; // Numbers <= 1 are not prime\n  if (num <= 3) return true;  // 2 and 3 are prime\n  if (num % 2 === 0 || num % 3 === 0) return false; // Divisible by 2 or 3\n\n  for (let i = 5; i * i <= num; i = i + 6) { // Optimized loop, check i and i+2\n    if (num % i === 0 || num % (i + 2) === 0) return false;\n  }\n\n  return true; // No divisors found, it's prime\n}",
          "explanation": "Implementation:\n- Handle base cases: `num <= 1`, `num <= 3`, divisibility by 2 or 3.\n- Optimized loop: `for (i=5; i*i <= num; i=i+6)` checks divisors `i` and `i+2`.\n- `if (num % i === 0 || num % (i + 2) === 0)`: If divisible, return `false` (not prime).\n- Return `true` if loop completes without finding divisors."
        }
      ]
    },
    {
      "id": "pq87",
      "title": "Implement a Function to Calculate Factorial",
      "category": "Algorithms, Math, Recursion",
      "difficulty": "Easy",
      "description": "Write a JavaScript function `factorial(n)` to calculate the factorial of a non-negative integer n. Factorial of n (n!) is the product of all positive integers less than or equal to n.",
      "methodology": {
        "approach": "Recursive and Iterative Approaches",
        "explanation": "Factorial can be calculated using both recursive and iterative approaches.\n\n1. Recursive Approach:\n   - Base case: If `n` is 0, factorial is 1 (0! = 1).\n   - Recursive case: For `n > 0`, factorial of `n` is `n * factorial(n - 1)`.\n\n2. Iterative Approach:\n   - Initialize a variable `result` to 1.\n   - Iterate from `i = 1` to `n`.\n   - In each iteration, multiply `result` by `i`.\n   - Return `result` after the loop.",
        "timeComplexity": "O(n) for both recursive and iterative approaches, as they both perform n multiplications.",
        "spaceComplexity": "O(n) for recursive approach due to call stack depth. O(1) for iterative approach - constant space.",
        "javascriptSpecific": false
      },
      "examples": [
        {
          "input": "factorial(5)",
          "output": "120",
          "explanation": "5! = 5 * 4 * 3 * 2 * 1 = 120"
        },
        {
          "input": "factorial(0)",
          "output": "1",
          "explanation": "0! = 1 (by definition)"
        }
      ],
      "solutions": [
        {
          "approach": "Recursive",
          "code": "function factorialRecursive(n) {\n  if (n === 0) return 1; // Base case: 0! = 1\n  return n * factorialRecursive(n - 1); // Recursive case: n! = n * (n-1)!\n}",
          "explanation": "Recursive implementation:\n- Base case: `if (n === 0) return 1`.\n- Recursive step: `return n * factorialRecursive(n - 1)`."
        },
        {
          "approach": "Iterative",
          "code": "function factorialIterative(n) {\n  let result = 1;\n  for (let i = 1; i <= n; i++) { // Iterate from 1 to n\n    result *= i; // Multiply result by current number\n  }\n  return result;\n}",
          "explanation": "Iterative implementation:\n- Initialize `result = 1`.\n- `for` loop: Iterate from `i = 1` to `n`.\n- `result *= i`: Multiply `result` by `i` in each iteration.\n- Return `result`."
        }
      ]
    },
    {
      "id": "pq88",
      "title": "Implement a Function to Reverse an Integer",
      "category": "Algorithms, Math",
      "difficulty": "Easy",
      "description": "Write a JavaScript function `reverseInteger(num)` that reverses a given integer `num`. For example, reversing 123 should return 321, and reversing -123 should return -321.",
      "methodology": {
        "approach": "String Conversion and Reversal, or Math Operations",
        "explanation": "There are two main approaches to reverse an integer:\n\n1. String Conversion and Reversal:\n   - Convert the integer to a string.\n   - Reverse the string.\n   - Convert the reversed string back to an integer.\n   - Handle the sign (positive or negative) separately.\n\n2. Math Operations (Modulo and Division):\n   - Initialize a variable `reversedNum` to 0.\n   - While the number `num` is greater than 0 (or while not zero for negative numbers too, handling sign separately):\n     - Extract the last digit of `num` using modulo operator (`digit = num % 10`).\n     - Append the digit to `reversedNum` by multiplying `reversedNum` by 10 and adding the `digit`.\n     - Remove the last digit from `num` by integer division (`num = Math.floor(num / 10)`).\n   - Handle the sign (positive or negative) to ensure the reversed number has the correct sign.",
        "timeComplexity": "O(log n), where n is the input number. The number of iterations is proportional to the number of digits in n, which is log base 10 of n.",
        "spaceComplexity": "O(1) - constant space, using only a few variables.",
        "javascriptSpecific": false
      },
      "examples": [
        {
          "input": "reverseInteger(123)",
          "output": "321",
          "explanation": "Reversing digits of 123 gives 321."
        },
        {
          "input": "reverseInteger(-123)",
          "output": "-321",
          "explanation": "Reversing digits of -123 gives -321, maintaining the negative sign."
        },
        {
          "input": "reverseInteger(120)",
          "output": "21",
          "explanation": "Reversing 120 gives 021, which is 21 as an integer."
        }
      ],
      "solutions": [
        {
          "approach": "String Conversion and Reversal",
          "code": "function reverseIntegerString(num) {\n  const isNegative = num < 0;\n  const numStr = String(Math.abs(num)); // Convert to string, handle negative\n  const reversedStr = numStr.split('').reverse().join(''); // Reverse string\n  const reversedNum = parseInt(reversedStr, 10); // Convert back to integer\n\n  return isNegative ? -reversedNum : reversedNum; // Restore sign\n}",
          "explanation": "String conversion approach:\n- `isNegative`: Check if number is negative.\n- `numStr = String(Math.abs(num))`: Convert absolute value to string.\n- `reversedStr = numStr.split('').reverse().join('')`: Reverse string.\n- `reversedNum = parseInt(reversedStr, 10)`: Convert reversed string back to integer.\n- Return `isNegative ? -reversedNum : reversedNum`: Restore original sign."
        },
        {
          "approach": "Math Operations (Modulo and Division)",
          "code": "function reverseIntegerMath(num) {\n  let reversedNum = 0;\n  let currentNum = Math.abs(num); // Work with absolute value\n  const isNegative = num < 0;\n\n  while (currentNum > 0) {\n    const digit = currentNum % 10; // Extract last digit\n    reversedNum = reversedNum * 10 + digit; // Append digit to reversedNum\n    currentNum = Math.floor(currentNum / 10); // Remove last digit from currentNum\n  }\n\n  return isNegative ? -reversedNum : reversedNum; // Restore sign\n}",
          "explanation": "Math operations approach:\n- `reversedNum = 0`: Initialize reversed number.\n- `currentNum = Math.abs(num)`: Use absolute value for processing.\n- `isNegative`: Track original sign.\n- `while (currentNum > 0)`: Loop while digits remain.\n  - `digit = currentNum % 10`: Extract last digit.\n  - `reversedNum = reversedNum * 10 + digit`: Append digit to reversed number.\n  - `currentNum = Math.floor(currentNum / 10)`: Remove last digit.\n- Return `isNegative ? -reversedNum : reversedNum`: Restore original sign."
        }
      ]
    },
    {
      "id": "pq89",
      "title": "Implement a Function to Check for Anagrams (Character Map)",
      "category": "Strings, Hash Tables",
      "difficulty": "Easy",
      "description": "Write a JavaScript function `areAnagrams(str1, str2)` to efficiently check if two strings `str1` and `str2` are anagrams using a character map (frequency counter).",
      "methodology": {
        "approach": "Character Frequency Counting (Hash Map)",
        "explanation": "To efficiently check for anagrams, we can use a character frequency map (hash map). This approach avoids sorting and directly compares character counts.\n\n1. Create a function `areAnagrams(str1, str2)`.\n2. Check if the lengths of `str1` and `str2` are different. If they are, they cannot be anagrams, return `false`.\n3. Create a character frequency map (object or Map) `charMap`.\n4. Iterate through `str1`:\n   - For each character, increment its count in `charMap`. If the character is not in `charMap`, initialize its count to 1.\n5. Iterate through `str2`:\n   - For each character, decrement its count in `charMap`. If the character is not in `charMap` (count becomes negative), or if a character's count becomes negative during decrement, it means strings are not anagrams, return `false`.\n6. After iterating through both strings, check all values in `charMap`. If all counts are 0, it means the strings are anagrams, return `true`. Otherwise, return `false`.",
        "timeComplexity": "O(n), where n is the length of the strings (assuming strings are of similar length). We iterate through both strings once and then iterate through the character map (which in worst case is alphabet size, considered constant).",
        "spaceComplexity": "O(1) - constant space, because the character map size is limited by the alphabet size (e.g., 26 for lowercase English letters).",
        "javascriptSpecific": false
      },
      "examples": [
        {
          "input": "areAnagrams(\"listen\", \"silent\")",
          "output": "true",
          "explanation": "\"listen\" and \"silent\" are anagrams."
        },
        {
          "input": "areAnagrams(\"hello\", \"world\")",
          "output": "false",
          "explanation": "\"hello\" and \"world\" are not anagrams."
        },
        {
          "input": "areAnagrams(\"Debit Card\", \"Bad Credit\")",
          "output": "true",
          "explanation": "\"Debit Card\" and \"Bad Credit\" are anagrams (ignoring spaces and case)."
        }
      ],
      "solutions": [
        {
          "approach": "Character Frequency Map",
          "code": "function areAnagrams(str1, str2) {\n  const cleanStr1 = str1.replace(/[^a-zA-Z0-9]/g, '').toLowerCase(); // Clean and normalize strings\n  const cleanStr2 = str2.replace(/[^a-zA-Z0-9]/g, '').toLowerCase();\n\n  if (cleanStr1.length !== cleanStr2.length) {\n    return false; // Different lengths, not anagrams\n  }\n\n  const charMap = {};\n\n  for (let char of cleanStr1) {\n    charMap[char] = (charMap[char] || 0) + 1; // Count chars in str1\n  }\n\n  for (let char of cleanStr2) {\n    if (!charMap[char]) {\n      return false; // Char in str2 not in str1\n    }\n    charMap[char]--; // Decrement count for chars in str2\n  }\n\n  for (let char in charMap) {\n    if (charMap[char] !== 0) {\n      return false; // Counts not balanced\n    }\n  }\n\n  return true; // All counts are zero, anagrams\n}",
          "explanation": "Implementation:\n- `cleanStr1`, `cleanStr2`: Clean strings (remove non-alphanumeric, lowercase).\n- Length check: `if (cleanStr1.length !== cleanStr2.length) return false`.\n- `charMap = {}`: Initialize character frequency map.\n- Loop 1 (str1): Count character frequencies in `charMap`.\n- Loop 2 (str2): Decrement frequencies in `charMap`. If char not found or count goes negative, return `false`.\n- Loop 3 (charMap): Check if all counts in `charMap` are 0. If not, return `false`.\n- Return `true` if all checks pass."
        }
      ]
    },
     {
      "id": "pq90",
      "title": "Implement a Function to Find the Intersection of Two Arrays",
      "category": "Arrays, Hash Tables, Sets",
      "difficulty": "Easy",
      "description": "Write a JavaScript function `intersection(nums1, nums2)` to find the intersection of two arrays `nums1` and `nums2`. The intersection should contain only unique elements and can be in any order.",
      "methodology": {
        "approach": "Set and Filter Approach, or Hash Set Approach",
        "explanation": "There are efficient ways to find the intersection of two arrays, ensuring uniqueness of elements in the result.\n\n1. Set and Filter Approach:\n   - Convert `nums1` to a Set for efficient lookups.\n   - Filter `nums2`. For each element in `nums2`, check if it exists in the `nums1` Set. If it does, include it in the result.\n   - Convert the filtered array to a Set to ensure uniqueness and then back to an array if array output is required.\n\n2. Hash Set Approach (More direct):\n   - Create two Sets, `set1` from `nums1` and `set2` from `nums2`.\n   - Iterate through `set1`. For each element, check if it exists in `set2`. If it does, add it to a result Set.\n   - Convert the result Set to an array.",
        "timeComplexity": "O(m + n) for both approaches, where n and m are lengths of `nums1` and `nums2`. Set creation and lookups are typically O(1) on average.",
        "spaceComplexity": "O(m + n) in worst case to store elements of both arrays in Sets.",
        "javascriptSpecific": true
      },
      "examples": [
        {
          "input": "nums1 = [1, 2, 2, 1], nums2 = [2, 2]",
          "output": "[2]",
          "explanation": "The intersection is [2], with unique elements only."
        },
        {
          "input": "nums1 = [4, 9, 5], nums2 = [9, 4, 9, 8, 4]",
          "output": "[9, 4] or [4, 9]",
          "explanation": "The intersection is [9, 4] (order doesn't matter, unique elements)."
        }
      ],
      "solutions": [
        {
          "approach": "Set and Filter",
          "code": "function intersectionSetFilter(nums1, nums2) {\n  const set1 = new Set(nums1); // Create Set from nums1 for fast lookup\n  const intersectionArray = nums2.filter(num => set1.has(num)); // Filter nums2 based on set1\n  return Array.from(new Set(intersectionArray)); // Convert to Set for uniqueness, then back to Array\n}",
          "explanation": "Set and Filter approach:\n- `set1 = new Set(nums1)`: Create Set from `nums1`.\n- `intersectionArray = nums2.filter(num => set1.has(num))`: Filter `nums2`, keep elements present in `set1`.\n- `Array.from(new Set(intersectionArray))`: Convert filtered array to Set (unique), then back to Array."
        },
        {
          "approach": "Hash Set (Two Sets)",
          "code": "function intersectionHashSets(nums1, nums2) {\n  const set1 = new Set(nums1); // Create Set from nums1\n  const set2 = new Set(nums2); // Create Set from nums2\n  const intersectionSet = new Set(); // Result set\n\n  for (let num of set1) { // Iterate through set1\n    if (set2.has(num)) { // Check if element exists in set2\n      intersectionSet.add(num); // Add to intersection set\n    }\n  }\n\n  return Array.from(intersectionSet); // Convert result set to Array\n}",
          "explanation": "Hash Set approach:\n- `set1 = new Set(nums1)`, `set2 = new Set(nums2)`: Create Sets from both arrays.\n- `intersectionSet = new Set()`: Initialize result Set.\n- Loop `for (let num of set1)`: Iterate through `set1`.\n- `if (set2.has(num))`: Check if element from `set1` is in `set2`.\n- `intersectionSet.add(num)`: Add to `intersectionSet` if in both.\n- `return Array.from(intersectionSet)`: Convert result Set to Array."
        }
      ]
    },
    {
      "id": "pq91",
      "title": "Implement a Function to Remove Duplicates from an Array",
      "category": "Arrays, JavaScript",
      "difficulty": "Easy",
      "description": "Write a JavaScript function `removeDuplicates(arr)` that removes duplicate values from an array and returns a new array with unique values in their original order.",
      "methodology": {
        "approach": "Using Set and Array.from, or Filter with IndexOf",
        "explanation": "There are several ways to remove duplicates from an array in JavaScript while preserving the original order.\n\n1. Using Set and Array.from (Efficient and order-preserving in modern JS):\n   - Create a new Set from the input array. Sets only store unique values, automatically removing duplicates.\n   - Convert the Set back to an array using `Array.from()` to get an array of unique values in their original order of appearance.\n\n2. Using Filter and IndexOf (Order-preserving but less efficient for large arrays):\n   - Use the `filter()` method on the array.\n   - For each element in `filter` callback, use `indexOf()` to check if the element's first occurrence in the array is at the current index. If true, it's the first occurrence, so keep it; otherwise, it's a duplicate, so filter it out.\n\nSet approach is generally preferred for efficiency and simplicity, especially for large arrays.",
        "timeComplexity": "O(n) for Set approach, as Set creation and Array.from are O(n). O(nÂ²) for Filter and IndexOf approach due to indexOf being O(n) inside filter loop.",
        "spaceComplexity": "O(n) for Set approach in worst case to store unique elements in Set. O(n) for Filter approach in worst case to store the new array.",
        "javascriptSpecific": true
      },
      "examples": [
        {
          "input": "arr = [1, 2, 2, 3, 4, 4, 5]",
          "output": "[1, 2, 3, 4, 5]",
          "explanation": "Duplicates (2 and 4) are removed, and unique values are in original order."
        },
        {
          "input": "arr = ['a', 'b', 'b', 'c', 'a']",
          "output": "['a', 'b', 'c']",
          "explanation": "Duplicates ('b' and 'a') are removed from string array, original order preserved."
        }
      ],
      "solutions": [
        {
          "approach": "Using Set and Array.from",
          "code": "function removeDuplicatesSet(arr) {\n  return Array.from(new Set(arr)); // Create Set to remove duplicates, convert back to Array\n}",
          "explanation": "Set approach:\n- `new Set(arr)`: Creates a Set from `arr`, automatically removing duplicates.\n- `Array.from(...)`: Converts the Set back to an Array, preserving original insertion order."
        },
        {
          "approach": "Using Filter and IndexOf",
          "code": "function removeDuplicatesFilter(arr) {\n  return arr.filter((item, index) => arr.indexOf(item) === index); // Filter array, keep only first occurrences\n}",
          "explanation": "Filter and IndexOf approach:\n- `arr.filter(...)`: Filters the array.\n- `(item, index) => arr.indexOf(item) === index`: Callback function for filter.\n  - `arr.indexOf(item)`: Gets index of first occurrence of `item`.\n  - `=== index`: Checks if first occurrence index is the same as current `index`.\n  - If true (first occurrence), `filter` keeps the item; otherwise, filters it out."
        }
      ]
    },
    {
      "id": "pq92",
      "title": "Implement a Function to Find the First Recurring Character in a String",
      "category": "Strings, Hash Tables",
      "difficulty": "Medium",
      "description": "Write a JavaScript function `firstRecurringChar(str)` that finds the first recurring character in a given string. For example, in 'abca', 'a' is the first recurring character.",
      "methodology": {
        "approach": "Hash Set to Track Seen Characters",
        "explanation": "To find the first recurring character efficiently, we can iterate through the string and use a Set to keep track of characters we've already seen. As soon as we encounter a character that is already in the Set, we've found the first recurring character.\n\n1. Create a function `firstRecurringChar(str)`.\n2. Initialize an empty Set `seenChars` to store characters encountered so far.\n3. Iterate through the input string `str` character by character.\n4. For each character:\n   - Check if the character is already present in `seenChars`. If yes, return this character as it's the first recurring one.\n   - If the character is not in `seenChars`, add it to `seenChars` and continue to the next character.\n5. If the loop completes without finding any recurring character, return `undefined` (or null) to indicate no recurring character found.",
        "timeComplexity": "O(n), where n is the length of the string, as we iterate through the string once in the worst case.",
        "spaceComplexity": "O(1) - constant space in practice, because the Set will store at most the number of unique characters in the alphabet, which is considered constant (e.g., 26 for lowercase English letters). In theory, worst-case O(n) if string has all unique characters before repetition.",
        "javascriptSpecific": false
      },
      "examples": [
        {
          "input": "str = \"abca\"",
          "output": "\"a\"",
          "explanation": "'a' is the first character that recurs in the string."
        },
        {
          "input": "str = \"bcaba\"",
          "output": "\"b\"",
          "explanation": "'b' is the first character that recurs."
        },
        {
          "input": "str = \"abcdefg\"",
          "output": "undefined",
          "explanation": "No character recurs in the string."
        }
      ],
      "solutions": [
        {
          "approach": "Hash Set Tracking",
          "code": "function firstRecurringChar(str) {\n  const seenChars = new Set(); // Set to store seen characters\n\n  for (let char of str) {\n    if (seenChars.has(char)) { // Check if char already seen\n      return char; // Found recurring char\n    }\n    seenChars.add(char); // Add char to seen set\n  }\n\n  return undefined; // No recurring char found\n}",
          "explanation": "Implementation:\n- `seenChars = new Set()`: Initialize Set to track seen characters.\n- `for (let char of str)`: Iterate through string.\n- `if (seenChars.has(char))`: Check if current `char` is already in `seenChars`.\n  - If yes, `return char` (first recurring character found).\n- `seenChars.add(char)`: If not seen, add `char` to `seenChars`.\n- `return undefined`: If loop completes without returning, no recurring char found."
        }
      ]
    },
    {
      "id": "pq93",
      "title": "Implement a Function to Check if a String is a Permutation of Another",
      "category": "Strings, Hash Tables",
      "difficulty": "Medium",
      "description": "Write a JavaScript function `checkPermutation(str1, str2)` to determine if one string is a permutation of another string. Consider two strings permutations of each other if they contain the same characters with the same frequencies, but in a different order.",
      "methodology": {
        "approach": "Character Frequency Counting (Hash Map)",
        "explanation": "To check if two strings are permutations of each other, we can compare their character frequencies. If two strings are permutations, they must have the same count of each character.\n\n1. Create a function `checkPermutation(str1, str2)`.\n2. Check if the lengths of `str1` and `str2` are different. If they are, they cannot be permutations, return `false`.\n3. Create a character frequency map (object or Map) `charCountMap`.\n4. Iterate through `str1` and populate `charCountMap` with character counts (increment counts).\n5. Iterate through `str2`:\n   - For each character in `str2`, decrement its count in `charCountMap`. If a character is not found in `charCountMap` or its count becomes negative, it means `str2` has characters not in `str1` or more occurrences of a character, so return `false`.\n6. After processing `str2`, iterate through the values in `charCountMap`. If all values are 0, it means both strings have the same character frequencies, so return `true` (permutations). If any value is not 0, return `false`.",
        "timeComplexity": "O(n), where n is the length of the strings (assuming similar lengths). We iterate through both strings and then the character map (which is of constant size alphabet).",
        "spaceComplexity": "O(1) - constant space, as the character map size is limited by the alphabet size.",
        "javascriptSpecific": false
      },
      "examples": [
        {
          "input": "str1 = \"listen\", str2 = \"silent\"",
          "output": "true",
          "explanation": "\"listen\" is a permutation of \"silent\"."
        },
        {
          "input": "str1 = \"hello\", str2 = \"world\"",
          "output": "false",
          "explanation": "\"hello\" is not a permutation of \"world\"."
        },
        {
          "input": "str1 = \"google\", str2 = \"elgoog\"",
          "output": "true",
          "explanation": "\"google\" is a permutation of \"elgoog\"."
        }
      ],
      "solutions": [
        {
          "approach": "Character Frequency Map",
          "code": "function checkPermutation(str1, str2) {\n  if (str1.length !== str2.length) {\n    return false; // Permutations must have same length\n  }\n\n  const charCountMap = {};\n\n  for (let char of str1) {\n    charCountMap[char] = (charCountMap[char] || 0) + 1; // Count chars in str1\n  }\n\n  for (let char of str2) {\n    if (!charCountMap[char]) {\n      return false; // Char in str2 not in str1\n    }\n    charCountMap[char]--; // Decrement count for chars in str2\n  }\n\n  for (let char in charCountMap) {\n    if (charCountMap[char] !== 0) {\n      return false; // Counts not balanced\n    }\n  }\n\n  return true; // All counts are zero, permutations\n}",
          "explanation": "Implementation:\n- Length check: `if (str1.length !== str2.length) return false`.\n- `charCountMap = {}`: Initialize character count map.\n- Loop 1 (str1): Populate `charCountMap` with character counts from `str1`.\n- Loop 2 (str2): Decrement counts in `charCountMap` for characters in `str2`. Return `false` if char not found or count becomes negative.\n- Loop 3 (charMap): Check if all counts in `charCountMap` are 0. Return `false` if not.\n- Return `true` if all checks pass."
        }
      ]
    },
    {
      "id": "pq94",
      "title": "Implement a Function to Find the First Non-Repeated Character in a String (Ordered)",
      "category": "Strings, Hash Tables, Ordering",
      "difficulty": "Medium",
      "description": "Write a JavaScript function `firstNonRepeatedChar(str)` that finds the first character that does not repeat in a given string, maintaining the order of characters as they appear in the string. For example, in 'total', 'o' is the first non-repeated character.",
      "methodology": {
        "approach": "Ordered Hash Map (or Two-Pass Approach with Regular Map)",
        "explanation": "To find the *first* non-repeated character while maintaining order, we need to track character counts and also the order of appearance. We can use an ordered hash map (like `LinkedHashMap` in some languages, or simulate order in JavaScript) or a two-pass approach.\n\n1. Ordered Hash Map Approach (using JavaScript Map which maintains insertion order):\n   - Create a Map `charCountMap` to store character counts and maintain insertion order.\n   - Iterate through the string `str`.\n   - For each character, update its count in `charCountMap`. If character is new, add it to the map with count 1; otherwise, increment its existing count.\n   - After counting, iterate through the entries of `charCountMap` in insertion order (using `Map.entries()`).\n   - Return the key (character) of the first entry with a count of 1.\n   - If no entry with count 1 is found, return `undefined`.\n\n2. Two-Pass Approach (using regular JavaScript object for count):\n   - First pass: Create a character count object `charCounts` by iterating through the string and counting each character's frequency.\n   - Second pass: Iterate through the string again in its original order.\n   - For each character, check its count in `charCounts`. If the count is 1, return this character as it's the first non-repeated character in order.\n   - If the second pass completes without finding any character with count 1, return `undefined`.",
        "timeComplexity": "O(n) for both approaches, where n is the length of the string. Two-pass approach iterates twice, and Map approach involves iteration and Map operations which are near O(1) on average.",
        "spaceComplexity": "O(1) - constant space, as character map/object size is limited by alphabet size.",
        "javascriptSpecific": false
      },
      "examples": [
        {
          "input": "str = \"total\"",
          "output": "\"o\"",
          "explanation": "'o' is the first non-repeated character in \"total\"."
        },
        {
          "input": "str = \"teeter\"",
          "output": "\"r\"",
          "explanation": "'r' is the first non-repeated character in \"teeter\"."
        },
        {
          "input": "str = \"aabbcc\"",
          "output": "undefined",
          "explanation": "All characters are repeated, so no non-repeated character."
        }
      ],
      "solutions": [
        {
          "approach": "Ordered Hash Map (JavaScript Map)",
          "code": "function firstNonRepeatedCharOrderedMap(str) {\n  const charCountMap = new Map(); // Use Map to maintain insertion order\n\n  for (let char of str) {\n    charCountMap.set(char, (charCountMap.get(char) || 0) + 1); // Count chars\n  }\n\n  for (let [char, count] of charCountMap.entries()) { // Iterate in insertion order\n    if (count === 1) {\n      return char; // Return first char with count 1\n    }\n  }\n\n  return undefined; // No non-repeated char found\n}",
          "explanation": "Ordered Map approach:\n- `charCountMap = new Map()`: Use Map to preserve order.\n- Loop 1 (str): Populate `charCountMap` with character counts.\n- Loop 2 (`charCountMap.entries()`): Iterate through Map entries in insertion order.\n- `if (count === 1)`: Return `char` if count is 1 (first non-repeated).\n- Return `undefined` if no non-repeated char."
        },
        {
          "approach": "Two-Pass Approach (Regular Object)",
          "code": "function firstNonRepeatedCharTwoPass(str) {\n  const charCounts = {}; // Regular object for counts\n\n  for (let char of str) { // First pass: count frequencies\n    charCounts[char] = (charCounts[char] || 0) + 1;\n  }\n\n  for (let char of str) { // Second pass: check in order\n    if (charCounts[char] === 1) {\n      return char; // Return first char with count 1\n    }\n  }\n\n  return undefined; // No non-repeated char\n}",
          "explanation": "Two-Pass approach:\n- `charCounts = {}`: Regular object for character counts.\n- First pass loop: Count character frequencies in `charCounts`.\n- Second pass loop: Iterate through string *again* in original order.\n- `if (charCounts[char] === 1)`: Return `char` if count is 1 (first non-repeated in order).\n- Return `undefined` if no non-repeated char."
        }
      ]
    },
    {
      "id": "pq95",
      "title": "Implement a Function to Check if a String Contains Only Unique Characters",
      "category": "Strings, Hash Sets",
      "difficulty": "Easy",
      "description": "Write a JavaScript function `hasUniqueChars(str)` to determine if a given string contains only unique characters. Consider case-sensitive uniqueness.",
      "methodology": {
        "approach": "Hash Set to Track Characters",
        "explanation": "To efficiently check for unique characters, we can iterate through the string and use a Set to keep track of characters we've encountered so far. If we encounter a character that is already in the Set, we know the string does not have all unique characters.\n\n1. Create a function `hasUniqueChars(str)`.\n2. Initialize an empty Set `charSet` to store characters encountered in the string.\n3. Iterate through the input string `str` character by character.\n4. For each character:\n   - Check if the character is already present in `charSet`. If yes, return `false` (duplicate found).\n   - If the character is not in `charSet`, add it to `charSet`.\n5. If the loop completes without finding any duplicates, return `true` (all characters are unique).",
        "timeComplexity": "O(n), where n is the length of the string, as we iterate through the string once.",
        "spaceComplexity": "O(1) - constant space in practice. The Set `charSet` will store at most the number of unique characters in the alphabet, which is considered constant. In theory, O(n) in extreme case if all chars are unique until end of string.",
        "javascriptSpecific": false
      },
      "examples": [
        {
          "input": "str = \"abcdefg\"",
          "output": "true",
          "explanation": "The string \"abcdefg\" contains all unique characters."
        },
        {
          "input": "str = \"hello\"",
          "output": "false",
          "explanation": "The string \"hello\" contains duplicate characters ('l')."
        },
        {
          "input": "str = \"Programming\"",
          "output": "false",
          "explanation": "\"Programming\" contains duplicate characters ('r', 'o', 'g', 'm', 'i', 'n')."
        }
      ],
      "solutions": [
        {
          "approach": "Hash Set Character Tracking",
          "code": "function hasUniqueChars(str) {\n  const charSet = new Set(); // Set to store characters\n\n  for (let char of str) {\n    if (charSet.has(char)) { // Check if character already in Set\n      return false; // Duplicate character found\n    }\n    charSet.add(char); // Add character to Set\n  }\n\n  return true; // No duplicates found, all unique\n}",
          "explanation": "Implementation:\n- `charSet = new Set()`: Initialize Set to track characters.\n- `for (let char of str)`: Iterate through string.\n- `if (charSet.has(char))`: Check if `char` is already in `charSet`.\n  - If yes, return `false` (duplicate found).\n- `charSet.add(char)`: If not duplicate, add `char` to `charSet`.\n- Return `true` if loop completes without duplicates."
        }
      ]
    },
     {
      "id": "pq96",
      "title": "Implement Bubble Sort Algorithm in JavaScript",
      "category": "Algorithms, Sorting",
      "difficulty": "Easy",
      "description": "Implement the Bubble Sort algorithm in JavaScript to sort an array of numbers in ascending order.",
      "methodology": {
        "approach": "Iterative Comparison and Swapping",
        "explanation": "Bubble Sort is a simple sorting algorithm that repeatedly steps through the list, compares adjacent elements and swaps them if they are in the wrong order. The pass through the list is repeated until no swaps are needed, which indicates that the list is sorted. Larger elements 'bubble' to the end of the array with each pass.\n\n1. Create a function `bubbleSort(arr)` that takes an array `arr` of numbers.\n2. Implement outer loop that iterates `n-1` times (where `n` is array length), controlling passes through the array.\n3. Implement inner loop that iterates from the beginning of the array up to the unsorted part of the array (initially up to `n-1`, reducing in each outer loop iteration).\n4. Inside the inner loop, compare adjacent elements `arr[j]` and `arr[j+1]`.\n5. If `arr[j] > arr[j+1]` (for ascending sort), swap them.\n6. After the loops complete, the array `arr` will be sorted in ascending order. Return the sorted array.",
        "timeComplexity": "O(nÂ²) in worst and average case, where n is the number of elements in the array. Best case O(n) if the array is already sorted (with optimization to check for swaps in each pass).",
        "spaceComplexity": "O(1) - constant space, as Bubble Sort is an in-place sorting algorithm.",
        "javascriptSpecific": false
      },
      "examples": [
        {
          "input": "arr = [5, 1, 4, 2, 8]",
          "output": "[1, 2, 4, 5, 8]",
          "explanation": "Bubble Sort sorts the array in ascending order."
        },
        {
          "input": "arr = [-3, 0, 5, -1, 2]",
          "output": "[-3, -1, 0, 2, 5]",
          "explanation": "Bubble Sort correctly sorts negative and positive numbers."
        }
      ],
      "solutions": [
        {
          "approach": "Iterative Bubble Sort",
          "code": "function bubbleSort(arr) {\n  const n = arr.length;\n  let swapped;\n\n  for (let i = 0; i < n - 1; i++) { // Outer loop for passes\n    swapped = false; // Optimization: check if any swap occurred in pass\n    for (let j = 0; j < n - i - 1; j++) { // Inner loop for adjacent comparisons\n      if (arr[j] > arr[j + 1]) { // Compare adjacent elements\n        // Swap arr[j] and arr[j+1]\n        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];\n        swapped = true; // Swap occurred\n      }\n    }\n    if (!swapped) break; // If no swap in inner loop, array is sorted\n  }\n  return arr;\n}",
          "explanation": "Implementation:\n- `n = arr.length`: Get array length.\n- Outer loop `for (i < n - 1)`: Controls passes.\n- `swapped = false`: Optimization flag, resets at start of each pass.\n- Inner loop `for (j < n - i - 1)`: Compares adjacent elements up to unsorted part.\n- `if (arr[j] > arr[j + 1])`: Compare adjacent elements for ascending order.\n  - Swap elements using destructuring assignment `[arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]`.\n  - `swapped = true`: Set flag if swap occurred.\n- `if (!swapped) break`: Optimization: if no swaps in a pass, array is sorted, break loop.\n- Return sorted `arr`."
        }
      ]
    },
    {
      "id": "pq97",
      "title": "Implement Selection Sort Algorithm in JavaScript",
      "category": "Algorithms, Sorting",
      "difficulty": "Medium",
      "description": "Implement the Selection Sort algorithm in JavaScript to sort an array of numbers in ascending order.",
      "methodology": {
        "approach": "Iterative Minimum Finding and Swapping",
        "explanation": "Selection Sort algorithm sorts an array by repeatedly finding the minimum element from the unsorted part and placing it at the beginning. The algorithm divides the array into a sorted and an unsorted region. In each iteration, the smallest element from the unsorted region is selected and moved to the sorted region.\n\n1. Create a function `selectionSort(arr)` that takes an array `arr` of numbers.\n2. Implement an outer loop that iterates from `i = 0` to `n-2` (where `n` is array length), marking the beginning of the unsorted region.\n3. Initialize `min_index` to `i`, assuming the current element is the minimum in the unsorted region.\n4. Implement an inner loop that iterates from `j = i + 1` to `n-1` (through the unsorted region).\n5. Inside the inner loop, compare `arr[j]` with `arr[min_index]`. If `arr[j]` is smaller, update `min_index` to `j` (found a new minimum).\n6. After the inner loop completes, `min_index` will hold the index of the minimum element in the unsorted region. Swap `arr[i]` (first element of unsorted region) with `arr[min_index]` to place the minimum element at the correct sorted position.\n7. After the outer loop completes, the array `arr` will be sorted in ascending order. Return the sorted array.",
        "timeComplexity": "O(nÂ²) in all cases (worst, average, best), where n is the number of elements. Selection Sort always performs nested loops regardless of input array order.",
        "spaceComplexity": "O(1) - constant space, as Selection Sort is an in-place sorting algorithm.",
        "javascriptSpecific": false
      },
      "examples": [
        {
          "input": "arr = [64, 25, 12, 22, 11]",
          "output": "[11, 12, 22, 25, 64]",
          "explanation": "Selection Sort sorts the array in ascending order."
        },
        {
          "input": "arr = [-5, 0, 10, -2, 3]",
          "output": "[-5, -2, 0, 3, 10]",
          "explanation": "Selection Sort sorts negative and positive numbers correctly."
        }
      ],
      "solutions": [
        {
          "approach": "Iterative Selection Sort",
          "code": "function selectionSort(arr) {\n  const n = arr.length;\n\n  for (let i = 0; i < n - 1; i++) { // Outer loop for unsorted region start\n    let minIndex = i; // Assume current index is min\n    for (let j = i + 1; j < n; j++) { // Inner loop to find minimum in unsorted region\n      if (arr[j] < arr[minIndex]) { // Compare for new minimum\n        minIndex = j; // Update minIndex if smaller element found\n      }\n    }\n    if (minIndex !== i) { // Swap if minIndex is not the current index\n      [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]]; // Swap current with minimum\n    }\n  }\n  return arr;\n}",
          "explanation": "Implementation:\n- `n = arr.length`: Get array length.\n- Outer loop `for (i < n - 1)`: Iterates through unsorted region start.\n- `minIndex = i`: Assume current element is minimum.\n- Inner loop `for (j = i + 1; j < n)`: Finds minimum in unsorted region.\n- `if (arr[j] < arr[minIndex])`: Compare for smaller element.\n  - `minIndex = j`: Update `minIndex` if new minimum found.\n- `if (minIndex !== i)`: Swap if `minIndex` changed (new minimum found).\n  - Swap `arr[i]` and `arr[minIndex]` using destructuring assignment.\n- Return sorted `arr`."
        }
      ]
    },
    {
      "id": "pq98",
      "title": "Implement Insertion Sort Algorithm in JavaScript",
      "category": "Algorithms, Sorting",
      "difficulty": "Medium",
      "description": "Implement the Insertion Sort algorithm in JavaScript to sort an array of numbers in ascending order.",
      "methodology": {
        "approach": "Iterative Insertion into Sorted Subarray",
        "explanation": "Insertion Sort builds the final sorted array one item at a time. It iterates through the input array and, for each element, inserts it into its correct position in the already sorted part of the array. It's efficient for small arrays or nearly sorted arrays.\n\n1. Create a function `insertionSort(arr)` that takes an array `arr` of numbers.\n2. Iterate through the array starting from the second element (index 1) to the end. This element is the `currentVal` to be inserted into the sorted part.\n3. For each `currentVal`, compare it with elements in the sorted part (elements to its left, from index `j = i-1` down to 0).\n4. While `arr[j] > currentVal` and `j >= 0` (meaning element in sorted part is greater than `currentVal` and we are within array bounds):\n   - Shift `arr[j]` one position to the right to make space for `currentVal` (`arr[j+1] = arr[j]`).\n   - Decrement `j` to compare with the next element to the left in the sorted part.\n5. After the inner loop (while loop) completes, the correct position for `currentVal` in the sorted part is found (or it's at the beginning). Insert `currentVal` at `arr[j+1]`.\n6. After the outer loop completes, the array `arr` will be sorted in ascending order. Return the sorted array.",
        "timeComplexity": "O(nÂ²) in worst and average case (reverse sorted array). Best case O(n) if the array is already sorted or nearly sorted.",
        "spaceComplexity": "O(1) - constant space, Insertion Sort is an in-place algorithm.",
        "javascriptSpecific": false
      },
      "examples": [
        {
          "input": "arr = [5, 2, 4, 6, 1, 3]",
          "output": "[1, 2, 3, 4, 5, 6]",
          "explanation": "Insertion Sort sorts the array in ascending order."
        },
        {
          "input": "arr = [-2, 0, -5, 4, 1]",
          "output": "[-5, -2, 0, 1, 4]",
          "explanation": "Insertion Sort correctly sorts negative and positive numbers."
        }
      ],
      "solutions": [
        {
          "approach": "Iterative Insertion Sort",
          "code": "function insertionSort(arr) {\n  const n = arr.length;\n\n  for (let i = 1; i < n; i++) { // Outer loop starts from 2nd element\n    let currentVal = arr[i]; // Element to be inserted\n    let j = i - 1; // Index in sorted part\n\n    while (j >= 0 && arr[j] > currentVal) { // Move elements in sorted part to right\n      arr[j + 1] = arr[j]; // Shift element to make space\n      j--;\n    }\n    arr[j + 1] = currentVal; // Insert currentVal in correct position\n  }\n  return arr;\n}",
          "explanation": "Implementation:\n- `n = arr.length`: Get array length.\n- Outer loop `for (i = 1; i < n)`: Start from 2nd element.\n- `currentVal = arr[i]`: Element to be inserted into sorted part.\n- `j = i - 1`: Index in sorted subarray (to the left).\n- `while (j >= 0 && arr[j] > currentVal)`: While in sorted part and element > `currentVal`:\n  - `arr[j + 1] = arr[j]`: Shift element to the right.\n  - `j--`: Move to next element to the left.\n- `arr[j + 1] = currentVal`: Insert `currentVal` at correct position (j+1).\n- Return sorted `arr`."
        }
      ]
    },
    {
      "id": "pq99",
      "title": "Implement Quick Sort Algorithm in JavaScript",
      "category": "Algorithms, Sorting, Divide and Conquer",
      "difficulty": "Hard",
      "description": "Implement the Quick Sort algorithm in JavaScript to sort an array of numbers in ascending order.",
      "methodology": {
        "approach": "Divide and Conquer with Partitioning",
        "explanation": "Quick Sort is a divide and conquer algorithm. It works by selecting a 'pivot' element from the array and partitioning the other elements into two sub-arrays, according to whether they are less than or greater than the pivot. The sub-arrays are then sorted recursively.\n\n1. Create a function `quickSort(arr)` that takes an array `arr` of numbers.\n2. Base case: If the array has 0 or 1 element, it's already sorted, return the array.\n3. Choose a pivot element. A common strategy is to pick the last element of the array as the pivot.\n4. Partition the array: Create two empty arrays, `leftArr` and `rightArr`. Iterate through the array (excluding the pivot element).\n   - If an element is less than the pivot, push it to `leftArr`.\n   - If an element is greater than or equal to the pivot, push it to `rightArr`.\n5. Recursively call `quickSort` on `leftArr` and `rightArr` to sort the sub-arrays.\n6. Combine the sorted `leftArr`, the pivot element, and the sorted `rightArr` to get the final sorted array: `return [...quickSort(leftArr), pivot, ...quickSort(rightArr)]`.",
        "timeComplexity": "O(n log n) on average and best case, where n is the number of elements. Worst case O(nÂ²) if pivot selection is consistently poor (e.g., always picking smallest or largest element, leading to skewed partitions).",
        "spaceComplexity": "O(log n) on average due to recursive call stack depth (for balanced partitions). Worst case O(n) in skewed partition scenarios.",
        "javascriptSpecific": false
      },
      "examples": [
        {
          "input": "arr = [10, 7, 8, 9, 1, 5]",
          "output": "[1, 5, 7, 8, 9, 10]",
          "explanation": "Quick Sort sorts the array in ascending order."
        },
        {
          "input": "arr = [-8, 2, -3, 4, 0, 5]",
          "output": "[-8, -3, 0, 2, 4, 5]",
          "explanation": "Quick Sort sorts negative and positive numbers."
        }
      ],
      "solutions": [
        {
          "approach": "Recursive Quick Sort",
          "code": "function quickSort(arr) {\n  if (arr.length <= 1) { // Base case: already sorted\n    return arr;\n  }\n\n  const pivotIndex = arr.length - 1; // Choose last element as pivot\n  const pivot = arr[pivotIndex];\n  const leftArr = [];\n  const rightArr = [];\n\n  for (let i = 0; i < pivotIndex; i++) { // Partitioning\n    if (arr[i] < pivot) {\n      leftArr.push(arr[i]); // Elements less than pivot to left\n    } else {\n      rightArr.push(arr[i]); // Elements >= pivot to right\n    }\n  }\n\n  return [...quickSort(leftArr), pivot, ...quickSort(rightArr)]; // Recursive calls and combine\n}",
          "explanation": "Implementation:\n- `if (arr.length <= 1) return arr`: Base case for recursion.\n- `pivotIndex = arr.length - 1`, `pivot = arr[pivotIndex]`: Choose last element as pivot.\n- `leftArr = [], rightArr = []`: Initialize sub-arrays for partitioning.\n- `for (i < pivotIndex)`: Partitioning loop.\n  - `if (arr[i] < pivot)`: Push to `leftArr` if smaller.\n  - `else`: Push to `rightArr` otherwise.\n- `return [...quickSort(leftArr), pivot, ...quickSort(rightArr)]`: Recursive calls on sub-arrays and combine with pivot."
        }
      ]
    },
    {
      "id": "pq100",
      "title": "Implement Merge Sort Algorithm in JavaScript",
      "category": "Algorithms, Sorting, Divide and Conquer",
      "difficulty": "Hard",
      "description": "Implement the Merge Sort algorithm in JavaScript to sort an array of numbers in ascending order.",
      "methodology": {
        "approach": "Divide and Conquer with Merging",
        "explanation": "Merge Sort is a divide and conquer algorithm. It divides the unsorted list into n sublists, each containing one element (a list of one element is considered sorted). Then, it repeatedly merges sublists to produce new sorted sublists until there is only one sorted list remaining. \n\n1. Create a function `mergeSort(arr)` that takes an array `arr` of numbers.\n2. Base case: If the array has 0 or 1 element, it's already sorted, return the array.\n3. Divide: Find the middle index of the array. Divide the array into two halves: `leftArr` (from start to middle) and `rightArr` (from middle to end).\n4. Recursively call `mergeSort` on `leftArr` and `rightArr` to sort the two halves.\n5. Merge: Implement a `merge(leftSorted, rightSorted)` function that takes two sorted arrays and merges them into a single sorted array.\n   - Initialize an empty array `mergedArray`.\n   - Initialize pointers `i = 0` for `leftSorted` and `j = 0` for `rightSorted`.\n   - While `i` is within bounds of `leftSorted` AND `j` is within bounds of `rightSorted`:\n     - Compare `leftSorted[i]` and `rightSorted[j]`.\n     - If `leftSorted[i] <= rightSorted[j]`, push `leftSorted[i]` to `mergedArray` and increment `i`.\n     - Else, push `rightSorted[j]` to `mergedArray` and increment `j`.\n   - After the while loop, one of the arrays might have remaining elements. Append any remaining elements from `leftSorted` (from index `i` onwards) and `rightSorted` (from index `j` onwards) to `mergedArray`.\n   - Return `mergedArray`.\n6. Return the result of merging the sorted `leftArr` and `rightArr`: `return merge(sortedLeft, sortedRight)`.",
        "timeComplexity": "O(n log n) in all cases (worst, average, best), where n is the number of elements. Merge Sort provides consistent performance regardless of input array order.",
        "spaceComplexity": "O(n) - Merge Sort is not in-place. It requires extra space for creating sub-arrays and the merged array during the merge process.",
        "javascriptSpecific": false
      },
      "examples": [
        {
          "input": "arr = [12, 11, 13, 5, 6, 7]",
          "output": "[5, 6, 7, 11, 12, 13]",
          "explanation": "Merge Sort sorts the array in ascending order."
        },
        {
          "input": "arr = [-4, 2, 0, -1, 3]",
          "output": "[-4, -1, 0, 2, 3]",
          "explanation": "Merge Sort sorts negative and positive numbers."
        }
      ],
      "solutions": [
        {
          "approach": "Recursive Merge Sort",
          "code": "function mergeSort(arr) {\n  if (arr.length <= 1) { // Base case: already sorted\n    return arr;\n  }\n\n  const middleIndex = Math.floor(arr.length / 2); // Find middle index\n  const leftArr = arr.slice(0, middleIndex);     // Divide into left half\n  const rightArr = arr.slice(middleIndex);      // Divide into right half\n\n  const sortedLeft = mergeSort(leftArr);   // Recursively sort left half\n  const sortedRight = mergeSort(rightArr);  // Recursively sort right half\n\n  return merge(sortedLeft, sortedRight); // Merge sorted halves\n}\n\nfunction merge(leftSorted, rightSorted) {\n  const mergedArray = [];\n  let i = 0;\n  let j = 0;\n\n  while (i < leftSorted.length && j < rightSorted.length) {\n    if (leftSorted[i] <= rightSorted[j]) {\n      mergedArray.push(leftSorted[i]);\n      i++;\n    } else {\n      mergedArray.push(rightSorted[j]);\n      j++;\n    }\n  }\n\n  // Append remaining elements (if any)\n  return mergedArray.concat(leftSorted.slice(i)).concat(rightSorted.slice(j));\n}",
          "explanation": "Implementation:\n- `mergeSort(arr)`:\n  - `if (arr.length <= 1) return arr`: Base case.\n  - `middleIndex`, `leftArr`, `rightArr`: Divide array.\n  - `sortedLeft = mergeSort(leftArr)`, `sortedRight = mergeSort(rightArr)`: Recursive calls.\n  - `return merge(sortedLeft, sortedRight)`: Merge sorted halves.\n- `merge(leftSorted, rightSorted)`:\n  - `mergedArray = []`, `i = 0`, `j = 0`: Initialize merged array and pointers.\n  - `while (i < leftSorted.length && j < rightSorted.length)`: Merge loop.\n    - Compare `leftSorted[i]` and `rightSorted[j]`, push smaller element to `mergedArray`, increment pointer.\n  - `return mergedArray.concat(...)`: Append remaining elements from either array (if any)."
        }
      ]
    },
    {
      "id": "pq101",
      "title": "Implement a JavaScript Generator Function for Fibonacci Sequence",
      "category": "JavaScript, Generators, Iterators",
      "difficulty": "Medium",
      "description": "Write a JavaScript generator function `fibonacciGenerator()` that yields the Fibonacci sequence numbers indefinitely. Each time `next()` is called on the generator, it should yield the next Fibonacci number.",
      "methodology": {
        "approach": "Generator Function with `yield`",
        "explanation": "JavaScript generator functions allow you to define an iterable sequence of values lazily. For the Fibonacci sequence, we can use `yield` to produce each number on demand. The generator will maintain its state between calls to `next()` to continue the sequence.\n\n1. Create a generator function `fibonacciGenerator()` using the `function*` syntax.\n2. Initialize two variables `a = 0` and `b = 1` to represent the first two Fibonacci numbers.\n3. Use an infinite `while (true)` loop to generate Fibonacci numbers indefinitely.\n4. Inside the loop:\n   - `yield a;` - Yield the current Fibonacci number `a`.\n   - Update `a` and `b` to the next Fibonacci numbers: `[a, b] = [b, a + b];` (destructuring assignment for simultaneous update).\n\nEach time `next()` is called on the generator, it executes the code until the `yield` statement, returns the yielded value, and pauses execution until the next `next()` call.",
        "timeComplexity": "O(1) for each `next()` call. Generating each Fibonacci number is constant time after the initial setup.",
        "spaceComplexity": "O(1) - constant space, as the generator only needs to store a few variables (a, b).",
        "javascriptSpecific": true
      },
      "examples": [
        {
          "input": "const fibGen = fibonacciGenerator(); fibGen.next().value; fibGen.next().value; fibGen.next().value;",
          "output": "0, 1, 1 (for the three next() calls)",
          "explanation": "The generator should yield the Fibonacci sequence numbers: 0, 1, 1, 2, 3, 5, 8, ... on successive calls to `next()`."
        }
      ],
      "solutions": [
        {
          "approach": "Generator with Infinite Loop and Yield",
          "code": "function* fibonacciGenerator() {\n  let a = 0;\n  let b = 1;\n\n  while (true) { // Infinite generator\n    yield a;      // Yield current Fibonacci number\n    [a, b] = [b, a + b]; // Update for next number\n  }\n}",
          "explanation": "Implementation:\n- `function* fibonacciGenerator()`: Defines a generator function.\n- `let a = 0, b = 1`: Initialize Fibonacci sequence starting values.\n- `while (true)`: Infinite loop to generate sequence indefinitely.\n- `yield a`: Yields the current Fibonacci number `a`.\n- `[a, b] = [b, a + b]`: Updates `a` and `b` to the next values in the sequence using destructuring assignment."
        }
      ]
    },
    {
      "id": "pq102",
      "title": "Implement a Function to Check if a String is a Valid Anagram of a Palindrome",
      "category": "Strings, Palindromes, Hash Tables",
      "difficulty": "Medium",
      "description": "Write a JavaScript function `isPalindromeAnagram(str)` that determines if a given string can be rearranged to form a palindrome. A string can be a permutation of a palindrome if, at most, one character appears an odd number of times (for strings of even length, all characters must appear an even number of times).",
      "methodology": {
        "approach": "Character Frequency Counting and Odd Count Check",
        "explanation": "To check if a string can be an anagram of a palindrome, we need to count the frequency of each character. In a palindrome anagram, at most one character can have an odd count (this applies to palindromes of odd length; for even length palindromes, all character counts must be even).\n\n1. Create a function `isPalindromeAnagram(str)`.\n2. Clean and normalize the input string `str` (e.g., remove spaces, convert to lowercase) to only consider alphabetic characters and ignore case.\n3. Create a character frequency map (object or Map) `charCounts`.\n4. Iterate through the cleaned string and count the frequency of each character in `charCounts`.\n5. Initialize a variable `oddCount` to 0.\n6. Iterate through the values (counts) in `charCounts`.\n7. For each count, check if it's odd. If yes, increment `oddCount`.\n8. After checking all counts, if `oddCount` is less than or equal to 1, return `true` (can be a palindrome anagram). Otherwise, return `false`.",
        "timeComplexity": "O(n), where n is the length of the string. We iterate through the string to count frequencies and then iterate through the character counts (at most alphabet size, which is constant).",
        "spaceComplexity": "O(1) - constant space, as the character map size is limited by the alphabet size.",
        "javascriptSpecific": false
      },
      "examples": [
        {
          "input": "str = \"tact coa\"",
          "output": "true",
          "explanation": "\"tact coa\" can be rearranged to form \"tacocat\", which is a palindrome."
        },
        {
          "input": "str = \"aabbccdde\"",
          "output": "true",
          "explanation": "\"aabbccdde\" can be rearranged to form \"edccbbaade\" (or similar palindromes)."
        },
        {
          "input": "str = \"aabbccddee\"",
          "output": "false",
          "explanation": "\"aabbccddee\" cannot be rearranged to form a palindrome because more than one character ('a', 'b', 'c', 'd', 'e') appears odd number of times."
        }
      ],
      "solutions": [
        {
          "approach": "Character Frequency Count and Odd Count Check",
          "code": "function isPalindromeAnagram(str) {\n  const cleanedStr = str.replace(/[^a-zA-Z]/g, '').toLowerCase(); // Clean string\n  const charCounts = {};\n\n  for (let char of cleanedStr) {\n    charCounts[char] = (charCounts[char] || 0) + 1; // Count character frequencies\n  }\n\n  let oddCount = 0;\n  for (let char in charCounts) {\n    if (charCounts[char] % 2 !== 0) {\n      oddCount++; // Count odd frequencies\n    }\n  }\n\n  return oddCount <= 1; // Palindrome anagram if at most one odd count\n}",
          "explanation": "Implementation:\n- `cleanedStr`: Clean input string (remove non-alphabetic, lowercase).\n- `charCounts = {}`: Initialize character frequency map.\n- Loop 1 (cleanedStr): Count character frequencies in `charCounts`.\n- `oddCount = 0`: Initialize odd count tracker.\n- Loop 2 (charCounts): Iterate through character counts.\n  - `if (charCounts[char] % 2 !== 0)`: If count is odd, increment `oddCount`.\n- `return oddCount <= 1`: Return `true` if `oddCount` is at most 1, `false` otherwise."
        }
      ]
    },
    {
      "id": "pq103",
      "title": "Implement a Function to Find the First Unique Element in an Array",
      "category": "Arrays, Hash Tables",
      "difficulty": "Easy",
      "description": "Write a JavaScript function `firstUniqueElement(arr)` that finds and returns the first unique element in a given array. If there are no unique elements, return `undefined`.",
      "methodology": {
        "approach": "Frequency Counting and Order-Preserving Iteration",
        "explanation": "To find the *first* unique element while preserving order, we can count element frequencies and then iterate through the array again to find the first element with a frequency of 1.\n\n1. Create a function `firstUniqueElement(arr)`.\n2. Create an element frequency map (object or Map) `elementCounts`.\n3. Iterate through the input array `arr` and count the frequency of each element in `elementCounts`.\n4. Iterate through the array `arr` again in its original order.\n5. For each element, check its count in `elementCounts`. If the count is 1, return this element as it's the first unique element.\n6. If the loop completes without finding any element with frequency 1, return `undefined`.",
        "timeComplexity": "O(n), where n is the length of the array. We iterate through the array twice.",
        "spaceComplexity": "O(n) in the worst case for frequency map storage if all elements are unique (though practically limited by the range of possible element values if it's known). In many cases closer to O(u) where u is number of unique elements.",
        "javascriptSpecific": true
      },
      "examples": [
        {
          "input": "arr = [1, 2, 2, 3, 4, 4, 5]",
          "output": "1",
          "explanation": "1 is the first element that appears only once in the array."
        },
        {
          "input": "arr = ['a', 'b', 'a', 'c', 'd', 'b']",
          "output": "'c'",
          "explanation": "'c' is the first unique element in the string array."
        },
        {
          "input": "arr = [7, 7, 7, 7]",
          "output": "undefined",
          "explanation": "No unique elements in the array, so undefined is returned."
        }
      ],
      "solutions": [
        {
          "approach": "Frequency Counting and Two-Pass Iteration",
          "code": "function firstUniqueElement(arr) {\n  const elementCounts = {};\n\n  for (let element of arr) {\n    elementCounts[element] = (elementCounts[element] || 0) + 1; // Count element frequencies\n  }\n\n  for (let element of arr) { // Iterate again to find first unique\n    if (elementCounts[element] === 1) {\n      return element; // Return first unique element\n    }\n  }\n\n  return undefined; // No unique element found\n}",
          "explanation": "Implementation:\n- `elementCounts = {}`: Initialize element frequency map.\n- Loop 1 (arr): Count frequencies of each element in `elementCounts`.\n- Loop 2 (arr): Iterate through array again in original order.\n- `if (elementCounts[element] === 1)`: Check if count is 1 for current element.\n  - If yes, return `element` (first unique element found).\n- Return `undefined` if loop finishes without finding a unique element."
        }
      ]
    },
    {
      "id": "pq104",
      "title": "Implement a Function to Find the Kth Largest Element in an Array",
      "category": "Arrays, Sorting, QuickSelect",
      "difficulty": "Medium",
      "description": "Write a JavaScript function `findKthLargest(nums, k)` that finds the kth largest element in an unsorted array `nums`. Note that it is the kth largest element in sorted order, not the kth distinct element.",
      "methodology": {
        "approach": "QuickSelect Algorithm (Partition-Based)",
        "explanation": "QuickSelect is a selection algorithm to find the kth smallest/largest element in an unordered list. It's related to QuickSort but only partially sorts the array to find the kth element, making it more efficient than full sorting.\n\n1. Create a function `findKthLargest(nums, k)`.\n2. Implement a helper function `quickSelect(arr, low, high, k)` which performs the selection recursively:\n   - Base case: If `low === high`, return `arr[low]` (single element range).\n   - Partition: Choose a pivot (e.g., last element `arr[high]`). Partition the array around the pivot such that elements smaller than pivot are to the left and larger elements are to the right. Get the pivot's final sorted position `pivotIndex` after partitioning.\n   - Count elements to the right of pivot (larger elements): `count = high - pivotIndex + 1`.\n   - If `count === k`, the pivot is the kth largest, return `pivot`.\n   - If `count > k`, the kth largest is in the right partition (larger elements), recursively call `quickSelect(arr, pivotIndex + 1, high, k)`.\n   - If `count < k`, the kth largest is in the left partition (smaller elements), recursively call `quickSelect(arr, low, pivotIndex - 1, k - count)` (adjust k for the smaller subproblem).\n3. Initial call to `quickSelect` from `findKthLargest`: `return quickSelect(nums, 0, nums.length - 1, k)`.",
        "timeComplexity": "O(n) on average case, where n is the length of the array. Worst case O(nÂ²) (similar to QuickSort's worst case, skewed partitions), but randomized pivot selection can mitigate this in practice. O(n) is significantly better than sorting (O(n log n)).",
        "spaceComplexity": "O(log n) on average due to recursive call stack (for balanced partitions). Worst case O(n) in skewed partition scenarios.",
        "javascriptSpecific": false
      },
      "examples": [
        {
          "input": "nums = [3, 2, 1, 5, 6, 4], k = 2",
          "output": "5",
          "explanation": "The 2nd largest element in [3, 2, 1, 5, 6, 4] is 5."
        },
        {
          "input": "nums = [3, 2, 3, 1, 2, 4, 5, 5, 6], k = 4",
          "output": "4",
          "explanation": "The 4th largest element is 4."
        }
      ],
      "solutions": [
        {
          "approach": "QuickSelect Algorithm",
          "code": "function findKthLargest(nums, k) {\n  function quickSelect(arr, low, high, k) {\n    if (low === high) return arr[low]; // Base case\n\n    const pivot = arr[high]; // Choose last element as pivot\n    let pivotIndex = low;\n\n    for (let j = low; j < high; j++) { // Partitioning\n      if (arr[j] <= pivot) { // Elements <= pivot to left\n        [arr[pivotIndex], arr[j]] = [arr[j], arr[pivotIndex]]; // Swap\n        pivotIndex++;\n      }\n    }\n    [arr[pivotIndex], arr[high]] = [arr[high], arr[pivotIndex]]; // Place pivot in correct position\n\n    const count = high - pivotIndex + 1; // Count elements >= pivot\n\n    if (count === k) return pivot; // Pivot is kth largest\n    if (count > k) return quickSelect(arr, pivotIndex + 1, high, k); // Search right partition\n    return quickSelect(arr, low, pivotIndex - 1, k - count); // Search left partition\n  }\n\n  return quickSelect(nums, 0, nums.length - 1, nums.length - k + 1); // Kth largest is (n-k+1)th smallest\n}",
          "explanation": "Implementation:\n- `findKthLargest(nums, k)`: Main function, calls `quickSelect`.\n- `quickSelect(arr, low, high, k)`: Recursive function.\n  - Base case: `if (low === high) return arr[low]`.\n  - Pivot selection: `pivot = arr[high]`.\n  - Partitioning: Loop and swap elements around pivot.\n  - `count = high - pivotIndex + 1`: Count elements >= pivot (right partition size).\n  - `if (count === k) return pivot`: Pivot is kth largest.\n  - `if (count > k)`: Recursive call on right partition.\n  - `else`: Recursive call on left partition, adjust `k`.\n- Initial call: `return quickSelect(nums, 0, nums.length - 1, nums.length - k + 1)` (finds (n-k+1)th smallest which is kth largest)."
        }
      ]
    },
    {
      "id": "pq105",
      "title": "Implement a Function to Check if a String is a Rotation of Another",
      "category": "Strings, Algorithms",
      "difficulty": "Medium",
      "description": "Write a JavaScript function `isStringRotation(s1, s2)` to determine if `s2` is a rotation of `s1`. For example, 'waterbottle' is a rotation of 'erbottlewat'. Assume you have a helper function `isSubstring(s1, s2)` which checks if `s2` is a substring of `s1`.",
      "methodology": {
        "approach": "String Concatenation and Substring Check",
        "explanation": "A string `s2` is a rotation of `s1` if `s2` is a substring of `s1` concatenated with itself. For example, if `s1 = 'waterbottle'`, then `s1s1 = 'waterbottlewaterbottle'`. Rotations of `s1` like 'erbottlewat', 'bottlewater', etc., are all substrings of `s1s1`. If `s2` is a rotation of `s1`, it must also have the same length as `s1`.\n\n1. Create a function `isStringRotation(s1, s2)`.\n2. Check if the lengths of `s1` and `s2` are equal. If not, `s2` cannot be a rotation of `s1`, return `false`.\n3. Concatenate `s1` with itself: `s1s1 = s1 + s1`.\n4. Use the provided `isSubstring(s1s1, s2)` helper function to check if `s2` is a substring of `s1s1`.\n5. Return the result of `isSubstring(s1s1, s2)`.",
        "timeComplexity": "O(n) assuming `isSubstring` function is O(n+m) or better (e.g., using efficient string searching algorithms like Knuth-Morris-Pratt (KMP) where m is length of s2 and n is length of s1s1, and since length of s1s1 is 2n, it becomes O(n)). If naive substring search is used, it could be O(n*m) which in this case becomes O(nÂ²).",
        "spaceComplexity": "O(n) to store the concatenated string `s1s1`.",
        "javascriptSpecific": false
      },
      "examples": [
        {
          "input": "s1 = \"waterbottle\", s2 = \"erbottlewat\"",
          "output": "true",
          "explanation": "\"erbottlewat\" is a rotation of \"waterbottle\"."
        },
        {
          "input": "s1 = \"waterbottle\", s2 = \"waterboottle\"",
          "output": "false",
          "explanation": "\"waterboottle\" is not a rotation of \"waterbottle\"."
        },
        {
          "input": "s1 = \"abc\", s2 = \"bca\"",
          "output": "true",
          "explanation": "\"bca\" is a rotation of \"abc\"."
        }
      ],
      "solutions": [
        {
          "approach": "Concatenation and Substring Check",
          "code": "function isStringRotation(s1, s2) {\n  if (s1.length !== s2.length) {\n    return false; // Rotations must have same length\n  }\n\n  const s1s1 = s1 + s1; // Concatenate s1 with itself\n  return isSubstring(s1s1, s2); // Check if s2 is substring of s1s1\n}\n\n// Assume isSubstring function is already implemented (e.g., using String.prototype.includes for simplicity here)\nfunction isSubstring(haystack, needle) {\n  return haystack.includes(needle); // Using includes as a placeholder for actual substring check\n}",
          "explanation": "Implementation:\n- Length check: `if (s1.length !== s2.length) return false`.\n- `s1s1 = s1 + s1`: Concatenate `s1` with itself.\n- `return isSubstring(s1s1, s2)`: Use `isSubstring` helper to check if `s2` is substring of `s1s1`.\n- `isSubstring(haystack, needle)` (placeholder): For simplicity, using `String.prototype.includes` as a stand-in for a real substring check function. In a real interview setting, you might be expected to implement `isSubstring` as well (e.g., using KMP or naive approach)."
        }
      ]
    },
    {
      "id": "pq106",
      "title": "Implement a Function to Find All Permutations of a String",
      "category": "Strings, Recursion, Backtracking",
      "difficulty": "Hard",
      "description": "Write a JavaScript function `stringPermutations(str)` that generates and returns all possible permutations of a given string `str`. Return the permutations as an array of strings.",
      "methodology": {
        "approach": "Recursion and Backtracking",
        "explanation": "Generating all permutations of a string is a classic backtracking problem. We can use recursion to explore all possible arrangements of characters.\n\n1. Create a function `stringPermutations(str)` that takes a string `str`.\n2. Base case: If the string has length 0 or 1, return the string itself in an array (or an array containing an empty string for empty input).\n3. Recursive step: \n   - Initialize an empty array `permutations` to store the generated permutations.\n   - Iterate through the characters of the string.\n   - For each character at index `i`:\n     - Fix the character at the current position.\n     - Create a substring `remainingChars` by removing the character at index `i` from the original string.\n     - Recursively call `stringPermutations` on `remainingChars` to get permutations of the rest of the string.\n     - For each permutation returned from the recursive call, prepend the current character to it and add the resulting permutation to the `permutations` array.\n4. Return the `permutations` array.",
        "timeComplexity": "O(n*n!), where n is the length of the string. There are n! permutations, and for each permutation, we might spend O(n) time to construct it (string concatenation, array operations).",
        "spaceComplexity": "O(n*n!) to store all n! permutations, each of length n. Recursion call stack depth can be up to O(n) in the worst case.",
        "javascriptSpecific": false
      },
      "examples": [
        {
          "input": "str = \"abc\"",
          "output": "[\"abc\", \"acb\", \"bac\", \"bca\", \"cab\", \"cba\"]",
          "explanation": "All 6 permutations of \"abc\" are generated."
        },
        {
          "input": "str = \"aab\"",
          "output": "[\"aab\", \"aba\", \"baa\", \"aba\", \"baa\", \"aab\"] (or similar order, duplicates allowed in basic implementation)",
          "explanation": "For strings with duplicate characters, basic implementation will generate duplicate permutations. For unique permutations, additional logic to handle duplicates is needed."
        },
        {
          "input": "str = \"\"",
          "output": "[\"\"]",
          "explanation": "Permutation of an empty string is an empty string itself."
        }
      ],
      "solutions": [
        {
          "approach": "Recursive Backtracking",
          "code": "function stringPermutations(str) {\n  if (str.length <= 1) { // Base case\n    return [str];\n  }\n\n  const permutations = [];\n  for (let i = 0; i < str.length; i++) {\n    const currentChar = str[i];\n    const remainingChars = str.slice(0, i) + str.slice(i + 1); // String without currentChar\n    const subPermutations = stringPermutations(remainingChars); // Recursive call\n\n    for (let subPermutation of subPermutations) {\n      permutations.push(currentChar + subPermutation); // Prepend currentChar to sub-permutations\n    }\n  }\n  return permutations;\n}",
          "explanation": "Implementation:\n- `stringPermutations(str)`: Recursive function.\n- `if (str.length <= 1) return [str]`: Base case for recursion.\n- `permutations = []`: Initialize array to store permutations.\n- `for (i < str.length)`: Loop through characters in `str`.\n  - `currentChar = str[i]`: Fix current character.\n  - `remainingChars`: Create substring without `currentChar`.\n  - `subPermutations = stringPermutations(remainingChars)`: Recursive call for remaining chars.\n  - Inner loop `for (subPermutation of subPermutations)`: Iterate through sub-permutations.\n    - `permutations.push(currentChar + subPermutation)`: Prepend `currentChar` and add to `permutations`.\n- Return `permutations`."
        }
      ]
    },
    {
      "id": "pq107",
      "title": "Implement a Function to Find All Subsets of a Set",
      "category": "Arrays, Recursion, Backtracking",
      "difficulty": "Medium",
      "description": "Write a JavaScript function `getSubsets(nums)` that generates and returns all possible subsets (including the empty subset) of a given set of numbers `nums`. Return the subsets as an array of arrays.",
      "methodology": {
        "approach": "Recursion and Backtracking (Power Set Generation)",
        "explanation": "Generating all subsets of a set (power set) can be done using recursion. For each element, we have two choices: either include it in the current subset or exclude it. We explore both choices recursively.\n\n1. Create a function `getSubsets(nums)` that takes an array `nums` (representing the set).\n2. Initialize an empty array `subsets` to store all generated subsets. Start with adding an empty subset `[]` to `subsets` (as empty set is always a subset).\n3. Implement a recursive helper function `generateSubsets(index, currentSubset)`:\n   - Base case: If `index` reaches the end of `nums` array, it means we have processed all elements. Return.\n   - Recursive step:\n     - Include current element: Create a new subset by adding `nums[index]` to `currentSubset`. Add this new subset to the `subsets` array. Recursively call `generateSubsets(index + 1, newSubset)` to explore subsets including the current element and subsequent elements.\n     - Exclude current element: Recursively call `generateSubsets(index + 1, currentSubset)` to explore subsets excluding the current element and considering subsequent elements with the *same* `currentSubset` (without adding current element).\n4. Initiate the recursive process by calling `generateSubsets(0, [])` starting from the first element (index 0) and an initially empty subset `[]`.\n5. Return the `subsets` array.",
        "timeComplexity": "O(2^n * n), where n is the number of elements in `nums`. There are 2^n subsets in total, and for each subset, we might spend O(n) time to create and add it to the result list (array copy operations in some implementations).",
        "spaceComplexity": "O(2^n * n) to store all 2^n subsets, each of average length n/2. Recursion call stack depth can be up to O(n).",
        "javascriptSpecific": false
      },
      "examples": [
        {
          "input": "nums = [1, 2, 3]",
          "output": "[[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]]",
          "explanation": "All 8 subsets of {1, 2, 3} are generated (including the empty set and the set itself)."
        },
        {
          "input": "nums = [1, 2]",
          "output": "[[], [1], [2], [1, 2]]",
          "explanation": "All 4 subsets of {1, 2} are generated."
        },
        {
          "input": "nums = []",
          "output": "[[]]",
          "explanation": "Subset of an empty set is just the empty set itself."
        }
      ],
      "solutions": [
        {
          "approach": "Recursive Backtracking for Subset Generation",
          "code": "function getSubsets(nums) {\n  const subsets = [[]]; // Start with empty subset\n\n  function generateSubsetsRecursive(index, currentSubset) {\n    if (index === nums.length) { // Base case: processed all elements\n      return;\n    }\n\n    // Include current element\n    const includeSubset = [...currentSubset, nums[index]]; // Create new subset by including current num\n    subsets.push(includeSubset); // Add subset to result\n    generateSubsetsRecursive(index + 1, includeSubset); // Recurse including current element\n\n    // Exclude current element\n    generateSubsetsRecursive(index + 1, currentSubset); // Recurse excluding current element (same subset)\n  }\n\n  generateSubsetsRecursive(0, []); // Start recursion\n  return subsets;\n}",
          "explanation": "Implementation:\n- `getSubsets(nums)`: Main function.\n- `subsets = [[]]`: Initialize `subsets` with empty set.\n- `generateSubsetsRecursive(index, currentSubset)`: Recursive helper function.\n  - Base case: `if (index === nums.length) return` (all elements processed).\n  - Include step:\n    - `includeSubset = [...currentSubset, nums[index]]`: Create new subset with current element.\n    - `subsets.push(includeSubset)`: Add to `subsets`.\n    - Recursive call `generateSubsetsRecursive(index + 1, includeSubset)`.\n  - Exclude step:\n    - Recursive call `generateSubsetsRecursive(index + 1, currentSubset)` (same subset, next index).\n- `generateSubsetsRecursive(0, [])`: Start recursion from index 0, empty subset.\n- Return `subsets`."
        }
      ]
    },
     {
      "id": "pq108",
      "title": "Implement a Function to Calculate the Power of a Number (Exponentiation)",
      "category": "Algorithms, Math, Recursion",
      "difficulty": "Medium",
      "description": "Write a JavaScript function `power(base, exponent)` to calculate `base` raised to the power of `exponent` (base^exponent). Handle both positive and negative exponents, and consider efficiency for large exponents.",
      "methodology": {
        "approach": "Recursive and Iterative Approaches, Optimization for Efficiency",
        "explanation": "Exponentiation can be implemented recursively or iteratively. For efficiency with large exponents, we can use the exponentiation by squaring method, which significantly reduces the number of multiplications.\n\n1. Recursive Approach (Basic):\n   - Base case: If `exponent` is 0, return 1 (base^0 = 1).\n   - If `exponent` is 1, return `base` (base^1 = base).\n   - If `exponent` is positive, return `base * power(base, exponent - 1)`.\n   - If `exponent` is negative, return `1 / power(base, -exponent)`.\n\n2. Iterative Approach (Basic):\n   - Initialize `result = 1`.\n   - If `exponent` is positive, loop `exponent` times, multiplying `result` by `base` in each iteration.\n   - If `exponent` is negative, calculate power for positive exponent `-exponent` and return `1 / result`.\n\n3. Optimized Recursive Approach (Exponentiation by Squaring):\n   - Base cases: `exponent === 0`, `exponent === 1` (same as basic recursion).\n   - If `exponent` is even, calculate `halfPower = power(base, exponent / 2)` and return `halfPower * halfPower` (squaring).\n   - If `exponent` is odd, calculate `halfPower = power(base, Math.floor(exponent / 2))` and return `base * halfPower * halfPower`.\n   - Handle negative exponents as in basic approaches.",
        "timeComplexity": "O(exponent) for basic recursive and iterative approaches. O(log exponent) for optimized exponentiation by squaring (recursive or iterative).",
        "spaceComplexity": "O(exponent) for basic recursive approach due to call stack. O(log exponent) for optimized recursive approach (call stack). O(1) for iterative approaches (both basic and optimized).",
        "javascriptSpecific": false
      },
      "examples": [
        {
          "input": "power(2, 3)",
          "output": "8",
          "explanation": "2^3 = 8"
        },
        {
          "input": "power(3, 0)",
          "output": "1",
          "explanation": "3^0 = 1"
        },
        {
          "input": "power(2, -2)",
          "output": "0.25",
          "explanation": "2^-2 = 1 / (2^2) = 0.25"
        }
      ],
      "solutions": [
        {
          "approach": "Recursive (Basic)",
          "code": "function powerRecursiveBasic(base, exponent) {\n  if (exponent === 0) return 1; // Base case: base^0 = 1\n  if (exponent === 1) return base; // Base case: base^1 = base\n\n  if (exponent > 0) return base * powerRecursiveBasic(base, exponent - 1); // Positive exponent\n  return 1 / powerRecursiveBasic(base, -exponent); // Negative exponent\n}",
          "explanation": "Basic recursive implementation:\n- Base cases: `exponent === 0`, `exponent === 1`.\n- Recursive case (positive exponent): `base * powerRecursiveBasic(base, exponent - 1)`.\n- Handle negative exponent: `1 / powerRecursiveBasic(base, -exponent)`."
        },
        {
          "approach": "Iterative (Basic)",
          "code": "function powerIterativeBasic(base, exponent) {\n  let result = 1;\n  const isNegativeExponent = exponent < 0;\n  const absExponent = Math.abs(exponent);\n\n  for (let i = 0; i < absExponent; i++) { // Iterate exponent times\n    result *= base;\n  }\n\n  return isNegativeExponent ? 1 / result : result; // Handle negative exponent\n}",
          "explanation": "Basic iterative implementation:\n- `result = 1`: Initialize result.\n- `isNegativeExponent`, `absExponent`: Handle negative exponent.\n- `for` loop: Iterate `absExponent` times.\n  - `result *= base`: Multiply result by base.\n- Return `isNegativeExponent ? 1 / result : result`: Handle sign for final result."
        },
        {
          "approach": "Recursive (Exponentiation by Squaring - Optimized)",
          "code": "function powerRecursiveOptimized(base, exponent) {\n  if (exponent === 0) return 1; // Base case\n  if (exponent === 1) return base; // Base case\n\n  if (exponent < 0) return 1 / powerRecursiveOptimized(base, -exponent); // Negative exponent\n\n  if (exponent % 2 === 0) { // Even exponent\n    const halfPower = powerRecursiveOptimized(base, exponent / 2); // Calculate power of half exponent\n    return halfPower * halfPower; // Square the result\n  } else { // Odd exponent\n    const halfPower = powerRecursiveOptimized(base, Math.floor(exponent / 2));\n    return base * halfPower * halfPower; // base * (base^(exponent/2))^2\n  }\n}",
          "explanation": "Optimized recursive (exponentiation by squaring):\n- Base cases: `exponent === 0`, `exponent === 1`.\n- Handle negative exponent.\n- `if (exponent % 2 === 0)` (even exponent):\n  - `halfPower = powerRecursiveOptimized(base, exponent / 2)`: Recursive call for half exponent.\n  - `return halfPower * halfPower`: Square the result.\n- `else` (odd exponent):\n  - `halfPower = powerRecursiveOptimized(base, Math.floor(exponent / 2))`: Recursive call for floor of half exponent.\n  - `return base * halfPower * halfPower`: base * (base^(exponent/2))^2."
        }
      ]
    }
  ]
}