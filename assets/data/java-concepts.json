{
   "concepts": [
    {
      "id": "java-core-basics",
      "title": "Java Core Basics",
      "description": "Fundamental Java concepts: syntax, data types, operators, control flow, and basic program structure.",
      "difficulty": "beginner",
      "category": "core-java",
      "explanation": "Java's foundation lies in its core basics. Understanding syntax, data types (primitive and reference), operators (arithmetic, logical, bitwise), and control flow (loops, conditionals, switch statements) is crucial. Java is statically-typed, enforcing type checking at compile time, which helps in early error detection.  Every Java program starts with a class definition and a `main` method, the entry point for execution.  Comments (`//` and `/* ... */`) are used for code documentation.  Variables must be declared with a type before use. Java follows object-oriented principles, but these basic elements are the building blocks for more complex OOP concepts.  Understanding these basics is essential for any Java developer.",
      "example": "// Basic Java Program Structure\npublic class BasicExample {\n    public static void main(String[] args) {\n        // Variable declaration and initialization\n        int age = 30;\n        String name = \"John Doe\";\n        boolean isAdult = age >= 18;\n\n        // Control flow - if-else statement\n        if (isAdult) {\n            System.out.println(name + \" is an adult.\");\n        } else {\n            System.out.println(name + \" is not an adult.\");\n        }\n\n        // Loop - for loop\n        for (int i = 0; i < 5; i++) {\n            System.out.println(\"Iteration: \" + i);\n        }\n    }\n}",
      "keyPoints": [
        "Java syntax is similar to C and C++ but simplified.",
        "Strongly typed language: type checking at compile time.",
        "Primitive data types: `byte`, `short`, `int`, `long`, `float`, `double`, `char`, `boolean`.",
        "Reference data types: Objects, Arrays, Strings.",
        "Operators: Arithmetic, assignment, comparison, logical, bitwise, ternary.",
        "Control flow statements: `if-else`, `switch`, `for`, `while`, `do-while`, `break`, `continue`.",
        "Every Java program needs a `main` method as the entry point: `public static void main(String[] args)`."
      ],
      "quiz": [
        {
          "question": "Which of the following is NOT a primitive data type in Java?",
          "options": ["int", "boolean", "String", "char"],
          "correctAnswer": 2
        },
        {
          "question": "What is the entry point of a Java application?",
          "options": ["`start()` method", "`main()` method", "The first class defined", "The constructor of the main class"],
          "correctAnswer": 1
        },
        {
          "question": "What type of language is Java?",
          "options": ["Dynamically typed", "Weakly typed", "Statically typed", "Loosely typed"],
          "correctAnswer": 2
        }
      ],
      "interactiveExamples": [
        {
          "title": "Data Types and Operators",
          "code": "// Exploring Data Types and Operators\npublic class DataTypesOperators {\n    public static void main(String[] args) {\n        int num1 = 10;\n        int num2 = 3;\n\n        // Arithmetic Operators\n        System.out.println(\"Sum: \" + (num1 + num2));\n        System.out.println(\"Difference: \" + (num1 - num2));\n        System.out.println(\"Product: \" + (num1 * num2));\n        System.out.println(\"Quotient: \" + (num1 / num2)); // Integer division\n        System.out.println(\"Remainder: \" + (num1 % num2));\n\n        // Logical Operators\n        boolean condition1 = true;\n        boolean condition2 = false;\n        System.out.println(\"AND: \" + (condition1 && condition2));\n        System.out.println(\"OR: \" + (condition1 || condition2));\n        System.out.println(\"NOT condition1: \" + (!condition1));\n\n        // Type Casting\n        double doubleNum = 10.5;\n        int castedNum = (int) doubleNum; // Explicit casting, loses decimal part\n        System.out.println(\"Casted double to int: \" + castedNum);\n    }\n}"
        }
      ]
    },
    {
      "id": "java-core-oop",
      "title": "Object-Oriented Programming (OOP) in Java",
      "description": "Principles of OOP: Encapsulation, Inheritance, Polymorphism, Abstraction, and their practical application in Java.",
      "difficulty": "beginner",
      "category": "core-java",
      "explanation": "Object-Oriented Programming (OOP) is a paradigm that structures software design around objects, which are instances of classes. Java is inherently object-oriented. The four pillars of OOP are: \n\n**Encapsulation**: Bundling data (attributes) and methods (behaviors) that operate on that data within a single unit (class). It hides the internal implementation details and exposes only necessary information through well-defined interfaces (getters/setters). Access modifiers (`private`, `protected`, `public`) control visibility.\n\n**Inheritance**: Mechanism where a new class (subclass/child) inherits properties and behaviors from an existing class (superclass/parent). It promotes code reusability and establishes 'is-a' relationships. Java supports single inheritance for classes and multiple inheritance through interfaces. The `extends` keyword is used for inheritance.\n\n**Polymorphism**: 'Many forms'. Ability of an object to take on many forms. In Java, it's achieved through method overloading (compile-time polymorphism) and method overriding (runtime polymorphism). Method overloading occurs when methods within the same class have the same name but different parameters. Method overriding happens when a subclass provides a specific implementation for a method already defined in its superclass. Polymorphism allows writing generic code that can work with objects of different classes in a unified way.\n\n**Abstraction**: Hiding complex implementation details and exposing only essential information to the user. Abstract classes and interfaces are used for abstraction. Abstract classes can have abstract methods (without implementation) and concrete methods. Interfaces define a contract that classes can implement, specifying methods that implementing classes must provide. Abstraction simplifies complexity and improves maintainability.",
      "example": "// OOP Example: Animal Hierarchy\n\n// Base class\nclass Animal {\n    private String name;\n\n    public Animal(String name) {\n        this.name = name;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void makeSound() {\n        System.out.println(\"Generic animal sound\");\n    }\n}\n\n// Subclass - Inheritance\nclass Dog extends Animal {\n    public Dog(String name) {\n        super(name); // Call superclass constructor\n    }\n\n    // Method Overriding - Polymorphism\n    @Override\n    public void makeSound() {\n        System.out.println(\"Woof!\");\n    }\n}\n\n// Another subclass\nclass Cat extends Animal {\n    public Cat(String name) {\n        super(name);\n    }\n\n    @Override\n    public void makeSound() {\n        System.out.println(\"Meow!\");\n    }\n}\n\npublic class OOPDemo {\n    public static void main(String[] args) {\n        Animal animal = new Animal(\"Generic Animal\");\n        Dog dog = new Dog(\"Buddy\");\n        Cat cat = new Cat(\"Whiskers\");\n\n        animal.makeSound(); // Generic animal sound\n        dog.makeSound();    // Woof!\n        cat.makeSound();    // Meow!\n\n        // Polymorphism in action - treating subclasses as superclass\n        Animal[] animals = {animal, dog, cat};\n        for (Animal a : animals) {\n            System.out.println(a.getName() + \" says: \");\n            a.makeSound(); // Polymorphic call\n        }\n    }\n}",
      "keyPoints": [
        "Encapsulation: Data hiding and abstraction through access modifiers.",
        "Inheritance: Code reuse and 'is-a' relationships using `extends` keyword.",
        "Polymorphism: Method overloading (compile-time) and method overriding (runtime).",
        "Abstraction: Simplifying complexity using abstract classes and interfaces.",
        "Classes: Blueprints for objects; define attributes and behaviors.",
        "Objects: Instances of classes; have state and behavior.",
        "Java is primarily an object-oriented language."
      ],
      "quiz": [
        {
          "question": "Which OOP principle is achieved by hiding internal implementation details and exposing only necessary information?",
          "options": ["Inheritance", "Polymorphism", "Encapsulation", "Abstraction"],
          "correctAnswer": 3
        },
        {
          "question": "What is method overriding an example of?",
          "options": ["Encapsulation", "Inheritance", "Polymorphism", "Abstraction"],
          "correctAnswer": 2
        },
        {
          "question": "Which keyword is used to implement inheritance in Java?",
          "options": ["implements", "inherits", "extends", "instanceof"],
          "correctAnswer": 2
        }
      ],
      "interactiveExamples": [
        {
          "title": "Encapsulation with Bank Account",
          "code": "// Encapsulation Example: Bank Account\nclass BankAccount {\n    private double balance; // Private attribute - Encapsulation\n\n    public BankAccount(double initialBalance) {\n        this.balance = initialBalance;\n    }\n\n    // Public methods to access and modify balance (controlled access)\n    public double getBalance() {\n        return balance;\n    }\n\n    public void deposit(double amount) {\n        if (amount > 0) {\n            balance += amount;\n            System.out.println(\"Deposited: \" + amount + \", New balance: \" + balance);\n        } else {\n            System.out.println(\"Invalid deposit amount.\");\n        }\n    }\n\n    public void withdraw(double amount) {\n        if (amount > 0 && balance >= amount) {\n            balance -= amount;\n            System.out.println(\"Withdrawn: \" + amount + \", New balance: \" + balance);\n        } else {\n            System.out.println(\"Insufficient balance or invalid withdrawal amount.\");\n        }\n    }\n}\n\npublic class EncapsulationDemo {\n    public static void main(String[] args) {\n        BankAccount account = new BankAccount(1000);\n        System.out.println(\"Initial balance: \" + account.getBalance());\n\n        account.deposit(500);\n        account.withdraw(200);\n        account.withdraw(2000); // Attempt to withdraw more than balance\n\n        // Cannot directly access balance attribute - Encapsulation\n        // System.out.println(account.balance); // This would cause a compile-time error\n    }\n}"
        }
      ]
    },
    {
      "id": "java-core-classes-objects",
      "title": "Classes and Objects",
      "description": "Understanding classes as blueprints for creating objects, object instantiation, constructors, and object lifecycle.",
      "difficulty": "beginner",
      "category": "core-java",
      "explanation": "In Java, classes are the fundamental building blocks of object-oriented programming. A **class** is a blueprint or template that defines the characteristics (attributes/fields) and behaviors (methods) that objects of that class will possess. Think of a class as a cookie cutter and objects as the cookies.\n\nAn **object** is an instance of a class. It's a real-world entity that has state (data stored in its attributes) and behavior (actions performed by its methods). Objects are created from classes using the `new` keyword.\n\n**Constructors** are special methods within a class that are used to initialize objects when they are created. Constructors have the same name as the class and do not have a return type (not even `void`). They are automatically invoked when an object is created using `new`.  Classes can have multiple constructors (constructor overloading) with different parameter lists, allowing for flexible object initialization.\n\n**Object Lifecycle**: Objects are created, used, and eventually destroyed. In Java, garbage collection automatically reclaims memory occupied by objects that are no longer in use. Understanding object lifecycle is important for memory management and efficient resource utilization.",
      "example": "// Class and Object Example: Dog Class\n\n// Class definition\nclass Dog {\n    // Attributes (fields)\n    String name;\n    String breed;\n    int age;\n\n    // Constructor - to initialize objects\n    public Dog(String name, String breed, int age) {\n        this.name = name;\n        this.breed = breed;\n        this.age = age;\n    }\n\n    // Methods (behaviors)\n    public void bark() {\n        System.out.println(name + \" says Woof!\");\n    }\n\n    public void displayDetails() {\n        System.out.println(\"Name: \" + name + \", Breed: \" + breed + \", Age: \" + age);\n    }\n}\n\npublic class ClassObjectDemo {\n    public static void main(String[] args) {\n        // Object instantiation using constructor\n        Dog dog1 = new Dog(\"Buddy\", \"Golden Retriever\", 3);\n        Dog dog2 = new Dog(\"Lucy\", \"Labrador\", 2);\n\n        // Accessing object attributes and methods\n        dog1.bark();         // Buddy says Woof!\n        dog2.displayDetails(); // Name: Lucy, Breed: Labrador, Age: 2\n    }\n}",
      "keyPoints": [
        "Class is a blueprint; object is an instance.",
        "Objects have state (attributes) and behavior (methods).",
        "Constructors initialize objects when they are created using `new`.",
        "Classes can have multiple constructors (constructor overloading).",
        "Object lifecycle: creation, usage, garbage collection.",
        "Access object attributes using dot notation (`object.attribute`).",
        "Invoke object methods using dot notation (`object.method()`)."
      ],
      "quiz": [
        {
          "question": "What is a class in Java?",
          "options": ["An instance of an object", "A blueprint for creating objects", "A data type", "A method"],
          "correctAnswer": 1
        },
        {
          "question": "Which keyword is used to create an object in Java?",
          "options": ["class", "object", "instance", "new"],
          "correctAnswer": 3
        },
        {
          "question": "What is the purpose of a constructor?",
          "options": ["To destroy objects", "To define methods", "To initialize objects", "To declare variables"],
          "correctAnswer": 2
        }
      ],
      "interactiveExamples": [
        {
          "title": "Creating and Using a 'Rectangle' Class",
          "code": "// Rectangle Class Example\nclass Rectangle {\n    double length;\n    double width;\n\n    // Constructor\n    public Rectangle(double length, double width) {\n        this.length = length;\n        this.width = width;\n    }\n\n    // Method to calculate area\n    public double calculateArea() {\n        return length * width;\n    }\n\n    // Method to calculate perimeter\n    public double calculatePerimeter() {\n        return 2 * (length + width);\n    }\n}\n\npublic class RectangleDemo {\n    public static void main(String[] args) {\n        // Create Rectangle objects\n        Rectangle rect1 = new Rectangle(5, 10);\n        Rectangle rect2 = new Rectangle(7.5, 3.2);\n\n        // Calculate and display area and perimeter\n        System.out.println(\"Rectangle 1 Area: \" + rect1.calculateArea());\n        System.out.println(\"Rectangle 1 Perimeter: \" + rect1.calculatePerimeter());\n        System.out.println(\"Rectangle 2 Area: \" + rect2.calculateArea());\n        System.out.println(\"Rectangle 2 Perimeter: \" + rect2.calculatePerimeter());\n    }\n}"
        }
      ]
    },
    {
      "id": "java-core-interfaces-abstract-classes",
      "title": "Interfaces and Abstract Classes",
      "description": "Differences and use cases for interfaces and abstract classes in Java, focusing on abstraction and design principles.",
      "difficulty": "intermediate",
      "category": "core-java",
      "explanation": "**Abstract Classes** and **Interfaces** are both mechanisms for achieving abstraction in Java, but they serve different purposes and have distinct characteristics.\n\n**Abstract Classes**: \n- Can contain both abstract methods (methods without implementation) and concrete methods (methods with implementation).\n- Cannot be instantiated directly; they must be subclassed. \n- Subclasses must implement all abstract methods unless they are also declared abstract. \n- Can have constructors, instance variables, and static variables. \n- Used to define a common base class with some shared implementation and some methods that must be implemented by subclasses. They represent an 'is-a' relationship.\n- Java supports single inheritance for classes, meaning a class can extend only one abstract class.\n\n**Interfaces**: \n- Define a contract for classes to implement. An interface specifies a set of methods that implementing classes must provide.\n- Prior to Java 8, interfaces could only contain abstract methods (implicitly `public abstract`) and constants (`public static final`). \n- From Java 8 onwards, interfaces can also contain `default` methods (with implementation) and `static` methods. \n- A class can implement multiple interfaces (multiple inheritance of type). \n- Interfaces represent a 'can-do' or 'has-a' relationship. They are used to achieve polymorphism and define roles or capabilities that classes can adopt. \n- Interfaces are used to decouple components and promote loose coupling. They are crucial for designing flexible and extensible systems.\n\n**Key Differences**: \n- Inheritance: Abstract classes support single inheritance, interfaces support multiple inheritance of type. \n- Implementation: Abstract classes can provide partial implementation, interfaces primarily define a contract (though with default methods, the line is slightly blurred). \n- Purpose: Abstract classes are used for class hierarchy and code reuse; interfaces are for defining contracts and achieving polymorphism.",
      "example": "// Interfaces and Abstract Classes Example\n\n// Interface\ninterface Drawable {\n    void draw(); // Abstract method - no implementation\n    default void color(String c) { // Default method - with implementation (Java 8+)\n        System.out.println(\"Color is: \" + c);\n    }\n}\n\n// Abstract Class\nabstract class Shape {\n    protected String name;\n\n    public Shape(String name) {\n        this.name = name;\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    // Abstract method - subclasses must implement\n    public abstract double getArea();\n\n    // Concrete method - inherited by subclasses\n    public void displayInfo() {\n        System.out.println(\"Shape: \" + name + \", Area: \" + getArea());\n    }\n}\n\n// Class implementing Interface and extending Abstract Class\nclass Circle extends Shape implements Drawable {\n    private double radius;\n\n    public Circle(double radius) {\n        super(\"Circle\");\n        this.radius = radius;\n    }\n\n    @Override\n    public double getArea() {\n        return Math.PI * radius * radius;\n    }\n\n    @Override\n    public void draw() {\n        System.out.println(\"Drawing a circle.\");\n    }\n}\n\npublic class AbstractInterfaceDemo {\n    public static void main(String[] args) {\n        Circle circle = new Circle(5);\n        circle.displayInfo(); // Shape: Circle, Area: 78.5398...\n        circle.draw();       // Drawing a circle.\n        circle.color(\"Red\");   // Color is: Red (default method from interface)\n    }\n}",
      "keyPoints": [
        "Abstract classes can have abstract and concrete methods; interfaces primarily define contracts (methods).",
        "Abstract classes cannot be instantiated; interfaces cannot be instantiated.",
        "A class can extend only one abstract class (single inheritance); a class can implement multiple interfaces (multiple inheritance of type).",
        "Abstract classes can have state (instance variables); interfaces primarily focus on behavior (methods).",
        "Interfaces are used for 'can-do' relationships and defining roles; abstract classes for 'is-a' relationships and code reuse.",
        "Interfaces promote loose coupling and are crucial for designing extensible systems.",
        "Abstract classes can have constructors; interfaces cannot have constructors (prior to Java 8)."
      ],
      "quiz": [
        {
          "question": "Which of the following is true about Abstract Classes in Java?",
          "options": ["They can be instantiated directly.", "They can only have abstract methods.", "They can have both abstract and concrete methods.", "A class can implement multiple abstract classes."],
          "correctAnswer": 2
        },
        {
          "question": "Which of the following is true about Interfaces in Java?",
          "options": ["They can have constructors.", "They can have instance variables.", "Prior to Java 8, they could only have abstract methods.", "A class can extend multiple interfaces."],
          "correctAnswer": 2
        },
        {
          "question": "When should you prefer an Interface over an Abstract Class?",
          "options": ["When you need to provide some default implementation.", "When you want to enforce a contract and allow multiple inheritance of type.", "When you want to create a class hierarchy with shared state.", "When you want to restrict inheritance."],
          "correctAnswer": 1
        }
      ],
      "interactiveExamples": [
        {
          "title": "Implementing Multiple Interfaces",
          "code": "// Multiple Interfaces Example\n\ninterface Swimmable {\n    void swim();\n}\n\ninterface Flyable {\n    void fly();\n}\n\nclass Duck implements Swimmable, Flyable {\n    @Override\n    public void swim() {\n        System.out.println(\"Duck is swimming.\");\n    }\n\n    @Override\n    public void fly() {\n        System.out.println(\"Duck is flying.\");\n    }\n}\n\npublic class MultipleInterfacesDemo {\n    public static void main(String[] args) {\n        Duck duck = new Duck();\n        duck.swim(); // Duck is swimming.\n        duck.fly();  // Duck is flying.\n\n        // Polymorphism - treating object as interface type\n        Swimmable swimmer = duck;\n        swimmer.swim(); // Duck is swimming.\n        Flyable flyer = duck;\n        flyer.fly();   // Duck is flying.\n    }\n}"
        }
      ]
    },
    {
      "id": "java-core-collections-framework",
      "title": "Collections Framework",
      "description": "In-depth knowledge of Java Collections Framework: List, Set, Map, Queue, their implementations, and use cases.",
      "difficulty": "intermediate",
      "category": "core-java",
      "explanation": "The Java Collections Framework provides a set of interfaces and classes to represent and manipulate collections of objects. It is a powerful tool for managing data in Java applications. The main interfaces in the Collections Framework are:\n\n**List**: Represents an ordered collection of elements. Allows duplicate elements. Elements can be accessed by their index (position). Common implementations include `ArrayList` (dynamically resizable array, fast for random access) and `LinkedList` (doubly linked list, efficient for insertions and deletions).\n\n**Set**: Represents a collection of unique elements. Does not allow duplicate elements. Order is not guaranteed in all Set implementations. Common implementations are `HashSet` (unordered, uses hashing for fast lookups), `TreeSet` (sorted set, elements are ordered based on their natural ordering or a provided Comparator), and `LinkedHashSet` (ordered set, maintains insertion order).\n\n**Map**: Represents a collection of key-value pairs. Keys are unique, but values can be duplicated. Maps do not maintain order unless specified. Common implementations include `HashMap` (unordered, uses hashing for fast key lookups), `TreeMap` (sorted map, entries are sorted by keys), and `LinkedHashMap` (ordered map, maintains insertion order of keys).\n\n**Queue**: Represents a collection designed for holding elements prior to processing. Follows FIFO (First-In-First-Out) order. Common implementations include `LinkedList` (can also act as a Queue), `PriorityQueue` (elements are processed based on priority), and `ArrayDeque` (double-ended queue).\n\nThe Collections Framework also includes utility classes like `Collections` (provides static methods for operating on collections, like sorting, searching, synchronization) and `Arrays` (provides static methods for array operations).\n\nChoosing the right collection type depends on the specific requirements of the application, such as whether order is important, whether duplicates are allowed, and the frequency of operations like insertion, deletion, and search.",
      "example": "// Collections Framework Example\n\nimport java.util.*;\n\npublic class CollectionsDemo {\n    public static void main(String[] args) {\n        // List - ArrayList\n        List<String> arrayList = new ArrayList<>();\n        arrayList.add(\"Apple\");\n        arrayList.add(\"Banana\");\n        arrayList.add(\"Orange\");\n        arrayList.add(\"Apple\"); // Duplicates allowed\n        System.out.println(\"ArrayList: \" + arrayList); // [Apple, Banana, Orange, Apple]\n\n        // Set - HashSet\n        Set<String> hashSet = new HashSet<>();\n        hashSet.add(\"Apple\");\n        hashSet.add(\"Banana\");\n        hashSet.add(\"Orange\");\n        hashSet.add(\"Apple\"); // Duplicates ignored\n        System.out.println(\"HashSet: \" + hashSet); // [Orange, Banana, Apple] (order may vary)\n\n        // Map - HashMap\n        Map<String, Integer> hashMap = new HashMap<>();\n        hashMap.put(\"Apple\", 10);\n        hashMap.put(\"Banana\", 20);\n        hashMap.put(\"Orange\", 15);\n        System.out.println(\"HashMap: \" + hashMap); // {Orange=15, Banana=20, Apple=10} (order may vary)\n\n        // Queue - LinkedList\n        Queue<String> linkedQueue = new LinkedList<>();\n        linkedQueue.offer(\"First\");\n        linkedQueue.offer(\"Second\");\n        linkedQueue.offer(\"Third\");\n        System.out.println(\"Queue: \" + linkedQueue); // [First, Second, Third]\n        System.out.println(\"Poll from Queue: \" + linkedQueue.poll()); // First, Queue becomes [Second, Third]\n    }\n}",
      "keyPoints": [
        "List: Ordered collection, allows duplicates. `ArrayList`, `LinkedList`.",
        "Set: Collection of unique elements, no duplicates. `HashSet`, `TreeSet`, `LinkedHashSet`.",
        "Map: Key-value pairs, unique keys. `HashMap`, `TreeMap`, `LinkedHashMap`.",
        "Queue: FIFO order, elements processed in order of addition. `LinkedList`, `PriorityQueue`, `ArrayDeque`.",
        "`ArrayList` for fast random access; `LinkedList` for efficient insertions/deletions.",
        "`HashSet` for fast lookups; `TreeSet` for sorted elements; `LinkedHashSet` for insertion order.",
        "`HashMap` for fast key lookups; `TreeMap` for sorted keys; `LinkedHashMap` for insertion order of keys.",
        "Utility classes: `Collections` and `Arrays` for collection and array operations."
      ],
      "quiz": [
        {
          "question": "Which Collection type guarantees the insertion order of elements?",
          "options": ["HashSet", "TreeSet", "LinkedHashSet", "ArrayList"],
          "correctAnswer": 2
        },
        {
          "question": "Which Collection type stores key-value pairs?",
          "options": ["List", "Set", "Map", "Queue"],
          "correctAnswer": 2
        },
        {
          "question": "Which List implementation is generally faster for random access of elements?",
          "options": ["LinkedList", "ArrayList", "Vector", "Stack"],
          "correctAnswer": 1
        }
      ],
      "interactiveExamples": [
        {
          "title": "Working with HashMap and TreeMap",
          "code": "// HashMap vs TreeMap Example\n\nimport java.util.HashMap;\nimport java.util.TreeMap;\nimport java.util.Map;\n\npublic class MapExample {\n    public static void main(String[] args) {\n        // HashMap - Unordered\n        Map<String, String> hashMap = new HashMap<>();\n        hashMap.put(\"C\", \"Cat\");\n        hashMap.put(\"A\", \"Apple\");\n        hashMap.put(\"B\", \"Banana\");\n        System.out.println(\"HashMap: \" + hashMap); // Order not guaranteed\n\n        // TreeMap - Sorted by keys\n        Map<String, String> treeMap = new TreeMap<>();\n        treeMap.put(\"C\", \"Cat\");\n        treeMap.put(\"A\", \"Apple\");\n        treeMap.put(\"B\", \"Banana\");\n        System.out.println(\"TreeMap: \" + treeMap); // Sorted by keys: {A=Apple, B=Banana, C=Cat}\n\n        // Iterating through TreeMap in sorted order\n        System.out.println(\"\\nTreeMap Iteration (Sorted Order):\");\n        for (Map.Entry<String, String> entry : treeMap.entrySet()) {\n            System.out.println(\"Key: \" + entry.getKey() + \", Value: \" + entry.getValue());\n        }\n    }\n}"
        }
      ]
    },
    {
      "id": "java-core-generics",
      "title": "Generics in Java",
      "description": "Understanding and using generics for type safety, code reusability, and eliminating ClassCastExceptions.",
      "difficulty": "intermediate",
      "category": "core-java",
      "explanation": "Generics in Java enable **parameterized types**. They allow you to define classes, interfaces, and methods that operate on types as parameters. Generics provide type safety at compile-time, meaning type errors are caught during compilation rather than at runtime, preventing `ClassCastException`s. Generics also enhance code reusability as you can write a single class or method that works with different types.\n\n**Type Parameters**: Generics use type parameters (e.g., `<T>`, `<E>`, `<K, V>`) to represent types that will be specified later when the generic type is used. Type parameters are enclosed in angle brackets `<>`. \n\n**Generic Classes**: A class can be made generic by declaring one or more type parameters in its class declaration. Example: `class MyGenericClass<T> { ... }`. When you create an object of a generic class, you must specify the actual type argument for the type parameter, e.g., `MyGenericClass<Integer> obj = new MyGenericClass<>();`.\n\n**Generic Methods**: Methods can also be generic, independent of the class being generic or not. Type parameters for generic methods are declared before the return type in the method signature. Example: `public <T> void myGenericMethod(T arg) { ... }`. Type inference often allows you to call generic methods without explicitly specifying type arguments.\n\n**Type Erasure**: Java implements generics using type erasure. At compile time, generic type information is removed, and raw types are used. This is for backward compatibility with older versions of Java that did not have generics. Type erasure means that at runtime, there's no difference between `List<Integer>` and `List<String>`; they are both just `List`s. However, type safety is enforced during compilation.",
      "example": "// Generics Example\n\n// Generic Class\nclass GenericBox<T> {\n    private T content;\n\n    public void setContent(T content) {\n        this.content = content;\n    }\n\n    public T getContent() {\n        return content;\n    }\n}\n\n// Generic Method\nclass GenericUtil {\n    public static <E> void printArray(E[] array) {\n        for (E element : array) {\n            System.out.print(element + \" \");\n        }\n        System.out.println();\n    }\n}\n\npublic class GenericsDemo {\n    public static void main(String[] args) {\n        // Using Generic Class\n        GenericBox<Integer> integerBox = new GenericBox<>();\n        integerBox.setContent(10);\n        int value = integerBox.getContent(); // No casting needed, type safe\n        System.out.println(\"Integer Box Content: \" + value);\n\n        GenericBox<String> stringBox = new GenericBox<>();\n        stringBox.setContent(\"Hello Generics\");\n        String text = stringBox.getContent(); // No casting needed, type safe\n        System.out.println(\"String Box Content: \" + text);\n\n        // Using Generic Method\n        Integer[] intArray = {1, 2, 3, 4, 5};\n        String[] stringArray = {\"Java\", \"Generics\", \"Example\"};\n\n        System.out.print(\"Integer Array: \");\n        GenericUtil.printArray(intArray); // Type inference\n        System.out.print(\"String Array: \");\n        GenericUtil.printArray(stringArray); // Type inference\n    }\n}",
      "keyPoints": [
        "Generics provide type safety at compile time, preventing `ClassCastException`s.",
        "Enable code reusability by writing classes and methods that work with different types.",
        "Type parameters (e.g., `<T>`, `<E>`) are used to represent generic types.",
        "Generic classes and generic methods can be defined using type parameters.",
        "Type erasure: Generic type information is removed at compile time for backward compatibility.",
        "Benefits: Type safety, code readability, performance (no runtime casting).",
        "Use cases: Collections, algorithms, generic data structures."
      ],
      "quiz": [
        {
          "question": "What is the primary benefit of using Generics in Java?",
          "options": ["Runtime type safety", "Improved performance at runtime", "Compile-time type safety", "Dynamic type checking"],
          "correctAnswer": 2
        },
        {
          "question": "What is Type Erasure in the context of Java Generics?",
          "options": ["Removing type parameters at runtime", "Removing type parameters at compile time", "Replacing type parameters with raw types at compile time", "Replacing type parameters with Object type at runtime"],
          "correctAnswer": 2
        },
        {
          "question": "Which of the following is a valid declaration of a generic class?",
          "options": ["class GenericClass { }", "class GenericClass< > { }", "class <T> GenericClass { }", "class GenericClass<T> { }"],
          "correctAnswer": 3
        }
      ],
      "interactiveExamples": [
        {
          "title": "Generic List Implementation",
          "code": "// Generic List Implementation\n\nclass MyList<T> {\n    private T[] elements;\n    private int size;\n    private static final int DEFAULT_CAPACITY = 10;\n\n    public MyList() {\n        elements = (T[]) new Object[DEFAULT_CAPACITY]; // Type erasure workaround\n        size = 0;\n    }\n\n    public void add(T element) {\n        if (size == elements.length) {\n            increaseCapacity();\n        }\n        elements[size++] = element;\n    }\n\n    public T get(int index) {\n        if (index < 0 || index >= size) {\n            throw new IndexOutOfBoundsException(\"Index: \" + index + \", Size: \" + size);\n        }\n        return elements[index];\n    }\n\n    public int size() {\n        return size;\n    }\n\n    private void increaseCapacity() {\n        int newCapacity = elements.length * 2;\n        T[] newElements = (T[]) new Object[newCapacity];\n        System.arraycopy(elements, 0, newElements, 0, size);\n        elements = newElements;\n    }\n}\n\npublic class GenericListDemo {\n    public static void main(String[] args) {\n        MyList<Integer> intList = new MyList<>();\n        intList.add(100);\n        intList.add(200);\n        intList.add(300);\n\n        for (int i = 0; i < intList.size(); i++) {\n            System.out.println(\"Element at index \" + i + \": \" + intList.get(i));\n        }\n\n        MyList<String> stringList = new MyList<>();\n        stringList.add(\"Generic\");\n        stringList.add(\"List\");\n        stringList.add(\"Example\");\n\n        for (int i = 0; i < stringList.size(); i++) {\n            System.out.println(\"Element at index \" + i + \": \" + stringList.get(i));\n        }\n    }\n}"
        }
      ]
    },
        {
      "id": "java-core-exception-handling",
      "title": "Exception Handling",
      "description": "Handling exceptions in Java using try-catch-finally blocks, exception hierarchy, checked vs. unchecked exceptions, and custom exceptions.",
      "difficulty": "beginner",
      "category": "core-java",
      "explanation": "Exception handling in Java is a powerful mechanism to deal with runtime errors, ensuring program robustness and preventing abrupt termination. Java uses a structured approach with `try-catch-finally` blocks.\n\n**try-catch-finally Block**: \n- **try**: Encloses the code that might throw an exception. \n- **catch**: Follows the `try` block and handles specific types of exceptions. There can be multiple `catch` blocks to handle different exception types. When an exception occurs in the `try` block, Java looks for a matching `catch` block to handle it. \n- **finally**: An optional block that always executes after the `try` and `catch` blocks, regardless of whether an exception was thrown or caught. It's typically used for cleanup operations (e.g., closing resources like files or database connections).\n\n**Exception Hierarchy**: Java exceptions are organized in a hierarchy. `Throwable` is the root class, with two main subclasses: `Exception` and `Error`. \n    - **Exception**: Represents conditions that a reasonable application might want to catch. Exceptions are further divided into: \n        - **Checked Exceptions**: Exceptions that the compiler forces you to handle (either `catch` or declare to throw using `throws` keyword). Examples: `IOException`, `SQLException`. \n        - **Unchecked Exceptions (Runtime Exceptions)**: Exceptions that the compiler does not force you to handle. They typically indicate programming errors. Examples: `NullPointerException`, `ArrayIndexOutOfBoundsException`, `IllegalArgumentException`. \n    - **Error**: Represents serious problems that a reasonable application should not try to catch. Errors are usually unrecoverable. Examples: `OutOfMemoryError`, `StackOverflowError`.\n\n**Custom Exceptions**: You can create your own exception classes by extending `Exception` (for checked exceptions) or `RuntimeException` (for unchecked exceptions). Custom exceptions help in providing more specific error information and handling application-specific error conditions.",
      "example": "// Exception Handling Example\n\nimport java.io.File;\nimport java.io.FileReader;\nimport java.io.IOException;\n\npublic class ExceptionHandlingDemo {\n    public static void main(String[] args) {\n        File file = new File(\"example.txt\");\n        FileReader fileReader = null;\n\n        try {\n            fileReader = new FileReader(file); // Potential IOException (Checked)\n            char[] buffer = new char[1024];\n            fileReader.read(buffer);         // Potential IOException (Checked)\n            System.out.println(new String(buffer));\n        } catch (IOException e) {\n            System.err.println(\"An IOException occurred: \" + e.getMessage());\n        } catch (NullPointerException e) { // Example of catching another type\n            System.err.println(\"A NullPointerException occurred (unlikely here): \" + e.getMessage());\n        } finally {\n            try {\n                if (fileReader != null) {\n                    fileReader.close();   // Potential IOException (Checked) - must be handled in finally too\n                }\n            } catch (IOException e) {\n                System.err.println(\"Error closing FileReader in finally: \" + e.getMessage());\n            }\n            System.out.println(\"Finally block executed.\");\n        }\n\n        System.out.println(\"Program continues after exception handling.\");\n    }\n}",
      "keyPoints": [
        "try-catch-finally blocks for handling exceptions.",
        "try block: Encloses code that might throw exceptions.",
        "catch block: Handles specific exception types.",
        "finally block: Always executes, used for cleanup.",
        "Exception hierarchy: `Throwable`, `Exception`, `Error`.",
        "Checked exceptions: Must be handled or declared to be thrown.",
        "Unchecked (Runtime) exceptions: Compiler does not force handling.",
        "Custom exceptions: Create application-specific exception types.",
        "Use `throws` keyword to declare that a method might throw a checked exception."
      ],
      "quiz": [
        {
          "question": "Which block is always executed in a try-catch-finally structure, regardless of whether an exception is thrown?",
          "options": ["try", "catch", "finally", "None of the above"],
          "correctAnswer": 2
        },
        {
          "question": "What is the difference between checked and unchecked exceptions?",
          "options": ["Checked exceptions are runtime errors, unchecked are compile-time errors.", "Checked exceptions must be handled at compile time, unchecked exceptions do not.", "Checked exceptions are subclasses of Error, unchecked are subclasses of Exception.", "There is no difference."],
          "correctAnswer": 1
        },
        {
          "question": "Which keyword is used to declare that a method might throw a checked exception?",
          "options": ["throw", "throws", "exception", "catch"],
          "correctAnswer": 1
        }
      ],
      "interactiveExamples": [
        {
          "title": "Custom Exception Example - Insufficient Funds Exception",
          "code": "// Custom Exception Example\n\n// Custom Checked Exception\nclass InsufficientFundsException extends Exception {\n    public InsufficientFundsException(String message) {\n        super(message);\n    }\n}\n\nclass BankAccount {\n    private double balance;\n\n    public BankAccount(double initialBalance) {\n        this.balance = initialBalance;\n    }\n\n    public void withdraw(double amount) throws InsufficientFundsException {\n        if (amount > balance) {\n            throw new InsufficientFundsException(\"Insufficient funds to withdraw \" + amount);\n        }\n        balance -= amount;\n        System.out.println(\"Withdrawn: \" + amount + \", New balance: \" + balance);\n    }\n}\n\npublic class CustomExceptionDemo {\n    public static void main(String[] args) {\n        BankAccount account = new BankAccount(1000);\n        try {\n            account.withdraw(1500); // Attempt to withdraw more than balance\n        } catch (InsufficientFundsException e) {\n            System.err.println(\"Exception caught: \" + e.getMessage());\n        }\n    }\n}"
        }
      ]
    },
    {
      "id": "java-core-multithreading",
      "title": "Multithreading and Concurrency",
      "description": "Concepts of threads, synchronization, concurrency utilities, and building concurrent applications in Java.",
      "difficulty": "advanced",
      "category": "core-java",
      "explanation": "Multithreading in Java enables concurrent execution of multiple parts of a program, improving performance and responsiveness, especially in applications that handle multiple tasks simultaneously. Java provides built-in support for multithreading through the `Thread` class and the `Runnable` interface.\n\n**Threads**: A thread is a lightweight subprocess, a unit of execution within a process. Java programs are by default single-threaded. To achieve multithreading, you can create and manage multiple threads. Threads share the same memory space of the process but have their own program counter, stack, and local variables.\n\n**Creating Threads**: Threads can be created in two primary ways:\n    1. **Extending the `Thread` class**: Create a class that extends `Thread` and override the `run()` method. Create an instance of this class and call the `start()` method to begin thread execution.\n    2. **Implementing the `Runnable` interface**: Create a class that implements `Runnable` and provide the thread's execution logic in the `run()` method. Create a `Thread` object, passing an instance of your `Runnable` class to the `Thread` constructor, and then call `start()`.\n\n**Synchronization**: When multiple threads access shared resources, it can lead to race conditions and data inconsistency. Synchronization mechanisms are used to control access to shared resources and prevent these issues. Java provides `synchronized` keyword and locks (`Lock` interface and implementations like `ReentrantLock`) for thread synchronization.\n\n**Concurrency Utilities**: The `java.util.concurrent` package provides a rich set of utility classes for concurrent programming, including:\n    - **Executors**: For managing and controlling thread execution (e.g., `ExecutorService`, `ThreadPoolExecutor`).\n    - **Locks**: More flexible locking mechanisms than `synchronized` (e.g., `ReentrantLock`, `ReadWriteLock`).\n    - **Concurrent Collections**: Thread-safe collection classes (e.g., `ConcurrentHashMap`, `CopyOnWriteArrayList`).\n    - **Atomic Variables**: Classes that support atomic operations on single variables (e.g., `AtomicInteger`, `AtomicReference`).\n    - **CountDownLatch, CyclicBarrier, Semaphore, Phaser**: Synchronization aids for coordinating thread execution.\n\n**Thread Lifecycle**: Threads go through various states: New, Runnable, Running, Blocked/Waiting, Terminated. Understanding thread lifecycle is essential for managing thread execution and debugging concurrent programs.",
      "example": "// Multithreading Example\n\nclass MyThread extends Thread {\n    private String threadName;\n\n    public MyThread(String name) {\n        this.threadName = name;\n    }\n\n    @Override\n    public void run() {\n        for (int i = 0; i < 5; i++) {\n            System.out.println(threadName + \": Count - \" + i);\n            try {\n                Thread.sleep(100); // Sleep for 100 milliseconds\n            } catch (InterruptedException e) {\n                System.out.println(threadName + \" interrupted.\");\n            }\n        }\n    }\n}\n\nclass MyRunnable implements Runnable {\n    private String runnableName;\n\n    public MyRunnable(String name) {\n        this.runnableName = name;\n    }\n\n    @Override\n    public void run() {\n        for (int i = 0; i < 5; i++) {\n            System.out.println(runnableName + \": Count - \" + i);\n            try {\n                Thread.sleep(100); // Sleep for 100 milliseconds\n            } catch (InterruptedException e) {\n                System.out.println(runnableName + \" interrupted.\");\n            }\n        }\n    }\n}\n\npublic class MultithreadingDemo {\n    public static void main(String[] args) {\n        MyThread thread1 = new MyThread(\"Thread-1\");\n        MyThread thread2 = new MyThread(\"Thread-2\");\n\n        MyRunnable runnable1 = new MyRunnable(\"Runnable-1\");\n        Thread thread3 = new Thread(runnable1);\n        MyRunnable runnable2 = new MyRunnable(\"Runnable-2\");\n        Thread thread4 = new Thread(runnable2);\n\n        thread1.start();\n        thread2.start();\n        thread3.start();\n        thread4.start();\n    }\n}",
      "keyPoints": [
        "Multithreading: Concurrent execution of multiple parts of a program.",
        "Threads: Lightweight subprocesses within a process.",
        "Creating threads: Extending `Thread` class or implementing `Runnable` interface.",
        "Synchronization: Controlling access to shared resources using `synchronized` and locks.",
        "Concurrency utilities (`java.util.concurrent`): Executors, Locks, Concurrent Collections, Atomic Variables, etc.",
        "Thread lifecycle: New, Runnable, Running, Blocked/Waiting, Terminated.",
        "Race conditions and data inconsistency in multithreaded programs; synchronization prevents these issues."
      ],
      "quiz": [
        {
          "question": "Which interface is used to define a task that can be executed by a thread?",
          "options": ["Thread", "Runnable", "Callable", "Executor"],
          "correctAnswer": 1
        },
        {
          "question": "What is the purpose of synchronization in multithreading?",
          "options": ["To speed up thread execution", "To prevent race conditions and ensure data consistency", "To create new threads", "To terminate threads"],
          "correctAnswer": 1
        },
        {
          "question": "Which of the following is NOT a concurrency utility in `java.util.concurrent` package?",
          "options": ["ExecutorService", "ReentrantLock", "ArrayList", "ConcurrentHashMap"],
          "correctAnswer": 2
        }
      ],
      "interactiveExamples": [
        {
          "title": "Synchronization using `synchronized` keyword",
          "code": "// Synchronization Example\n\nclass Counter {\n    private int count = 0;\n\n    // Synchronized method\n    public synchronized void increment() {\n        count++;\n    }\n\n    public int getCount() {\n        return count;\n    }\n}\n\npublic class SynchronizationDemo {\n    public static void main(String[] args) throws InterruptedException {\n        Counter counter = new Counter();\n        Thread thread1 = new Thread(() -> {\n            for (int i = 0; i < 1000; i++) {\n                counter.increment();\n            }\n        });\n        Thread thread2 = new Thread(() -> {\n            for (int i = 0; i < 1000; i++) {\n                counter.increment();\n            }\n        });\n\n        thread1.start();\n        thread2.start();\n\n        thread1.join(); // Wait for thread1 to complete\n        thread2.join(); // Wait for thread2 to complete\n\n        System.out.println(\"Final Count: \" + counter.getCount()); // Expected: 2000\n    }\n}"
        }
      ]
    },
    {
      "id": "java-core-java8-features",
      "title": "Java 8 Features",
      "description": "Key features introduced in Java 8: Lambdas, Streams, Optionals, Functional Interfaces, and Date/Time API.",
      "difficulty": "intermediate",
      "category": "core-java",
      "explanation": "Java 8 brought significant changes to the language, introducing features that promote functional programming, improve code conciseness, and enhance API capabilities.\n\n**Lambdas (Lambda Expressions)**: Enable treating functionality as a method argument, or code as data. Lambdas allow you to express instances of single-method interfaces (functional interfaces) more compactly. Syntax: `(parameters) -> expression` or `(parameters) -> { statements; }`.\n\n**Streams**: Provide a high-level, declarative way to process collections of data. Streams allow you to perform operations like filtering, mapping, sorting, and reducing data in a functional style. Streams are not data structures; they are pipelines for processing data from a source. Operations on streams do not modify the original data source.\n\n**Optionals**: A container object that may or may not contain a non-null value. Optionals are used to avoid `NullPointerException`s and make code more readable by explicitly handling cases where a value might be absent. Methods like `isPresent()`, `orElse()`, `orElseGet()`, `map()`, `flatMap()` are used with Optionals.\n\n**Functional Interfaces**: An interface with exactly one abstract method. Functional interfaces can be annotated with `@FunctionalInterface` (optional, but good practice). They are used as the target type for lambda expressions and method references. Examples: `Runnable`, `Comparator`, `Predicate`, `Function`, `Consumer`, `Supplier`.\n\n**Date/Time API (java.time package)**: A new Date and Time API that replaces the old `java.util.Date` and `java.util.Calendar` classes. It provides a more comprehensive, immutable, and thread-safe API for handling dates, times, time zones, and durations. Key classes: `LocalDate`, `LocalTime`, `LocalDateTime`, `ZonedDateTime`, `Duration`, `Period`.\n\n**Method References**: A shorthand syntax to refer to methods without executing them. Method references can be used in place of lambda expressions when the lambda expression simply calls an existing method. Types: Reference to a static method, Reference to an instance method of a particular object, Reference to an instance method of an arbitrary object of a particular type, Reference to a constructor.",
      "example": "// Java 8 Features Example\n\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.Optional;\nimport java.time.LocalDate;\nimport java.util.function.Predicate;\n\npublic class Java8FeaturesDemo {\n    public static void main(String[] args) {\n        // Lambda Expression\n        List<Integer> numbers = Arrays.asList(1, 2, 3, 4, 5, 6);\n        numbers.forEach(n -> System.out.println(\"Number: \" + n));\n\n        // Streams\n        long evenCount = numbers.stream()\n                                .filter(n -> n % 2 == 0)\n                                .count();\n        System.out.println(\"Even numbers count: \" + evenCount);\n\n        // Optional\n        Optional<String> optionalValue = Optional.ofNullable(null); // Could be null\n        String value = optionalValue.orElse(\"Default Value\");\n        System.out.println(\"Optional Value: \" + value); // Default Value\n\n        // Functional Interface (Predicate)\n        Predicate<Integer> isEven = n -> n % 2 == 0;\n        System.out.println(\"Is 4 even? \" + isEven.test(4)); // true\n\n        // Date/Time API\n        LocalDate today = LocalDate.now();\n        System.out.println(\"Today's Date: \" + today);\n    }\n}",
      "keyPoints": [
        "Lambdas: Anonymous functions, enable functional programming.",
        "Streams: Declarative data processing, functional style operations on collections.",
        "Optionals: Container to represent optional values, avoid `NullPointerException`s.",
        "Functional Interfaces: Interfaces with a single abstract method, used with lambdas.",
        "Date/Time API (`java.time`): Modern, immutable, and thread-safe date and time handling.",
        "Method References: Shorthand for lambda expressions that call existing methods.",
        "Java 8 features promote concise, readable, and functional style code."
      ],
      "quiz": [
        {
          "question": "What is a Lambda Expression in Java 8?",
          "options": ["A class without a name", "An anonymous function", "A method reference", "A functional interface"],
          "correctAnswer": 1
        },
        {
          "question": "What is the purpose of Streams in Java 8?",
          "options": ["To store collections of data", "To process collections of data in a declarative and functional style", "To handle exceptions", "To create threads"],
          "correctAnswer": 1
        },
        {
          "question": "What problem do Optionals primarily solve in Java 8?",
          "options": ["Memory leaks", "Concurrency issues", "NullPointerException", "Checked exceptions"],
          "correctAnswer": 2
        }
      ],
      "interactiveExamples": [
        {
          "title": "Stream Operations - Map and Filter",
          "code": "// Stream Map and Filter Example\n\nimport java.util.Arrays;\nimport java.util.List;\nimport java.util.stream.Collectors;\n\npublic class StreamOperationsDemo {\n    public static void main(String[] args) {\n        List<String> names = Arrays.asList(\"Alice\", \"Bob\", \"Charlie\", \"David\", \"Eve\");\n\n        // Map operation: Convert names to uppercase\n        List<String> upperCaseNames = names.stream()\n                                          .map(String::toUpperCase) // Method reference\n                                          .collect(Collectors.toList());\n        System.out.println(\"Uppercase Names: \" + upperCaseNames); // [ALICE, BOB, CHARLIE, DAVID, EVE]\n\n        // Filter operation: Get names starting with 'C'\n        List<String> namesStartingWithC = names.stream()\n                                                 .filter(name -> name.startsWith(\"C\")) // Lambda expression\n                                                 .collect(Collectors.toList());\n        System.out.println(\"Names starting with 'C': \" + namesStartingWithC); // [Charlie]\n\n        // Chaining operations: Uppercase names starting with 'C'\n        List<String> upperCaseCNames = names.stream()\n                                              .filter(name -> name.startsWith(\"C\"))\n                                              .map(String::toUpperCase)\n                                              .collect(Collectors.toList());\n        System.out.println(\"Uppercase names starting with 'C': \" + upperCaseCNames); // [CHARLIE]\n    }\n}"
        }
      ]
    },
     {
      "id": "java-core-io-nio",
      "title": "IO and NIO",
      "description": "Input/Output operations and New IO (NIO) for non-blocking operations, focusing on performance and efficiency.",
      "difficulty": "intermediate",
      "category": "core-java",
      "explanation": "Java Input/Output (IO) and New IO (NIO) are frameworks for handling data transfer between a Java application and external resources like files, networks, or devices. \n\n**IO (Blocking IO)**: The traditional IO model in Java is based on streams. Streams are sequential flows of data. IO operations in the `java.io` package are typically **blocking**. When a thread initiates an IO operation (e.g., reading from a file), the thread is blocked (suspended) until the operation completes. This blocking nature can be inefficient for high-concurrency applications as it can lead to thread starvation and performance bottlenecks. \n    - **Streams**: `InputStream`, `OutputStream` for byte streams; `Reader`, `Writer` for character streams. \n    - **Buffered Streams**: `BufferedInputStream`, `BufferedOutputStream`, `BufferedReader`, `BufferedWriter` for improving performance by reducing the number of actual IO operations.\n\n**NIO (Non-blocking IO)**: New IO, introduced in Java 1.4 and enhanced in later versions, provides a non-blocking, channel-based IO model. NIO operations are generally non-blocking, allowing a single thread to manage multiple channels. NIO is designed for high-performance, scalable applications, especially network programming. \n    - **Channels**: Represent connections to IO sources or sinks (e.g., files, sockets). Channels support asynchronous IO operations. Examples: `FileChannel`, `SocketChannel`, `ServerSocketChannel`. \n    - **Buffers**: Data containers for channels. Data is read from channels into buffers and written from buffers to channels. Buffers allow non-blocking operations. Examples: `ByteBuffer`, `CharBuffer`, `IntBuffer`. \n    - **Selectors**: Enable a single thread to monitor multiple channels for readiness (e.g., readable, writable). Selectors facilitate multiplexing IO operations, allowing efficient management of multiple connections with fewer threads. \n\n**Key Differences**: \n- **Blocking vs. Non-blocking**: IO is blocking; NIO is primarily non-blocking. \n- **Streams vs. Channels and Buffers**: IO uses streams; NIO uses channels and buffers. Channels are bidirectional and support non-blocking operations, unlike streams. Buffers allow for more efficient data manipulation. \n- **Thread Management**: IO typically requires more threads for handling concurrent connections due to blocking nature; NIO can handle many connections with fewer threads using selectors.",
      "example": "// IO and NIO Example - File Reading\n\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\n\npublic class IO_NIO_Demo {\n    public static void main(String[] args) {\n        String filePath = \"example.txt\";\n\n        // IO Example (BufferedReader)\n        System.out.println(\"--- IO Example ---\");\n        try (BufferedReader reader = new BufferedReader(new FileReader(filePath))) {\n            String line;\n            while ((line = reader.readLine()) != null) {\n                System.out.println(line);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n\n        // NIO Example (Files.lines)\n        System.out.println(\"\\n--- NIO Example ---\");\n        try {\n            Files.lines(Paths.get(filePath))\n                 .forEach(System.out::println); // Using Streams API with NIO\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}",
      "keyPoints": [
        "IO (java.io): Blocking, stream-based, simpler for basic operations.",
        "NIO (java.nio): Non-blocking, channel-based, designed for high performance and scalability.",
        "IO uses streams (`InputStream`, `OutputStream`, `Reader`, `Writer`); NIO uses channels (`Channel`) and buffers (`Buffer`).",
        "NIO Selectors: Enable a single thread to manage multiple channels efficiently.",
        "IO operations are typically blocking, NIO operations are primarily non-blocking.",
        "NIO is more complex than IO but offers better performance and scalability for concurrent applications.",
        "Use cases: IO for simple file operations, NIO for high-performance network servers, handling many concurrent connections."
      ],
      "quiz": [
        {
          "question": "Which IO model in Java is primarily non-blocking?",
          "options": ["java.io", "java.net", "java.nio", "java.util"],
          "correctAnswer": 2
        },
        {
          "question": "What are the core components of NIO?",
          "options": ["Streams and Readers/Writers", "Channels and Buffers", "Sockets and ServerSockets", "Files and Paths"],
          "correctAnswer": 1
        },
        {
          "question": "What is the main advantage of NIO over traditional IO in terms of concurrency?",
          "options": ["NIO is simpler to use for concurrent programming.", "NIO uses more threads than IO for concurrency.", "NIO can handle more concurrent connections with fewer threads using selectors.", "There is no advantage in concurrency."],
          "correctAnswer": 2
        }
      ],
      "interactiveExamples": [
        {
          "title": "NIO - FileChannel Example",
          "code": "// NIO FileChannel Example - Reading from a file\n\nimport java.nio.ByteBuffer;\nimport java.nio.channels.FileChannel;\nimport java.nio.file.Paths;\nimport java.nio.file.StandardOpenOption;\nimport java.io.IOException;\n\npublic class NIOFileChannelDemo {\n    public static void main(String[] args) {\n        String filePath = \"example.txt\";\n\n        try (FileChannel channel = FileChannel.open(Paths.get(filePath), StandardOpenOption.READ)) {\n            ByteBuffer buffer = ByteBuffer.allocate(1024); // Allocate buffer\n\n            while (channel.read(buffer) > 0) { // Read data into buffer\n                buffer.flip(); // Prepare buffer for reading\n                while (buffer.hasRemaining()) {\n                    System.out.print((char) buffer.get()); // Read byte by byte\n                }\n                buffer.clear(); // Clear buffer for next read\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}"
        }
      ]
    },
     {
      "id": "java-core-jvm-internals",
      "title": "JVM Internals",
      "description": "Understanding Java Virtual Machine (JVM) internals: Memory Management, Garbage Collection, and JVM architecture.",
      "difficulty": "advanced",
      "category": "core-java",
      "explanation": "The Java Virtual Machine (JVM) is the runtime environment for Java applications. Understanding its internals is crucial for performance tuning and debugging. Key aspects of JVM internals include memory management and garbage collection.\n\n**JVM Architecture**: The JVM is broadly divided into subsystems:\n    - **Classloader Subsystem**: Responsible for loading class files and preparing them for execution. It performs loading, linking (verification, preparation, resolution), and initialization. \n    - **Runtime Data Areas (Memory Areas)**: Memory structures used by the JVM during program execution. Key areas are: \n        - **Heap**: Area where objects are allocated. Shared by all threads. Garbage collection operates on the heap. \n        - **Method Area (PermGen/Metaspace)**: Stores class-level information (e.g., class structure, method code, static variables). In Java 8+, PermGen is replaced by Metaspace (native memory). \n        - **Stack (Java Virtual Machine Stacks)**: Each thread has its own JVM stack, storing frames. A frame is created for each method invocation and contains local variables, operand stack, and frame data. \n        - **Program Counter (PC) Registers**: Each thread has a PC register, holding the address of the current instruction being executed. \n        - **Native Method Stacks**: Stacks for native methods (non-Java code).\n    - **Execution Engine**: Executes bytecode instructions. Includes: \n        - **Interpreter**: Interprets bytecode instruction by instruction. \n        - **Just-In-Time (JIT) Compiler**: Compiles frequently executed bytecode into native machine code for better performance. HotSpot JVM uses adaptive optimization, dynamically compiling hot methods. \n        - **Garbage Collector**: Manages automatic memory management by reclaiming memory occupied by objects that are no longer reachable.\n\n**Memory Management**: Java uses automatic memory management through garbage collection. Developers do not need to explicitly allocate or deallocate memory. \n\n**Garbage Collection (GC)**: Process of automatically reclaiming memory occupied by unused objects. GC algorithms include: \n    - **Mark and Sweep**: Marks reachable objects and then sweeps (deallocates) unmarked objects. Can lead to fragmentation. \n    - **Mark and Compact**: Marks reachable objects, sweeps unmarked objects, and then compacts (moves) remaining objects to reduce fragmentation. \n    - **Copying**: Divides heap into two regions; copies live objects from one region to another. Used in generational GC. \n    - **Generational Garbage Collection**: Divides heap into generations (Young Generation, Old Generation, Permanent Generation/Metaspace). Objects are initially allocated in the Young Generation. Minor GC is frequent in Young Generation. Major GC (Full GC) is less frequent, in Old Generation. Different GC algorithms can be used for different generations. Common GC algorithms: Serial GC, Parallel GC, CMS GC (Concurrent Mark Sweep), G1 GC (Garbage-First Garbage Collector), ZGC, Shenandoah.  \n\n**JVM Tuning**: Optimizing JVM settings for performance, including heap size, GC algorithm selection, JIT compiler options, etc.",
      "example": "// JVM Internals - Memory Areas (Conceptual)\n\npublic class JVMMemory {\n    static int staticVar = 10; // Stored in Method Area (Metaspace)\n\n    public static void main(String[] args) {\n        JVMMemory obj1 = new JVMMemory(); // Object in Heap\n        JVMMemory obj2 = new JVMMemory(); // Another object in Heap\n        int localVar = 20;               // Local variable in Stack Frame\n        method1(obj1, localVar);       // Method invocation - new Stack Frame\n    }\n\n    public static void method1(JVMMemory obj, int param) {\n        int localVarMethod1 = 30;       // Local variable in Stack Frame of method1\n        // ... method logic ...\n    }\n}",
      "keyPoints": [
        "JVM Architecture: Classloader Subsystem, Runtime Data Areas, Execution Engine.",
        "Runtime Data Areas (Memory Areas): Heap, Method Area (Metaspace), Stack, PC Registers, Native Method Stacks.",
        "Heap: Object allocation, garbage collection.",
        "Method Area (Metaspace): Class-level information.",
        "Stack: Thread-specific, method invocation frames, local variables.",
        "Garbage Collection (GC): Automatic memory management, reclaiming unused objects.",
        "GC Algorithms: Mark and Sweep, Mark and Compact, Copying, Generational GC.",
        "JVM Tuning: Optimizing JVM settings for performance."
      ],
      "quiz": [
        {
          "question": "In which JVM memory area are objects primarily allocated?",
          "options": ["Method Area", "Stack", "Heap", "PC Registers"],
          "correctAnswer": 2
        },
        {
          "question": "What is the role of the Garbage Collector in JVM?",
          "options": ["To compile Java code to bytecode", "To execute bytecode instructions", "To manage automatic memory management and reclaim unused objects", "To load class files"],
          "correctAnswer": 2
        },
        {
          "question": "Which JVM memory area is thread-specific and stores method invocation frames?",
          "options": ["Heap", "Method Area", "Stack", "Metaspace"],
          "correctAnswer": 2
        }
      ],
      "interactiveExamples": [
        {
          "title": "JVM Memory Visualization (Conceptual)",
          "code": "// JVM Memory Areas - Conceptual Visualization (No actual code to run)\n\n// Heap: [Object 1][Object 2][...][Free Space]  (Garbage Collection happens here)\n// Method Area (Metaspace): [Class Info JVMMemory][Static Var staticVar=10][...]\n// Stack (Thread 1): [Frame for main method][Frame for method1] (Local vars, operand stack)\n// Stack (Thread 2): [...]\n// ...\n\n// Garbage Collection process (simplified):\n// 1. Mark Reachable Objects (starting from GC roots)\n// 2. Sweep Unreachable Objects (reclaim memory)\n// 3. (Optionally) Compact Heap (reduce fragmentation)\n\n// Generational GC (Young Generation, Old Generation):\n// New objects in Young Gen -> Minor GC -> Promotion to Old Gen -> Major GC\n\n// Note: This is a conceptual representation. JVM memory management is complex and dynamic."
        }
      ]
    },
     {
      "id": "java-core-design-patterns",
      "title": "Design Patterns",
      "description": "Common design patterns in Java: Creational, Structural, Behavioral patterns (Singleton, Factory, Observer, Strategy, etc.).",
      "difficulty": "intermediate",
      "category": "core-java",
      "explanation": "Design patterns are reusable solutions to commonly occurring problems in software design. They are not code, but templates for how to solve problems that can be used in many different situations. Design patterns are categorized into three main types:\n\n**Creational Patterns**: Deal with object creation mechanisms, trying to create objects in a manner suitable to the situation. Examples: \n    - **Singleton**: Ensures a class has only one instance and provides a global point of access to it. \n    - **Factory Method**: Defines an interface for creating an object, but lets subclasses decide which class to instantiate. \n    - **Abstract Factory**: Provides an interface for creating families of related or dependent objects without specifying their concrete classes. \n    - **Builder**: Separates the construction of a complex object from its representation, allowing the same construction process to create different representations. \n    - **Prototype**: Specifies the kinds of objects to create using a prototypical instance, and create new objects by copying this prototype.\n\n**Structural Patterns**: Deal with class and object composition. They simplify the design by identifying simple ways to realize relationships between entities. Examples: \n    - **Adapter**: Allows interfaces of incompatible classes to work together. Converts the interface of a class into another interface clients expect. \n    - **Bridge**: Decouples an abstraction from its implementation so that the two can vary independently. \n    - **Composite**: Composes objects into tree structures to represent part-whole hierarchies. Lets clients treat individual objects and compositions of objects uniformly. \n    - **Decorator**: Dynamically adds responsibilities to an object. Provides a flexible alternative to subclassing for extending functionality. \n    - **Facade**: Provides a unified interface to a set of interfaces in a subsystem. Facade defines a higher-level interface that makes the subsystem easier to use. \n    - **Flyweight**: Uses sharing to support large numbers of fine-grained objects efficiently. \n    - **Proxy**: Provides a surrogate or placeholder for another object to control access to it.\n\n**Behavioral Patterns**: Concerned with algorithms and the assignment of responsibilities between objects. Behavioral patterns characterize complex control flow and focus on how objects communicate. Examples: \n    - **Observer**: Defines a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically. \n    - **Strategy**: Defines a family of algorithms, encapsulates each one, and makes them interchangeable. Strategy lets the algorithm vary independently from clients that use it. \n    - **Template Method**: Defines the skeleton of an algorithm in an operation, deferring some steps to subclasses. Template Method lets subclasses redefine certain steps of an algorithm without changing the algorithm's structure. \n    - **Command**: Encapsulates a request as an object, thereby letting you parameterize clients with queues, requests, or operations. \n    - **Iterator**: Provides a way to access the elements of an aggregate object sequentially without exposing its underlying representation. \n    - **Mediator**: Defines an object that encapsulates how a set of objects interact. Mediator promotes loose coupling by keeping objects from referring to each other explicitly, and lets you vary their interaction independently. \n    - **Memento**: Without violating encapsulation, capture and externalize an object's internal state so that the object can be restored to this state later. \n    - **State**: Allow an object to alter its behavior when its internal state changes. The object will appear to change its class. \n    - **Visitor**: Represent an operation to be performed on the elements of an object structure. Visitor lets you define a new operation without changing the classes of the elements on which it operates. \n    - **Chain of Responsibility**: Avoid coupling the sender of a request to its receiver by giving more than one object a chance to handle the request. Chain the receiver objects and pass the request along the chain until an object handles it. \n    - **Interpreter**: Given a language, define a representation for its grammar along with an interpreter that uses the representation to interpret sentences in the language.",
      "example": "// Design Patterns Example - Singleton Pattern\n\n// Singleton Class\nclass Singleton {\n    private static Singleton instance; // Private static instance\n\n    private Singleton() { // Private constructor - prevents external instantiation\n        // Initialization code here\n    }\n\n    public static Singleton getInstance() { // Public static method to get instance\n        if (instance == null) {\n            instance = new Singleton();\n        }\n        return instance;\n    }\n\n    public void showMessage() {\n        System.out.println(\"Singleton instance is working!\");\n    }\n}\n\npublic class DesignPatternsDemo {\n    public static void main(String[] args) {\n        // Get Singleton instance\n        Singleton singleton = Singleton.getInstance();\n\n        // Use singleton instance\n        singleton.showMessage(); // Singleton instance is working!\n\n        Singleton anotherSingleton = Singleton.getInstance();\n        System.out.println(\"Are both instances same? \" + (singleton == anotherSingleton)); // true - same instance\n    }\n}",
      "keyPoints": [
        "Design patterns: Reusable solutions to common software design problems.",
        "Creational Patterns: Object creation (Singleton, Factory, Builder, Prototype).",
        "Structural Patterns: Class and object composition (Adapter, Bridge, Decorator, Facade, Proxy).",
        "Behavioral Patterns: Algorithms and responsibilities (Observer, Strategy, Template Method, Command, Iterator).",
        "Singleton: Ensure only one instance of a class.",
        "Factory Method: Define interface for object creation, subclasses decide instantiation.",
        "Observer: One-to-many dependency, notify dependents on state change.",
        "Strategy: Encapsulate algorithms, make them interchangeable."
      ],
      "quiz": [
        {
          "question": "Which design pattern ensures that a class has only one instance?",
          "options": ["Factory", "Singleton", "Observer", "Strategy"],
          "correctAnswer": 1
        },
        {
          "question": "Which category of design patterns deals with object creation mechanisms?",
          "options": ["Structural", "Behavioral", "Creational", "Concurrency"],
          "correctAnswer": 2
        },
        {
          "question": "Which design pattern defines a one-to-many dependency between objects?",
          "options": ["Adapter", "Strategy", "Singleton", "Observer"],
          "correctAnswer": 3
        }
      ],
      "interactiveExamples": [
        {
          "title": "Factory Method Pattern Example",
          "code": "// Factory Method Pattern Example\n\n// Product Interface\ninterface Animal {\n    void makeSound();\n}\n\n// Concrete Products\nclass Dog implements Animal {\n    @Override\n    public void makeSound() {\n        System.out.println(\"Woof!\");\n    }\n}\n\nclass Cat implements Animal {\n    @Override\n    public void makeSound() {\n        System.out.println(\"Meow!\");\n    }\n}\n\n// Factory Class\nclass AnimalFactory {\n    public Animal createAnimal(String type) {\n        if (\"dog\".equalsIgnoreCase(type)) {\n            return new Dog();\n        } else if (\"cat\".equalsIgnoreCase(type)) {\n            return new Cat();\n        } else {\n            return null;\n        }\n    }\n}\n\npublic class FactoryMethodDemo {\n    public static void main(String[] args) {\n        AnimalFactory factory = new AnimalFactory();\n\n        Animal dog = factory.createAnimal(\"dog\");\n        if (dog != null) {\n            dog.makeSound(); // Woof!\n        }\n\n        Animal cat = factory.createAnimal(\"cat\");\n        if (cat != null) {\n            cat.makeSound(); // Meow!\n        }\n    }\n}"
        }
      ]
    },
     {
      "id": "java-core-solid-principles",
      "title": "SOLID Principles",
      "description": "SOLID principles for object-oriented design: Single Responsibility, Open/Closed, Liskov Substitution, Interface Segregation, Dependency Inversion.",
      "difficulty": "intermediate",
      "category": "core-java",
      "explanation": "SOLID principles are a set of five design principles intended to make software designs more understandable, flexible, and maintainable. They are fundamental to object-oriented design and development.\n\n**1. Single Responsibility Principle (SRP)**: A class should have only one reason to change. In other words, a class should have only one responsibility. This principle aims to keep classes focused and cohesive, making them easier to understand, test, and maintain. If a class has multiple responsibilities, changes to one responsibility might affect others, leading to unexpected side effects and increased complexity. \n\n**2. Open/Closed Principle (OCP)**: Software entities (classes, modules, functions, etc.) should be open for extension but closed for modification. This means you should be able to add new functionality without modifying existing code. Achieving OCP often involves using abstractions like interfaces and abstract classes, and design patterns like Strategy and Decorator. \n\n**3. Liskov Substitution Principle (LSP)**: Subtypes must be substitutable for their base types without altering the correctness of the program. If class B is a subtype of class A, then objects of type A may be replaced with objects of type B (or vice versa) without altering any of the desirable properties of that program (correctness, task performed, etc.). LSP ensures that inheritance is used correctly and promotes robust and maintainable class hierarchies. \n\n**4. Interface Segregation Principle (ISP)**: Clients should not be forced to depend on interfaces they do not use. ISP advocates for creating smaller, more specific interfaces rather than large, general-purpose interfaces. By segregating interfaces, clients only need to implement and depend on the methods they actually use, reducing unnecessary dependencies and improving flexibility. \n\n**5. Dependency Inversion Principle (DIP)**: \n    a. High-level modules should not depend on low-level modules. Both should depend on abstractions. \n    b. Abstractions should not depend on details. Details should depend on abstractions. \nDIP promotes decoupling between modules. It suggests that instead of high-level modules depending directly on low-level modules, both should depend on abstractions (interfaces or abstract classes). This reduces coupling, increases flexibility, and makes it easier to change implementations without affecting high-level modules. Dependency Injection (DI) is a technique often used to implement DIP.",
      "example": "// SOLID Principles Example - Single Responsibility Principle (SRP)\n\n// Violation of SRP - Email and Logger in one class\nclass User {\n    public void changePassword(String newPassword) {\n        // Password change logic\n        System.out.println(\"Password changed\");\n        log(\"Password changed for user\"); // Logging responsibility mixed in\n    }\n\n    public void log(String message) {\n        // Logging logic\n        System.out.println(\"Logging: \" + message);\n    }\n}\n\n// SRP Applied - Separate classes for User and Logger\nclass UserSRP {\n    private Logger logger;\n\n    public UserSRP(Logger logger) {\n        this.logger = logger;\n    }\n\n    public void changePassword(String newPassword) {\n        // Password change logic\n        System.out.println(\"Password changed\");\n        logger.log(\"Password changed for user\"); // Delegate logging to Logger class\n    }\n}\n\nclass Logger {\n    public void log(String message) {\n        // Logging logic\n        System.out.println(\"Logging: \" + message);\n    }\n}\n\npublic class SOLIDDemo {\n    public static void main(String[] args) {\n        // Using SRP compliant classes\n        Logger logger = new Logger();\n        UserSRP userSRP = new UserSRP(logger);\n        userSRP.changePassword(\"NewPass123\");\n    }\n}",
      "keyPoints": [
        "SOLID: Five design principles for maintainable and flexible OOP code.",
        "SRP (Single Responsibility Principle): Class should have one reason to change.",
        "OCP (Open/Closed Principle): Open for extension, closed for modification.",
        "LSP (Liskov Substitution Principle): Subtypes substitutable for base types.",
        "ISP (Interface Segregation Principle): Clients should not depend on unused interfaces.",
        "DIP (Dependency Inversion Principle): Depend on abstractions, not concretions.",
        "SOLID principles promote good OO design, reduce coupling, and improve maintainability."
      ],
      "quiz": [
        {
          "question": "Which SOLID principle states that a class should have only one reason to change?",
          "options": ["Open/Closed Principle", "Liskov Substitution Principle", "Single Responsibility Principle", "Dependency Inversion Principle"],
          "correctAnswer": 2
        },
        {
          "question": "Which SOLID principle encourages creating smaller, more specific interfaces?",
          "options": ["Interface Segregation Principle", "Open/Closed Principle", "Liskov Substitution Principle", "Dependency Inversion Principle"],
          "correctAnswer": 0
        },
        {
          "question": "Which SOLID principle advocates for depending on abstractions rather than concrete implementations?",
          "options": ["Single Responsibility Principle", "Open/Closed Principle", "Liskov Substitution Principle", "Dependency Inversion Principle"],
          "correctAnswer": 3
        }
      ],
      "interactiveExamples": [
        {
          "title": "Open/Closed Principle Example",
          "code": "// Open/Closed Principle Example\n\n// Violation of OCP - Shape class with area calculation\nclass Shape {\n    String type;\n\n    public Shape(String type) {\n        this.type = type;\n    }\n\n    public double calculateArea() {\n        if (\"Rectangle\".equalsIgnoreCase(type)) {\n            // Rectangle area calculation\n            return 0.0; // Placeholder\n        } else if (\"Circle\".equalsIgnoreCase(type)) {\n            // Circle area calculation\n            return 0.0; // Placeholder\n        } // Adding new shapes requires modifying this class - violates OCP\n        return 0.0;\n    }\n}\n\n// OCP Applied - Abstraction for shapes\ninterface ShapeOCP {\n    double calculateArea();\n}\n\nclass RectangleOCP implements ShapeOCP {\n    double length, width;\n    public RectangleOCP(double l, double w){length = l; width = w;}\n    @Override\n    public double calculateArea() {\n        return length * width;\n    }\n}\n\nclass CircleOCP implements ShapeOCP {\n    double radius;\n    public CircleOCP(double r){radius = r;}\n    @Override\n    public double calculateArea() {\n        return Math.PI * radius * radius;\n    }\n}\n\npublic class OCPDemo {\n    public static void main(String[] args) {\n        RectangleOCP rect = new RectangleOCP(5, 10);\n        CircleOCP circle = new CircleOCP(5);\n\n        System.out.println(\"Rectangle Area: \" + rect.calculateArea());\n        System.out.println(\"Circle Area: \" + circle.calculateArea());\n    }\n}"
        }
      ]
    },
    {
      "id": "spring-core-di",
      "title": "Dependency Injection (DI)",
      "description": "Core concept of Spring Framework: Dependency Injection and its benefits, Inversion of Control (IoC), and bean wiring.",
      "difficulty": "beginner",
      "category": "spring-core",
      "explanation": "Dependency Injection (DI) is a core design pattern and a fundamental principle in the Spring Framework. DI is a form of Inversion of Control (IoC). In traditional programming, objects are responsible for creating their own dependencies. With DI, dependencies are injected into objects, typically by a container (like Spring IoC container). This inverts the control of dependency creation and management from the object to an external entity.\n\n**Inversion of Control (IoC)**: IoC is a broader concept where the framework controls the flow of the application. DI is a specific type of IoC that deals with how objects get their dependencies. In IoC, the framework takes control of object creation and lifecycle, freeing the application code from these responsibilities. Spring IoC container is responsible for instantiating, configuring, and assembling beans (objects managed by Spring).\n\n**Benefits of DI**: \n    - **Decoupling**: Reduces dependencies between components. Components become more independent and reusable. \n    - **Testability**: Makes components easier to test. Dependencies can be easily mocked or stubbed during testing. \n    - **Maintainability**: Improves code maintainability and readability. Changes in dependencies are less likely to affect dependent components. \n    - **Reusability**: Components are more reusable in different contexts because they are not hardcoded to specific dependencies. \n    - **Configuration**: Dependency configuration is externalized (e.g., in XML, annotations, Java configuration), making it easier to manage and change dependencies without modifying code.\n\n**Types of Dependency Injection**: \n    - **Constructor Injection**: Dependencies are provided through the constructor of a class. Preferred for mandatory dependencies. \n    - **Setter Injection**: Dependencies are provided through setter methods of a class. Suitable for optional dependencies. \n    - **Field Injection (Annotation-based)**: Dependencies are injected directly into fields using annotations like `@Autowired`. While convenient, it can make testing and understanding dependencies slightly harder compared to constructor injection. \n\n**Bean Wiring**: The process of creating associations between application components (beans) in the Spring container. Bean wiring is configured using XML configuration files, annotations, or Java-based configuration classes. Spring IoC container uses this configuration to understand which dependencies to inject into which beans.",
      "example": "// Spring DI Example - Constructor Injection\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Component;\n\ninterface MessageService {\n    String getMessage();\n}\n\n@Component\nclass EmailService implements MessageService {\n    @Override\n    public String getMessage() {\n        return \"Email Message\";\n    }\n}\n\n@Component\nclass NotificationService {\n    private MessageService messageService;\n\n    // Constructor Injection using @Autowired\n    @Autowired\n    public NotificationService(MessageService service) {\n        this.messageService = service;\n    }\n\n    public void sendNotification() {\n        System.out.println(\"Sending notification: \" + messageService.getMessage());\n    }\n}\n\n// Configuration (Java Config - @Configuration and @ComponentScan)\n//@Configuration\n//@ComponentScan(\"com.example\") // Assuming classes are in com.example package\n\n// Main application class to demonstrate DI\n//@SpringBootApplication // Using Spring Boot for simplicity\n//public class SpringDiDemoApplication {\n//    public static void main(String[] args) {\n//        ApplicationContext context = SpringApplication.run(SpringDiDemoApplication.class, args);\n//        NotificationService service = context.getBean(NotificationService.class);\n//        service.sendNotification(); // Sending notification: Email Message\n//    }\n//}",
      "keyPoints": [
        "Dependency Injection (DI): Dependencies are injected into objects, not created by objects themselves.",
        "Inversion of Control (IoC): Framework controls application flow and object lifecycle.",
        "Spring IoC Container: Manages beans, instantiates, configures, and assembles dependencies.",
        "Benefits of DI: Decoupling, Testability, Maintainability, Reusability, Externalized Configuration.",
        "Types of DI: Constructor Injection, Setter Injection, Field Injection (@Autowired).",
        "Bean Wiring: Process of creating associations between beans in Spring container.",
        "Configuration for Bean Wiring: XML, Annotations, Java-based configuration."
      ],
      "quiz": [
        {
          "question": "What is Dependency Injection (DI)?",
          "options": ["A design pattern where objects create their own dependencies.", "A design pattern where dependencies are injected into objects.", "A type of exception handling in Java.", "A method for creating singleton beans in Spring."],
          "correctAnswer": 1
        },
        {
          "question": "What is Inversion of Control (IoC) in Spring?",
          "options": ["A specific type of Dependency Injection.", "A broader concept where the framework controls the application flow.", "A technique for managing transactions.", "A way to implement Aspect-Oriented Programming."],
          "correctAnswer": 1
        },
        {
          "question": "Which type of Dependency Injection is generally preferred for mandatory dependencies?",
          "options": ["Setter Injection", "Field Injection", "Constructor Injection", "Interface Injection"],
          "correctAnswer": 2
        }
      ],
      "interactiveExamples": [
        {
          "title": "Setter Injection Example",
          "code": "// Setter Injection Example\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.stereotype.Component;\n\ninterface LoggerService {\n    void log(String message);\n}\n\n@Component\nclass ConsoleLogger implements LoggerService {\n    @Override\n    public void log(String message) {\n        System.out.println(\"Log to console: \" + message);\n    }\n}\n\n@Component\nclass UserService {\n    private LoggerService loggerService;\n\n    // Setter Injection using @Autowired\n    @Autowired\n    public void setLoggerService(LoggerService loggerService) {\n        this.loggerService = loggerService;\n    }\n\n    public void createUser(String username) {\n        // User creation logic\n        System.out.println(\"Creating user: \" + username);\n        loggerService.log(\"User created: \" + username);\n    }\n}\n\n//@SpringBootApplication // Using Spring Boot for simplicity\n//public class SpringSetterDiDemoApplication {\n//    public static void main(String[] args) {\n//        ApplicationContext context = SpringApplication.run(SpringSetterDiDemoApplication.class, args);\n//        UserService userService = context.getBean(UserService.class);\n//        userService.createUser(\"testUser\"); // Creating user: testUser, Log to console: User created: testUser\n//    }\n//}"
        }
      ]
    },
     {
      "id": "spring-core-ioc",
      "title": "Inversion of Control (IoC)",
      "description": "Understanding Inversion of Control (IoC) container in Spring, bean lifecycle, and ApplicationContext.",
      "difficulty": "beginner",
      "category": "spring-core",
      "explanation": "Inversion of Control (IoC) is a design principle where the control flow of a program is inverted compared to traditional control flow. In traditional programming, the application code is responsible for calling libraries and frameworks. In IoC, the framework takes control and calls the application code. In the context of Spring, the IoC container is the core of the framework. It is responsible for managing the lifecycle of beans (objects) and injecting dependencies.\n\n**Spring IoC Container**: The Spring IoC container is responsible for: \n    - **Bean Definition**: Reading configuration metadata (XML, annotations, Java config) that defines beans and their dependencies. \n    - **Bean Instantiation**: Creating instances of beans based on their definitions. \n    - **Bean Configuration**: Configuring beans by setting properties and injecting dependencies. \n    - **Bean Assembly (Wiring)**: Connecting beans together by injecting dependencies. \n    - **Bean Lifecycle Management**: Managing the lifecycle of beans, including initialization and destruction callbacks. \n\n**Bean Lifecycle**: Beans in Spring IoC container have a lifecycle, from creation to destruction. Key lifecycle phases are: \n    1. **Instantiation**: Spring container creates an instance of the bean class. \n    2. **Populating Properties**: Spring injects dependencies and sets properties of the bean. \n    3. **Initialization Callbacks**: If a bean implements `InitializingBean` interface, `afterPropertiesSet()` method is called. Or, if `init-method` is specified in configuration, that method is invoked. \n    4. **Bean is Ready for Use**: The bean is now ready to be used by the application. \n    5. **Destruction Callbacks**: When the container is shutting down or a bean is no longer needed (for prototype scope), destruction callbacks are invoked. If a bean implements `DisposableBean` interface, `destroy()` method is called. Or, if `destroy-method` is specified in configuration, that method is invoked. \n\n**ApplicationContext**: `ApplicationContext` is the central interface in Spring IoC container. It extends `BeanFactory` and provides more enterprise-level functionality like AOP integration, message resource handling, event publication, and web application features. `ApplicationContext` implementations (e.g., `ClassPathXmlApplicationContext`, `AnnotationConfigApplicationContext`, `WebApplicationContext`) are used to bootstrap Spring applications and manage beans. `ApplicationContext` is typically preferred over `BeanFactory` in most Spring applications due to its extended functionality and easier configuration.",
      "example": "// Spring IoC Container and Bean Lifecycle Example\n\nimport org.springframework.beans.factory.DisposableBean;\nimport org.springframework.beans.factory.InitializingBean;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.annotation.AnnotationConfigApplicationContext;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\nclass MyBean implements InitializingBean, DisposableBean {\n    public MyBean() {\n        System.out.println(\"Bean constructor called\");\n    }\n\n    @Override\n    public void afterPropertiesSet() throws Exception {\n        System.out.println(\"InitializingBean: afterPropertiesSet() called\");\n        // Initialization logic\n    }\n\n    @Override\n    public void destroy() throws Exception {\n        System.out.println(\"DisposableBean: destroy() called\");\n        // Cleanup logic\n    }\n\n    public void doSomething() {\n        System.out.println(\"Bean is doing something...\");\n    }\n\n    @Bean(initMethod = \"customInit\", destroyMethod = \"customDestroy\") // Example of custom init/destroy methods\n    public static MyBean anotherBean() {\n        return new MyBean();\n    }\n\n    public void customInit() {\n        System.out.println(\"Custom init-method: customInit() called\");\n    }\n\n    public void customDestroy() {\n        System.out.println(\"Custom destroy-method: customDestroy() called\");\n    }\n}\n\n@Configuration\nclass AppConfig {\n    @Bean\n    public MyBean myBean() {\n        return new MyBean();\n    }\n}\n\npublic class SpringIoCDemo {\n    public static void main(String[] args) {\n        ApplicationContext context = new AnnotationConfigApplicationContext(AppConfig.class);\n        MyBean bean = context.getBean(MyBean.class);\n        bean.doSomething();\n\n        ((AnnotationConfigApplicationContext) context).close(); // Close context to trigger destroy callbacks\n    }\n}",
      "keyPoints": [
        "Inversion of Control (IoC): Framework controls application flow.",
        "Spring IoC Container: Manages bean lifecycle, instantiation, configuration, wiring.",
        "Bean Lifecycle: Instantiation, Property Population, Initialization, Ready for Use, Destruction.",
        "`InitializingBean` and `DisposableBean` interfaces for lifecycle callbacks.",
        "Custom `init-method` and `destroy-method` in bean configuration.",
        "`ApplicationContext`: Central interface for Spring IoC container, extends `BeanFactory`.",
        "`ApplicationContext` provides enterprise-level features and is preferred over `BeanFactory`."
      ],
      "quiz": [
        {
          "question": "What is the primary responsibility of the Spring IoC container?",
          "options": ["Compiling Java code", "Managing bean lifecycle and dependencies", "Handling HTTP requests", "Managing database transactions"],
          "correctAnswer": 1
        },
        {
          "question": "Which interface in Spring is the central interface for the IoC container and provides enterprise-level features?",
          "options": ["BeanFactory", "ApplicationContext", "BeanRegistry", "ConfigurableBeanFactory"],
          "correctAnswer": 1
        },
        {
          "question": "Which of the following is NOT a phase in the Spring bean lifecycle?",
          "options": ["Bean Instantiation", "Property Population", "Bean Compilation", "Initialization Callbacks"],
          "correctAnswer": 2
        }
      ],
      "interactiveExamples": [
        {
          "title": "Bean Scopes - Singleton and Prototype",
          "code": "// Bean Scopes Example - Singleton and Prototype\n\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.annotation.AnnotationConfigApplicationContext;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.Scope;\n\nclass MyScopedBean {\n    private String message;\n\n    public MyScopedBean() {\n        System.out.println(\"MyScopedBean instance created\");\n    }\n\n    public void setMessage(String message) {\n        this.message = message;\n    }\n\n    public String getMessage() {\n        return message;\n    }\n}\n\n@Configuration\nclass ScopeConfig {\n    @Bean\n    @Scope(\"singleton\") // Default scope - Singleton\n    public MyScopedBean singletonBean() {\n        return new MyScopedBean();\n    }\n\n    @Bean\n    @Scope(\"prototype\") // Prototype scope - new instance each time\n    public MyScopedBean prototypeBean() {\n        return new MyScopedBean();\n    }\n}\n\npublic class BeanScopeDemo {\n    public static void main(String[] args) {\n        ApplicationContext context = new AnnotationConfigApplicationContext(ScopeConfig.class);\n\n        // Singleton scope - same instance\n        MyScopedBean singletonBean1 = context.getBean(\"singletonBean\", MyScopedBean.class);\n        MyScopedBean singletonBean2 = context.getBean(\"singletonBean\", MyScopedBean.class);\n        System.out.println(\"Singleton beans are same instance: \" + (singletonBean1 == singletonBean2)); // true\n\n        // Prototype scope - different instances\n        MyScopedBean prototypeBean1 = context.getBean(\"prototypeBean\", MyScopedBean.class);\n        MyScopedBean prototypeBean2 = context.getBean(\"prototypeBean\", MyScopedBean.class);\n        System.out.println(\"Prototype beans are same instance: \" + (prototypeBean1 == prototypeBean2)); // false\n    }\n}"
        }
      ]
    },
    {
      "id": "spring-core-spring-context",
      "title": "Spring Context",
      "description": "The role and configuration of Spring Application Context, bean definition, and context initialization.",
      "difficulty": "beginner",
      "category": "spring-core",
      "explanation": "The Spring Context, represented by the `ApplicationContext` interface, is the heart of the Spring Framework. It is the IoC container that manages beans and provides the runtime environment for Spring applications. The Spring Context is responsible for bootstrapping the application, loading bean definitions, creating and wiring beans, and managing their lifecycle.\n\n**Role of Spring Application Context**: \n    - **Bean Registry**: Holds bean definitions and manages bean instances. \n    - **Dependency Resolution**: Resolves dependencies between beans and injects them. \n    - **Bean Lifecycle Management**: Manages bean creation, initialization, and destruction. \n    - **Configuration Loading**: Loads bean definitions from various sources (XML, annotations, Java config). \n    - **Resource Loading**: Provides a unified way to access resources (e.g., files, classpath resources, URLs). \n    - **Event Publication**: Supports publishing and listening to application events. \n    - **Internationalization (i18n)**: Provides support for message resource handling and internationalization. \n    - **AOP Integration**: Integrates seamlessly with Spring AOP for aspect-oriented programming. \n\n**Bean Definition**: A bean definition describes how a bean should be created, configured, and managed by the Spring container. Bean definitions can be provided in several ways: \n    - **XML Configuration**: Bean definitions are specified in XML files. \n    - **Annotation-based Configuration**: Bean definitions are declared using annotations directly in the bean classes (e.g., `@Component`, `@Service`, `@Repository`, `@Controller`, `@Bean`). \n    - **Java-based Configuration (JavaConfig)**: Bean definitions are defined in Java classes using `@Configuration` and `@Bean` annotations. \n\n**Context Initialization**: The process of creating and initializing the Spring Application Context. Common ways to initialize ApplicationContext: \n    - **`ClassPathXmlApplicationContext`**: Loads context configuration from XML files in the classpath. \n    - **`FileSystemXmlApplicationContext`**: Loads context configuration from XML files in the file system. \n    - **`AnnotationConfigApplicationContext`**: Loads context configuration from annotated classes (JavaConfig). \n    - **`WebApplicationContext`**: Specialized context for web applications, typically initialized by a Servlet listener in web.xml. \n    - **Spring Boot Application**: Spring Boot simplifies context initialization significantly. Using `@SpringBootApplication` annotation and `SpringApplication.run()` method, Spring Boot automatically sets up and runs the application context.",
      "example": "// Spring Context Initialization Example - AnnotationConfigApplicationContext\n\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.annotation.AnnotationConfigApplicationContext;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\nclass MyService {\n    public void doService() {\n        System.out.println(\"Service is running...\");\n    }\n}\n\n@Configuration\nclass AppConfigContext {\n    @Bean\n    public MyService myServiceBean() {\n        return new MyService();\n    }\n}\n\npublic class SpringContextDemo {\n    public static void main(String[] args) {\n        // Initialize ApplicationContext using AnnotationConfigApplicationContext\n        ApplicationContext context = new AnnotationConfigApplicationContext(AppConfigContext.class);\n\n        // Get bean from context\n        MyService service = context.getBean(MyService.class);\n        service.doService(); // Service is running...\n\n        ((AnnotationConfigApplicationContext) context).close();\n    }\n}",
      "keyPoints": [
        "Spring Application Context: IoC container, manages beans and runtime environment.",
        "Roles of ApplicationContext: Bean registry, dependency resolution, lifecycle management, configuration loading, resource loading, event publication, i18n, AOP integration.",
        "Bean Definition: Describes how beans are created and configured.",
        "Bean Definition Methods: XML Configuration, Annotation-based Configuration, Java-based Configuration (JavaConfig).",
        "Context Initialization: Creating and initializing ApplicationContext.",
        "Common Context Implementations: `ClassPathXmlApplicationContext`, `AnnotationConfigApplicationContext`, `WebApplicationContext`.",
        "Spring Boot simplifies context initialization with `@SpringBootApplication` and `SpringApplication.run()`."
      ],
      "quiz": [
        {
          "question": "What is the primary interface representing the Spring Context?",
          "options": ["BeanFactory", "BeanRegistry", "ApplicationContext", "ConfigurableApplicationContext"],
          "correctAnswer": 2
        },
        {
          "question": "Which of the following is NOT a way to define bean definitions in Spring?",
          "options": ["XML Configuration", "Annotation-based Configuration", "Java-based Configuration", "Database Configuration"],
          "correctAnswer": 3
        },
        {
          "question": "Which ApplicationContext implementation is used to load configuration from annotated classes (JavaConfig)?",
          "options": ["ClassPathXmlApplicationContext", "FileSystemXmlApplicationContext", "AnnotationConfigApplicationContext", "WebApplicationContext"],
          "correctAnswer": 2
        }
      ],
      "interactiveExamples": [
        {
          "title": "XML Configuration - ClassPathXmlApplicationContext",
          "code": "// XML Configuration Example (beans.xml in classpath)\n\n// beans.xml (in src/main/resources or classpath)\n// <beans xmlns=\"http://www.springframework.org/schema/beans\"\n//        xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n//        xsi:schemaLocation=\"http://www.springframework.org/schema/beans\n//                           http://www.springframework.org/schema/beans/spring-beans.xsd\">\n//     <bean id=\"myXmlService\" class=\"com.example.MyXmlService\"/>\n// </beans>\n\n// MyXmlService.java\n// package com.example;\n// public class MyXmlService {\n//     public void doXmlService() {\n//         System.out.println(\"XML Service is running...\");\n//     }\n// }\n\n// SpringXmlContextDemo.java\n// import com.example.MyXmlService;\n// import org.springframework.context.ApplicationContext;\n// import org.springframework.context.support.ClassPathXmlApplicationContext;\n\n// public class SpringXmlContextDemo {\n//     public static void main(String[] args) {\n//         ApplicationContext context = new ClassPathXmlApplicationContext(\"beans.xml\");\n//         MyXmlService service = context.getBean(\"myXmlService\", MyXmlService.class);\n//         service.doXmlService(); // XML Service is running...\n//         ((ClassPathXmlApplicationContext) context).close();\n//     }\n// }",
          "comment": "Note: You need to create beans.xml file in your classpath and MyXmlService class in com.example package to run this example."
        }
      ]
    },
    {
      "id": "spring-boot-autoconfiguration",
      "title": "Auto-configuration in Spring Boot",
      "description": "Understanding how auto-configuration simplifies Spring Boot setup and reduces boilerplate code.",
      "difficulty": "beginner",
      "category": "spring-boot",
      "explanation": "Auto-configuration is a flagship feature of Spring Boot that dramatically simplifies application setup. It intelligently configures your Spring application based on the dependencies you've added to your project. When Spring Boot starts, it examines your classpath, inspects available dependencies, and automatically configures beans that it thinks you'll need. This drastically reduces the amount of manual configuration required, letting developers focus on business logic rather than infrastructure setup.\n\n**How Auto-configuration Works**: Spring Boot's auto-configuration is enabled by the `@EnableAutoConfiguration` annotation (often implicitly included through `@SpringBootApplication`). It works based on several factors:\n    - **Classpath Scanning**: Spring Boot examines the dependencies on your classpath. For example, if it finds `spring-webmvc` on the classpath, it infers that you are building a web application and configures components like `DispatcherServlet`, `ViewResolvers`, etc.\n    - **Conditional Configuration**: Auto-configuration is conditional. It uses `@ConditionalOnClass`, `@ConditionalOnMissingBean`, `@ConditionalOnProperty`, and other conditional annotations to decide whether to apply a particular configuration. For instance, a data source auto-configuration will only kick in if a suitable JDBC driver is on the classpath and a data source bean is not already defined by the user.\n    - **Starter Dependencies**: Spring Boot Starters are key to auto-configuration. Starters are curated sets of dependency descriptors that include all the necessary dependencies for a specific functionality (e.g., `spring-boot-starter-web`, `spring-boot-starter-data-jpa`). When you include a starter, you bring in a set of dependencies that Spring Boot understands and can auto-configure.\n\n**Customizing Auto-configuration**: While auto-configuration is powerful, you can customize or override it:\n    - **Excluding Auto-configurations**: You can exclude specific auto-configurations using the `exclude` attribute of `@EnableAutoConfiguration` or `@SpringBootApplication`. \n    - **Providing Your Own Configurations**: If you define your own bean of a type that Spring Boot would auto-configure, your bean will take precedence, and auto-configuration will back off. For example, if you define your own `DataSource` bean, Spring Boot will not auto-configure one.\n    - **`application.properties` or `application.yml`**: Many auto-configurations are further customizable through properties in `application.properties` or `application.yml`. Spring Boot provides sensible defaults, but you can adjust settings like server port, database connection details, etc., via configuration properties.",
      "example": "// Auto-configuration Example (Conceptual - No explicit code needed to enable)\n\n// Add spring-boot-starter-web dependency to pom.xml/build.gradle\n// <dependency>\n//     <groupId>org.springframework.boot</groupId>\n//     <artifactId>spring-boot-starter-web</artifactId>\n// </dependency>\n\n// @SpringBootApplication\n// public class MyApp {\n//     public static void main(String[] args) {\n//         SpringApplication.run(MyApp.class, args);\n//     }\n// }\n\n// When you run MyApp, Spring Boot auto-configures: \n// - Embedded Tomcat server\n// - DispatcherServlet for MVC\n// - Default ViewResolvers\n// - Jackson for JSON processing (if jackson-databind is on classpath)\n// - ... and many other web-related beans without explicit configuration.",
      "keyPoints": [
        "Auto-configuration: Automatic configuration of Spring application based on classpath dependencies.",
        "`@EnableAutoConfiguration` (via `@SpringBootApplication`) enables auto-configuration.",
        "Classpath scanning, conditional configuration, and starter dependencies drive auto-configuration.",
        "Conditional annotations (e.g., `@ConditionalOnClass`, `@ConditionalOnMissingBean`) control auto-configuration.",
        "Starter dependencies bundle necessary dependencies for specific functionalities.",
        "Customization: Exclude auto-configurations, override beans, configure properties in `application.properties/yml`.",
        "Reduces boilerplate configuration, speeds up development, promotes convention over configuration."
      ],
      "quiz": [
        {
          "question": "What is the primary purpose of auto-configuration in Spring Boot?",
          "options": ["To manually configure all beans.", "To automatically configure Spring application based on dependencies.", "To disable Spring features.", "To complicate application setup."],
          "correctAnswer": 1
        },
        {
          "question": "Which annotation enables auto-configuration in Spring Boot?",
          "options": ["@Configuration", "@ComponentScan", "@EnableAutoConfiguration", "@SpringBootApplication"],
          "correctAnswer": 2
        },
        {
          "question": "How does Spring Boot decide which configurations to apply during auto-configuration?",
          "options": ["Based on manual XML configuration.", "Based on classpath dependencies and conditional annotations.", "Based on randomly selected configurations.", "Based on operating system settings."],
          "correctAnswer": 1
        }
      ],
      "interactiveExamples": [
        {
          "title": "Conditional Auto-configuration - Example with DataSource",
          "code": "// Conditional Auto-configuration - DataSource Example (Conceptual)\n\n// 1. If you add spring-boot-starter-jdbc dependency:\n// <dependency>\n//     <groupId>org.springframework.boot</groupId>\n//     <artifactId>spring-boot-starter-jdbc</artifactId>\n// </dependency>\n\n// 2. AND you have a suitable JDBC driver on classpath (e.g., H2, MySQL driver):\n// <dependency>\n//     <groupId>com.h2database</groupId>\n//     <artifactId>h2</artifactId>\n//     <scope>runtime</scope>\n// </dependency>\n\n// 3. AND you DON'T define your own DataSource bean:\n// @Bean // If you define a DataSource bean, auto-configuration backs off\n// public DataSource dataSource() { ... }\n\n// THEN, Spring Boot's DataSourceAutoConfiguration kicks in and auto-configures a DataSource bean for you.\n// You can then inject and use DataSource in your application without explicit DataSource configuration.\n\n// @Autowired\n// private DataSource dataSource;\n\n// This demonstrates conditional auto-configuration: it happens only when certain conditions (dependencies, missing beans) are met."
        }
      ]
    },
    {
      "id": "spring-boot-starter-dependencies",
      "title": "Starter Dependencies in Spring Boot",
      "description": "Using starter dependencies to manage project dependencies efficiently and reduce dependency management overhead.",
      "difficulty": "beginner",
      "category": "spring-boot",
      "explanation": "Spring Boot Starters are dependency descriptors that provide a convenient way to include all the necessary dependencies for a specific functionality in your Spring Boot application. Starters are essentially curated sets of dependencies that are grouped together based on common use cases. They aim to simplify dependency management and reduce the effort required to set up a Spring Boot project.\n\n**Benefits of Starter Dependencies**: \n    - **Simplified Dependency Management**: Instead of manually adding individual dependencies, you can include a single starter dependency, which brings in all related dependencies transitively. This reduces the complexity of `pom.xml` or `build.gradle` files. \n    - **Reduced Dependency Conflicts**: Starters are designed to work together harmoniously. They ensure that compatible versions of dependencies are used, minimizing the risk of dependency conflicts. \n    - **Auto-configuration Enablement**: Starters are tightly integrated with auto-configuration. Including a starter often triggers relevant auto-configurations, further simplifying setup. \n    - **Feature Grouping**: Starters logically group dependencies by feature or functionality. For example, `spring-boot-starter-web` includes dependencies for building web applications, `spring-boot-starter-data-jpa` for JPA-based data access, etc. \n    - **Naming Convention**: Starter dependencies follow a consistent naming convention: `spring-boot-starter-*`, where `*` indicates the specific area of functionality (e.g., `web`, `data-jpa`, `security`, `test`).\n\n**Common Spring Boot Starters**: \n    - `spring-boot-starter-web`: For building web applications, including Spring MVC, embedded Tomcat, Jackson, validation, etc. \n    - `spring-boot-starter-data-jpa`: For using Spring Data JPA to access relational databases. Includes JPA, Hibernate, Spring Data JPA. \n    - `spring-boot-starter-security`: For integrating Spring Security for authentication and authorization. \n    - `spring-boot-starter-test`: For writing tests. Includes JUnit, Mockito, Spring Test, AssertJ, etc. \n    - `spring-boot-starter-thymeleaf`: For using Thymeleaf as a template engine for web views. \n    - `spring-boot-starter-actuator`: For enabling Spring Boot Actuator features for monitoring and management. \n    - `spring-boot-starter-mail`: For sending emails using JavaMail.\n    - `spring-boot-starter-jdbc`: For using JDBC to access databases.\n    - `spring-boot-starter-cache`: For enabling Spring's caching abstraction.",
      "example": "// Starter Dependencies Example - pom.xml (Maven)\n\n// <dependencies>\n//     <!-- Spring Boot Starter Web -->\n//     <dependency>\n//         <groupId>org.springframework.boot</groupId>\n//         <artifactId>spring-boot-starter-web</artifactId>\n//     </dependency>\n\n//     <!-- Spring Boot Starter Data JPA -->\n//     <dependency>\n//         <groupId>org.springframework.boot</groupId>\n//         <artifactId>spring-boot-starter-data-jpa</artifactId>\n//     </dependency>\n\n//     <!-- Spring Boot Starter Test -->\n//     <dependency>\n//         <groupId>org.springframework.boot</groupId>\n//         <artifactId>spring-boot-starter-test</artifactId>\n//         <scope>test</scope>\n//     </dependency>\n// </dependencies>\n\n// By including these starters, you get all necessary dependencies for web development, JPA data access, and testing without listing each dependency individually.",
      "keyPoints": [
        "Starter dependencies: Curated sets of dependency descriptors in Spring Boot.",
        "Simplify dependency management by including a single starter instead of many individual dependencies.",
        "Reduce dependency conflicts by ensuring compatible versions.",
        "Enable auto-configuration for related functionalities.",
        "Group dependencies logically by feature (e.g., web, data-jpa, security).",
        "Naming convention: `spring-boot-starter-*`.",
        "Common starters: `web`, `data-jpa`, `security`, `test`, `thymeleaf`, `actuator`, etc."
      ],
      "quiz": [
        {
          "question": "What is the main purpose of Spring Boot starter dependencies?",
          "options": ["To complicate dependency management.", "To simplify dependency management and reduce boilerplate.", "To disable auto-configuration.", "To introduce dependency conflicts."],
          "correctAnswer": 1
        },
        {
          "question": "Which starter dependency is used for building web applications with Spring MVC?",
          "options": ["spring-boot-starter-data-jpa", "spring-boot-starter-security", "spring-boot-starter-web", "spring-boot-starter-test"],
          "correctAnswer": 2
        },
        {
          "question": "What naming convention do Spring Boot starter dependencies follow?",
          "options": ["spring-starter-*", "spring-boot-module-*", "spring-boot-starter-*", "spring-module-starter-*"],
          "correctAnswer": 2
        }
      ],
      "interactiveExamples": [
        {
          "title": "Exploring Starter Dependencies - spring-boot-starter-web",
          "code": "// Exploring spring-boot-starter-web (Conceptual)\n\n// When you include spring-boot-starter-web, you transitively get dependencies like:\n// - spring-webmvc: Core Spring MVC framework.\n// - spring-web: Web support in Spring.\n// - spring-boot-starter-tomcat: Embedded Tomcat server.\n// - jackson-databind: For JSON processing.\n// - validation-api: For bean validation (JSR-303).\n// - ... and many others.\n\n// You can inspect your project's dependency tree (e.g., using Maven's 'mvn dependency:tree' or Gradle's dependency report) to see all transitive dependencies brought in by a starter.\n\n// Starter dependencies are essentially pre-packaged dependency sets that make it easy to get started with specific types of Spring Boot applications."
        }
      ]
    },
    {
      "id": "spring-boot-embedded-servers",
      "title": "Embedded Servers in Spring Boot",
      "description": "Understanding embedded servers in Spring Boot (Tomcat, Jetty, Undertow) and their configuration.",
      "difficulty": "beginner",
      "category": "spring-boot",
      "explanation": "Spring Boot makes it incredibly easy to create stand-alone, production-ready Spring applications that can be run directly. A key aspect of this is **embedded servers**. Instead of requiring a separate application server (like traditional WAR deployments), Spring Boot applications typically embed a server directly within the application JAR file. This creates self-contained, executable applications.\n\n**Types of Embedded Servers**: Spring Boot supports several embedded servlet containers:\n    - **Tomcat**: Default embedded server in Spring Boot. Widely used, mature, and robust. \n    - **Jetty**: Another popular servlet container, known for its lightweight nature and extensibility. \n    - **Undertow**: A flexible, performant, and lightweight web server from Red Hat, designed for modern web applications. \n    - **Netty**: While technically not a servlet container, Netty can also be used in Spring Boot for reactive web applications (using Spring WebFlux). It's an asynchronous event-driven network application framework.\n\n**Why Embedded Servers?**: \n    - **Simplified Deployment**: Applications are packaged as executable JARs, making deployment straightforward. No need to deploy WAR files to separate application servers. \n    - **Version Consistency**: Ensures consistent server version across different environments (development, testing, production). Reduces \"works on my machine\" issues related to server version discrepancies. \n    - **Lightweight and Fast Startup**: Embedded servers are optimized for Spring Boot and often lead to faster application startup times compared to deploying to external servers. \n    - **Easy Configuration**: Spring Boot provides convenient ways to configure embedded servers through `application.properties` or `application.yml`.\n\n**Configuring Embedded Servers**: You can configure embedded servers in Spring Boot through:\n    - **`application.properties` or `application.yml`**: Common server properties like `server.port`, `server.servlet.context-path`, `server.ssl.*`, etc., can be configured here. \n    - **Programmatic Configuration**: You can programmatically configure the embedded server using `WebServerFactoryCustomizer` beans. This provides more fine-grained control. \n    - **Dependency Management**: You can switch between different embedded servers by changing dependencies in your `pom.xml` or `build.gradle`. For example, to switch from Tomcat to Jetty, exclude `spring-boot-starter-tomcat` and include `spring-boot-starter-jetty`.\n\n**Default Server**: Tomcat is the default embedded server if you use `spring-boot-starter-web` or `spring-boot-starter-webflux`. If you don't explicitly include a web starter, no embedded server is configured.",
      "example": "// Embedded Servers Configuration Example - application.properties\n\n// server.port=8081        // Change default port (8080) to 8081\n// server.servlet.context-path=/myapp  // Set context path to /myapp\n\n// Example of switching to Jetty (pom.xml)\n// <!-- Exclude Tomcat -->\n// <dependency>\n//     <groupId>org.springframework.boot</groupId>\n//     <artifactId>spring-boot-starter-web</artifactId>\n//     <exclusions>\n//         <exclusion>\n//             <groupId>org.springframework.boot</groupId>\n//             <artifactId>spring-boot-starter-tomcat</artifactId>\n//         </exclusion>\n//     </exclusions>\n// </dependency>\n\n// <!-- Include Jetty -->\n// <dependency>\n//     <groupId>org.springframework.boot</groupId>\n//     <artifactId>spring-boot-starter-jetty</artifactId>\n// </dependency>",
      "keyPoints": [
        "Embedded servers: Servers packaged directly within Spring Boot application JARs.",
        "Types: Tomcat (default), Jetty, Undertow, Netty (for reactive).",
        "Benefits: Simplified deployment, version consistency, lightweight, fast startup, easy configuration.",
        "Configuration via `application.properties/yml` and `WebServerFactoryCustomizer` beans.",
        "Switch servers by changing dependencies (exclude default Tomcat, include desired server starter).",
        "Tomcat is default for web starters; no server if web starter is not included.",
        "Create stand-alone, executable JAR applications."
      ],
      "quiz": [
        {
          "question": "Which is the default embedded server in Spring Boot?",
          "options": ["Jetty", "Undertow", "Tomcat", "Netty"],
          "correctAnswer": 2
        },
        {
          "question": "What is the main advantage of using embedded servers in Spring Boot?",
          "options": ["Increased application complexity.", "Simplified deployment as executable JARs.", "Requirement for separate application server.", "Slower application startup."],
          "correctAnswer": 1
        },
        {
          "question": "How can you configure the port of an embedded server in Spring Boot?",
          "options": ["Only programmatically.", "Only by changing dependencies.", "Through `application.properties` or `application.yml`.", "It's not configurable."],
          "correctAnswer": 2
        }
      ],
      "interactiveExamples": [
        {
          "title": "Changing Embedded Server Port",
          "code": "// Example: Setting server port in application.properties\n\n// Create a file application.properties in src/main/resources\n// Add the line: server.port=8085\n\n// Run your Spring Boot application. It will now start on port 8085 instead of the default 8080.\n\n// You can verify this by accessing your application in a web browser at http://localhost:8085 (if it's a web application).\n\n// This simple configuration demonstrates how easily you can customize embedded server settings using application properties."
        }
      ]
    },
    {
      "id": "spring-boot-actuator-basics",
      "title": "Spring Boot Actuator Basics",
      "description": "Introduction to Spring Boot Actuator for monitoring and managing Spring Boot applications.",
      "difficulty": "intermediate",
      "category": "spring-boot",
      "explanation": "Spring Boot Actuator is a powerful module that provides production-ready features to monitor and manage your Spring Boot application. It exposes operational information about your application through HTTP endpoints or JMX. Actuator helps you understand what's happening inside your running application, diagnose issues, and gather metrics. It's essential for production deployments and operational monitoring.\n\n**Key Features of Actuator**: \n    - **Endpoints**: Actuator exposes various endpoints that provide information about the application's health, metrics, environment, beans, configuration, and more. These endpoints are typically accessed via HTTP or JMX. \n    - **Health Checks**: `/actuator/health` endpoint provides information about the application's health status. It can be used by monitoring systems to check if the application is up and running. Health checks can include status of dependencies like databases, message brokers, etc. \n    - **Metrics**: `/actuator/metrics` endpoint exposes application metrics, such as JVM memory usage, HTTP request counts, database connection pool metrics, custom application metrics, etc. Metrics are crucial for performance monitoring and capacity planning. \n    - **Info Endpoint**: `/actuator/info` endpoint displays arbitrary application information, which can be customized to include build details, git commit ID, etc. \n    - **Environment Endpoint**: `/actuator/env` endpoint shows the current Spring Environment properties, including system properties, environment variables, application properties, etc. (Sensitive properties are masked by default). \n    - **Beans Endpoint**: `/actuator/beans` lists all Spring beans in your application context. \n    - **Configuration Endpoint**: `/actuator/configprops` displays the auto-configuration properties and user-defined configuration properties applied to your application. \n    - **Loggers Endpoint**: `/actuator/loggers` allows you to manage and configure application loggers at runtime (e.g., change log levels). \n    - **Thread Dump Endpoint**: `/actuator/threaddump` provides a snapshot of thread activity in the JVM, useful for diagnosing performance issues or deadlocks. \n    - **Heap Dump Endpoint**: `/actuator/heapdump` allows you to download a heap dump of the JVM for memory analysis (disabled by default due to security concerns).\n\n**Enabling Actuator**: To enable Actuator, you need to include the `spring-boot-starter-actuator` dependency in your project:\n\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-starter-actuator</artifactId>\n</dependency>\n```\n\nAfter adding the dependency, many actuator endpoints become available by default under the `/actuator` base path. You can access them via HTTP (e.g., `http://localhost:8080/actuator/health`).",
      "example": "// Spring Boot Actuator Example - Accessing Health Endpoint\n\n// 1. Add spring-boot-starter-actuator dependency to your project.\n\n// 2. Run your Spring Boot application.\n\n// 3. Access the health endpoint in your browser or using curl:\n//    http://localhost:8080/actuator/health\n\n// Default response will be something like:\n// {\"status\":\"UP\"}  // Indicating application is healthy.\n\n// If you have database or other health indicators configured, the response might be more detailed, showing status of those components as well.\n\n// Example of a more detailed health response (with database health indicator):\n// {\"status\":\"UP\",\n//  \"components\": {\n//    \"db\": {\n//      \"status\":\"UP\",\n//      \"details\": {\n//        \"database\":\"H2\",\n//        \"validationQuery\":\"isValid()\",\n//        \"result\":1\n//      }\n//    },\n//    \"diskSpace\":{\"status\":\"UP\", ...}\n//  }\n// }",
      "keyPoints": [
        "Spring Boot Actuator: Module for monitoring and managing Spring Boot applications in production.",
        "Exposes operational information via HTTP endpoints or JMX.",
        "Key endpoints: `/health`, `/metrics`, `/info`, `/env`, `/beans`, `/configprops`, `/loggers`, `/threaddump`, `/heapdump`.",
        "`/health` endpoint provides application health status.",
        "`/metrics` endpoint exposes application metrics (JVM, HTTP, custom).",
        "`/info` endpoint for application information, `/env` for environment properties, `/beans` for bean list, etc.",
        "Enable Actuator by adding `spring-boot-starter-actuator` dependency.",
        "Access endpoints via HTTP under `/actuator` base path (e.g., `/actuator/health`)."
      ],
      "quiz": [
        {
          "question": "What is the primary purpose of Spring Boot Actuator?",
          "options": ["To build web applications.", "To manage database transactions.", "To monitor and manage Spring Boot applications in production.", "To handle security in Spring Boot."],
          "correctAnswer": 2
        },
        {
          "question": "Which Actuator endpoint is used to check the health status of a Spring Boot application?",
          "options": ["/actuator/metrics", "/actuator/info", "/actuator/health", "/actuator/env"],
          "correctAnswer": 2
        },
        {
          "question": "How do you enable Spring Boot Actuator in your application?",
          "options": ["By adding `@EnableActuator` annotation.", "By adding `spring-boot-starter-actuator` dependency.", "It's enabled by default.", "By configuring in `application.properties`."],
          "correctAnswer": 1
        }
      ],
      "interactiveExamples": [
        {
          "title": "Exploring Actuator Endpoints in Browser",
          "code": "// Interactive Example: Accessing Actuator Endpoints in Browser\n\n// 1. Ensure you have spring-boot-starter-actuator dependency in your project.\n// 2. Run your Spring Boot application.\n// 3. Open your web browser and try accessing these URLs:\n//    - http://localhost:8080/actuator/health  (Health status)\n//    - http://localhost:8080/actuator/info    (Application info)\n//    - http://localhost:8080/actuator/metrics  (Application metrics - might be verbose)\n//    - http://localhost:8080/actuator/env      (Environment properties - be cautious about exposing sensitive info in production).\n\n// 4. Observe the JSON responses returned by these endpoints. They provide valuable operational insights into your running application.\n\n// Note: Actuator endpoint paths and security can be customized in application properties. Default base path is /actuator."
        }
      ]
    },
    {
      "id": "spring-boot-profiles",
      "title": "Spring Boot Profiles",
      "description": "Managing configurations for different environments (dev, test, prod) using Spring Boot Profiles.",
      "difficulty": "intermediate",
      "category": "spring-boot",
      "explanation": "Spring Boot Profiles provide a way to manage different configurations for various environments such as development, testing, staging, and production. Profiles allow you to activate specific parts of your application configuration only when needed, based on the environment in which the application is running. This is crucial for managing environment-specific settings like database connections, logging levels, external service URLs, and feature toggles.\n\n**How Profiles Work**: Spring Boot profiles are activated through several mechanisms:\n    - **`spring.profiles.active` Property**: Set in `application.properties` or `application.yml`, environment variables, command-line arguments, or programmatically. You can specify a comma-separated list of active profiles. \n    - **Environment Variables**: Set `SPRING_PROFILES_ACTIVE` environment variable. \n    - **Command-line Arguments**: Pass `--spring.profiles.active=profileName` when starting the application. \n    - **Programmatic Activation**: Use `SpringApplicationBuilder` to programmatically set active profiles. \n\n**Profile-Specific Configuration Files**: Spring Boot supports profile-specific application property files. You can create files named `application-{profile}.properties` or `application-{profile}.yml` (e.g., `application-dev.properties`, `application-prod.yml`). These files will be loaded and applied only when the corresponding profile is active, in addition to the default `application.properties` or `application.yml`. Profile-specific properties override the default properties.\n\n**`@Profile` Annotation**: The `@Profile` annotation is used to conditionally enable or disable Spring components (beans, configurations, etc.) based on active profiles. You can annotate classes or methods with `@Profile(\"profileName\")`. The component will only be registered in the application context if the specified profile is active. You can use logical operators like `!` (not), `&` (and), `|` (or) in `@Profile` expressions.\n\n**Use Cases for Profiles**: \n    - **Database Configuration**: Use different database connections for dev, test, and prod environments. \n    - **Logging Levels**: Set more verbose logging in development and less verbose in production. \n    - **External Service URLs**: Configure different URLs for external APIs in different environments. \n    - **Feature Flags**: Enable or disable certain features based on the active profile. \n    - **Mock Implementations**: Use mock implementations of services in test profiles. \n    - **Security Settings**: Apply different security configurations based on the environment.",
      "example": "// Spring Boot Profiles Example - Profile-specific properties and @Profile annotation\n\n// application.properties (default properties)\n// app.message=Default Message\n\n// application-dev.properties (dev profile properties)\n// app.message=Development Message\n// server.port=8081\n\n// application-prod.properties (prod profile properties)\n// app.message=Production Message\n// server.port=80\n\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.boot.CommandLineRunner;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Profile;\n\n@SpringBootApplication\npublic class SpringProfilesDemoApplication {\n\n    @Value(\"${app.message}\")\n    private String message;\n\n    public static void main(String[] args) {\n        SpringApplication.run(SpringProfilesDemoApplication.class, args);\n    }\n\n    @Bean\n    CommandLineRunner runner() {\n        return args -> {\n            System.out.println(\"Active Profile Message: \" + message);\n        };\n    }\n\n    @Bean\n    @Profile(\"dev\") // Only active in 'dev' profile\n    CommandLineRunner devRunner() {\n        return args -> {\n            System.out.println(\"Dev profile specific runner\");\n        };\n    }\n\n    @Bean\n    @Profile(\"!dev\") // Active in profiles other than 'dev'\n    CommandLineRunner nonDevRunner() {\n        return args -> {\n            System.out.println(\"Non-dev profile specific runner\");\n        };\n    }\n}",
      "keyPoints": [
        "Spring Boot Profiles: Manage configurations for different environments (dev, test, prod).",
        "Activate profiles using `spring.profiles.active` property, environment variables, command-line arguments.",
        "Profile-specific configuration files: `application-{profile}.properties/yml`.",
        "`@Profile` annotation: Conditionally enable/disable components based on active profiles.",
        "Profile-specific properties override default properties.",
        "Use cases: Database config, logging levels, service URLs, feature flags, mock implementations, security settings.",
        "Logical operators in `@Profile` expressions: `!`, `&`, `|`."
      ],
      "quiz": [
        {
          "question": "What is the primary purpose of Spring Boot Profiles?",
          "options": ["To manage application logging.", "To handle security configurations.", "To manage configurations for different environments.", "To define bean scopes."],
          "correctAnswer": 2
        },
        {
          "question": "How do you specify active profiles in Spring Boot?",
          "options": ["Using `@ActiveProfiles` annotation in code.", "By setting `spring.profiles.active` property.", "Only through environment variables.", "Only through command-line arguments."],
          "correctAnswer": 1
        },
        {
          "question": "What is the naming convention for profile-specific configuration files?",
          "options": ["profile-{profile}.properties", "app-{profile}.properties", "application-{profile}.properties", "{profile}-application.properties"],
          "correctAnswer": 2
        }
      ],
      "interactiveExamples": [
        {
          "title": "Activating Profiles via Command Line",
          "code": "// Interactive Example: Activating Spring Boot Profiles via Command Line\n\n// 1. Create application.properties and application-dev.properties (as in example).\n// 2. Package your Spring Boot application as a JAR file (e.g., using 'mvn package' or 'gradle build').\n// 3. Run the JAR without any profile active:\n//    java -jar your-application.jar\n//    (Observe output - default profile behavior)\n\n// 4. Run the JAR with 'dev' profile active:\n//    java -jar your-application.jar --spring.profiles.active=dev\n//    (Observe output - 'dev' profile behavior, e.g., different message, port 8081)\n\n// 5. Try running with 'prod' profile (if you have application-prod.properties):\n//    java -jar your-application.jar --spring.profiles.active=prod\n//    (Observe 'prod' profile behavior).\n\n// This demonstrates how command-line arguments can be used to activate different Spring Boot profiles and load environment-specific configurations."
        }
      ]
    },
    {
      "id": "spring-boot-devtools",
      "title": "Spring Boot DevTools",
      "description": "Using Spring Boot DevTools for rapid development and hot reloading, improving developer productivity.",
      "difficulty": "beginner",
      "category": "spring-boot",
      "explanation": "Spring Boot DevTools is a set of development-time tools that enhance the development experience with Spring Boot applications. It provides features like automatic application restarts, LiveReload for browser refresh, property defaults for development, and more. DevTools aims to speed up the development cycle by reducing the time spent on application restarts and manual browser refreshes after code changes.\n\n**Key Features of DevTools**: \n    - **Automatic Restart**: When DevTools is active, any change to classpath resources (e.g., Java code, templates, properties files) triggers an automatic restart of the application. This restart is faster than a full application startup, as it reloads only the changed parts. \n    - **LiveReload**: DevTools includes a LiveReload server. When static resources (e.g., HTML, CSS, JavaScript files) are changed, LiveReload automatically triggers a browser refresh, so you can see changes instantly in the browser without manual refresh. \n    - **Property Defaults**: DevTools provides sensible property defaults for development environments. For example, caching is disabled for templates and static resources, making development iterations faster. \n    - **Remote Application Restart**: DevTools can be used to trigger restarts of remote applications. \n    - **Global Settings**: DevTools properties can be configured globally in `$HOME/.spring-boot-devtools.properties` to apply settings across all Spring Boot DevTools enabled applications. \n    - **Exclude Restart**: You can exclude specific resources from triggering restarts using `spring.devtools.restart.exclude` property. \n    - **Restart Classloader**: DevTools uses two classloaders: base classloader (for dependencies) and restart classloader (for application code). Only restart classloader is reloaded on changes, making restarts faster.\n\n**Enabling DevTools**: To enable DevTools, simply add the `spring-boot-devtools` dependency to your project:\n\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-devtools</artifactId>\n    <optional>true</optional> <!-- Important: Mark as optional for production builds -->\n</dependency>\n```\n\n**Important**: DevTools should be disabled or marked as optional (`<optional>true</optional>` in Maven, `optional = true` in Gradle) for production builds. DevTools is intended for development-time use and may introduce security risks if left enabled in production environments.",
      "example": "// Spring Boot DevTools Example - Automatic Restart and LiveReload (Conceptual)\n\n// 1. Add spring-boot-devtools dependency to your project (pom.xml or build.gradle).\n// 2. Run your Spring Boot application.\n// 3. Make a change to a Java file (e.g., in a Controller or Service).\n// 4. Save the file. Observe that Spring Boot application automatically restarts in the background.\n// 5. Make a change to a static resource file (e.g., HTML template).\n// 6. Save the file. Observe that your browser automatically refreshes (if LiveReload browser extension is installed).\n\n// No specific code changes are needed in your application to enable DevTools features. Just adding the dependency is usually sufficient to get automatic restarts and LiveReload for development." ,
      "keyPoints": [
        "Spring Boot DevTools: Development-time tools for enhanced developer experience.",
        "Automatic application restarts on classpath resource changes.",
        "LiveReload: Automatic browser refresh for static resource changes.",
        "Property defaults for development (e.g., caching disabled).",
        "Remote application restart capability.",
        "Configure global DevTools settings in `$HOME/.spring-boot-devtools.properties`.",
        "Disable or mark as optional for production builds due to security risks.",
        "Uses two classloaders for faster restarts."
      ],
      "quiz": [
        {
          "question": "What is the primary benefit of using Spring Boot DevTools?",
          "options": ["Improved production performance.", "Enhanced security features.", "Rapid development and improved developer productivity.", "Database management tools."],
          "correctAnswer": 2
        },
        {
          "question": "Which feature of DevTools automatically restarts the Spring Boot application on code changes?",
          "options": ["LiveReload", "Remote Restart", "Automatic Restart", "Property Defaults"],
          "correctAnswer": 2
        },
        {
          "question": "Should Spring Boot DevTools be enabled in production environments?",
          "options": ["Yes, it improves production performance.", "Yes, it's required for application startup.", "No, it should be disabled or optional for production.", "It depends on the application type."],
          "correctAnswer": 2
        }
      ],
      "interactiveExamples": [
        {
          "title": "Demonstrating Automatic Restart with DevTools",
          "code": "// Interactive Example: Demonstrating Automatic Restart with Spring Boot DevTools\n\n// 1. Add spring-boot-devtools dependency to your project.\n// 2. Create a simple Spring Boot web application with a Controller that returns a message.\n// 3. Run the application.\n// 4. Open the Controller class in your IDE and modify the message returned by the endpoint.\n// 5. Save the Controller file.\n// 6. Observe the console output - you should see Spring Boot application restarting automatically.\n// 7. Access the endpoint in your browser again - you will see the updated message without manually restarting the application.\n\n// This demonstrates the automatic restart feature of DevTools, saving development time."
        }
      ]
    },
    {
      "id": "spring-boot-testing-basics",
      "title": "Spring Boot Testing Basics",
      "description": "Introduction to testing Spring Boot applications: Unit tests, Integration tests, and testing slices.",
      "difficulty": "intermediate",
      "category": "spring-testing",
      "explanation": "Testing is a crucial part of software development, and Spring Boot provides excellent support for writing various types of tests for your applications. Spring Boot testing framework is built on top of Spring TestContext Framework and provides convenient annotations and utilities to simplify testing. Common types of tests in Spring Boot applications are:\n\n**Unit Tests**: Focus on testing individual components (classes, methods) in isolation. Unit tests should be fast and verify the logic of a single unit of code without involving external dependencies or Spring container. Mocking frameworks like Mockito are often used to isolate dependencies. \n\n**Integration Tests**: Test the interactions between different parts of your application or with external systems (e.g., databases, message queues, external APIs). Integration tests typically involve the Spring application context and may interact with real dependencies (or test containers for external services). They verify that components work together correctly.\n\n**Testing Slices**: Spring Boot provides testing slices to test specific layers or aspects of your application in a more focused integration test. Testing slices load only the necessary parts of the Spring context required for testing a particular slice. Examples of testing slices:\n    - `@WebMvcTest`: Tests Spring MVC controllers, loads only web-related components, not full application context. \n    - `@WebFluxTest`: For testing Spring WebFlux controllers in reactive applications. \n    - `@DataJpaTest`: Tests Spring Data JPA repositories, sets up an embedded database, loads JPA-related components. \n    - `@JdbcTest`: Tests JDBC-based components, sets up an embedded database, loads JDBC template. \n    - `@RestClientTest`: Tests REST client components using `RestTemplate` or `WebClient`, mocks external REST services. \n    - `@JsonTest`: Tests JSON serialization and deserialization logic using Jackson or Gson.\n\n**Key Testing Annotations**: \n    - `@SpringBootTest`: Loads the full Spring Boot application context. Used for end-to-end integration tests. \n    - `@WebMvcTest`: For testing Spring MVC controllers in isolation. \n    - `@WebFluxTest`: For testing Spring WebFlux controllers. \n    - `@DataJpaTest`: For testing Spring Data JPA repositories. \n    - `@JdbcTest`: For testing JDBC components. \n    - `@RestClientTest`: For testing REST clients. \n    - `@JsonTest`: For testing JSON processing. \n    - `@MockBean`: Spring Test annotation to mock a bean in the application context. \n    - `@Autowired`: To inject beans into tests. \n    - `TestRestTemplate` or `WebTestClient`: For testing REST endpoints in integration tests. \n    - `MockMvc` or `WebTestClient`: For testing controllers in a mocked MVC/WebFlux environment.",
      "example": "// Spring Boot Testing Basics Example - Unit Test and Integration Test (Conceptual)\n\n// Unit Test Example (using JUnit and Mockito)\n// @ExtendWith(MockitoExtension.class) // JUnit 5\n// public class MyServiceUnitTest {\n//     @InjectMocks\n//     private MyService myService;\n//     @Mock\n//     private Dependency dependencyMock;\n\n//     @Test\n//     void testMyServiceMethod() {\n//         when(dependencyMock.getData()).thenReturn(\"mocked data\");\n//         String result = myService.processData();\n//         assertEquals(\"expected result\", result);\n//         verify(dependencyMock).getData();\n//     }\n// }\n\n// Integration Test Example (@SpringBootTest)\n// @SpringBootTest\n// class MyIntegrationTest {\n//     @Autowired\n//     private TestRestTemplate restTemplate;\n\n//     @Test\n//     void testEndpoint() {\n//         ResponseEntity<String> response = restTemplate.getForEntity(\"/api/endpoint\", String.class);\n//         assertEquals(HttpStatus.OK, response.getStatusCode());\n//         assertEquals(\"expected response body\", response.getBody());\n//     }\n// }",
      "keyPoints": [
        "Spring Boot Testing: Comprehensive support for unit, integration, and slice tests.",
        "Unit Tests: Isolate and test individual components, use mocking (Mockito).",
        "Integration Tests: Test interactions between components and external systems, use `@SpringBootTest`.",
        "Testing Slices: Focused integration tests for specific layers (`@WebMvcTest`, `@DataJpaTest`, etc.).",
        "`@SpringBootTest`: Loads full application context for integration tests.",
        "`@WebMvcTest`: Tests Spring MVC controllers only.",
        "`@DataJpaTest`: Tests Spring Data JPA repositories with embedded database.",
        "`@MockBean`: Mock beans in Spring context for tests.",
        "`TestRestTemplate` or `WebTestClient`: Test REST endpoints in integration tests.",
        "`MockMvc` or `WebTestClient`: Test controllers in mocked MVC/WebFlux environment."
      ],
      "quiz": [
        {
          "question": "What type of test focuses on verifying individual components in isolation?",
          "options": ["Integration Test", "Unit Test", "Slice Test", "End-to-End Test"],
          "correctAnswer": 1
        },
        {
          "question": "Which annotation is used to load the full Spring Boot application context for integration tests?",
          "options": ["@WebMvcTest", "@DataJpaTest", "@SpringBootTest", "@TestComponent"],
          "correctAnswer": 2
        },
        {
          "question": "Which testing slice is used to test Spring Data JPA repositories?",
          "options": ["@WebMvcTest", "@JdbcTest", "@DataJpaTest", "@RestClientTest"],
          "correctAnswer": 2
        }
      ],
      "interactiveExamples": [
        {
          "title": "Writing a Simple Unit Test with Mockito",
          "code": "// Interactive Example: Writing a Simple Unit Test with Mockito\n\n// 1. Create a Service class (e.g., MyCalculatorService) with a method that performs a calculation.\n// 2. Create a Unit Test class (e.g., MyCalculatorServiceUnitTest) in src/test/java.\n// 3. Use JUnit 5 annotations (@ExtendWith(MockitoExtension.class), @InjectMocks, @Mock, @Test).\n// 4. Mock any dependencies of your Service class using @Mock.\n// 5. Inject the mocks into your Service class using @InjectMocks.\n// 6. Use Mockito's 'when' to define mock behavior.\n// 7. Call the method on your Service class and assert the result using JUnit's assertions (e.g., assertEquals).\n\n// Example: Unit test for a simple CalculatorService\n// @ExtendWith(MockitoExtension.class)\n// class CalculatorServiceUnitTest {\n//     @InjectMocks\n//     private CalculatorService calculatorService;\n\n//     @Test\n//     void testAdd() {\n//         int result = calculatorService.add(2, 3);\n//         assertEquals(5, result); // Assert the expected result\n//     }\n// }",
          "comment": "Note: Implement a simple CalculatorService and then write a unit test for its 'add' method."
        }
      ]
    },
    {
      "id": "spring-boot-testing-unittests",
      "title": "Unit Testing in Spring Boot",
      "description": "Writing effective unit tests for Spring components, using Mockito for mocking, and testing services and components in isolation.",
      "difficulty": "intermediate",
      "category": "spring-testing",
      "explanation": "Unit testing in Spring Boot involves testing individual components, such as services, utilities, or helper classes, in isolation. The goal of unit tests is to verify the logic of a single unit of code without relying on the Spring container or external dependencies. This makes unit tests fast, focused, and easy to maintain. Mocking frameworks like Mockito are essential for isolating the component under test from its collaborators.\n\n**Key Principles for Unit Testing in Spring Boot**: \n    - **Isolation**: Unit tests should test a single component in isolation. Dependencies should be replaced with mocks or stubs. \n    - **Speed**: Unit tests should be fast to execute. Avoid slow operations like database or network calls in unit tests. \n    - **Focus**: Each unit test should have a clear and focused purpose, testing a specific behavior or scenario of the component. \n    - **Mockito for Mocking**: Mockito is a popular Java mocking framework often used in Spring Boot unit tests. It allows you to create mock objects for dependencies, define their behavior, and verify interactions. \n    - **JUnit 5**: Spring Boot testing typically uses JUnit 5 as the testing framework. Annotations like `@Test`, `@BeforeEach`, `@AfterEach`, `@ExtendWith` (for Mockito extension) are used from JUnit 5. \n    - **`@InjectMocks` and `@Mock` (Mockito Annotations)**: `@Mock` is used to create mock instances of dependencies. `@InjectMocks` is used to inject these mocks into the class under test. \n    - **`when()` and `thenReturn()` (Mockito)**: Used to define the behavior of mock objects when their methods are called. \n    - **`verify()` (Mockito)**: Used to verify that certain methods on mock objects were called during the test execution.\n\n**Testing Services and Components**: When unit testing Spring components (e.g., `@Service`, `@Component` classes), you typically mock any dependencies that these components have (e.g., repositories, other services, external clients). This allows you to focus solely on the logic within the component being tested. You can then use Mockito to simulate the behavior of dependencies and assert that the component behaves as expected based on different inputs and dependency interactions.",
      "example": "// Spring Boot Unit Testing Example - Service Unit Test with Mockito\n\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.extension.ExtendWith;\nimport org.mockito.InjectMocks;\nimport org.mockito.Mock;\nimport org.mockito.junit.jupiter.MockitoExtension;\nimport static org.mockito.Mockito.when;\nimport static org.mockito.Mockito.verify;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\n@ExtendWith(MockitoExtension.class) // Enable Mockito extension for JUnit 5\npublic class UserServiceImplUnitTest {\n\n    @InjectMocks // Inject mocks into UserServiceImpl\n    private UserServiceImpl userService;\n\n    @Mock // Create a mock instance of UserRepository\n    private UserRepository userRepository;\n\n    @Test\n    void getUserById_ExistingUser_ReturnsUser() {\n        // Arrange\n        Long userId = 1L;\n        User expectedUser = new User(userId, \"Test User\");\n        when(userRepository.findById(userId)).thenReturn(java.util.Optional.of(expectedUser)); // Mock repository behavior\n\n        // Act\n        User actualUser = userService.getUserById(userId);\n\n        // Assert\n        assertEquals(expectedUser, actualUser);\n        verify(userRepository).findById(userId); // Verify repository method was called\n    }\n\n    // ... more unit test methods for other scenarios (e.g., user not found, exception handling) ...\n}",
      "keyPoints": [
        "Unit Testing: Testing individual components in isolation.",
        "Focus on testing logic within a single class/method.",
        "Use Mockito for mocking dependencies.",
        "JUnit 5 for test framework and annotations.",
        "`@Mock`: Create mock instances of dependencies.",
        "`@InjectMocks`: Inject mocks into the class under test.",
        "`when().thenReturn()`: Define mock behavior.",
        "`verify()`: Verify method invocations on mocks.",
        "Test services, components, utilities in isolation."
      ],
      "quiz": [
        {
          "question": "What is the primary goal of unit testing?",
          "options": ["To test the entire application.", "To test individual components in isolation.", "To test database interactions.", "To test web endpoints."],
          "correctAnswer": 1
        },
        {
          "question": "Which framework is commonly used for mocking dependencies in Java unit tests?",
          "options": ["JUnit", "Spring Test", "Mockito", "AssertJ"],
          "correctAnswer": 2
        },
        {
          "question": "Which Mockito annotation is used to create mock instances of dependencies?",
          "options": ["@InjectMocks", "@MockBean", "@Autowired", "@Mock"],
          "correctAnswer": 3
        }
      ],
      "interactiveExamples": [
        {
          "title": "Writing Unit Tests for a Service Method",
          "code": "// Interactive Example: Writing Unit Tests for a Service Method\n\n// 1. Create a simple Service class (e.g., ArticleService) with a method (e.g., getArticleSummary).\n// 2. Assume ArticleService depends on a Repository (e.g., ArticleRepository).\n// 3. Create a Unit Test class (e.g., ArticleServiceUnitTest).\n// 4. Use @ExtendWith(MockitoExtension.class) to enable Mockito.\n// 5. Use @InjectMocks to create an instance of ArticleService and inject mocks.\n// 6. Use @Mock to create a mock ArticleRepository.\n// 7. Write a test method (e.g., testGetArticleSummary_ValidArticleId_ReturnsSummary).\n// 8. Use Mockito's 'when' to mock ArticleRepository.findById() to return a sample Article.\n// 9. Call articleService.getArticleSummary() and assert the returned summary is as expected.\n// 10. Use Mockito's 'verify' to ensure ArticleRepository.findById() was called.\n\n// Example code structure (Service and UnitTest class skeletons) to guide interactive coding."
        }
      ]
    },
    {
      "id": "spring-boot-testing-integrationtests",
      "title": "Integration Testing in Spring Boot",
      "description": "Performing integration tests for Spring Boot applications, testing interactions between components and external systems.",
      "difficulty": "intermediate",
      "category": "spring-testing",
      "explanation": "Integration testing in Spring Boot focuses on testing the interactions between different parts of your application and with external systems like databases, message queues, or external APIs. Unlike unit tests that isolate components, integration tests verify that components work together correctly in a more realistic environment, often involving the Spring application context. Integration tests are crucial for ensuring that the application functions as a whole and that different parts are properly integrated.\n\n**Key Aspects of Integration Testing in Spring Boot**: \n    - **Full or Partial Spring Context**: Integration tests typically load either the full Spring Boot application context (`@SpringBootTest`) or specific slices (`@WebMvcTest`, `@DataJpaTest`, etc.). \n    - **Testing Component Interactions**: Verify that beans are correctly wired, dependencies are injected, and components collaborate as expected. \n    - **External System Interactions**: Test interactions with databases, message brokers, REST APIs, etc. This may involve using embedded databases (for database tests), test containers (for containerized dependencies), or mocking external APIs. \n    - **`@SpringBootTest` Annotation**:  The `@SpringBootTest` annotation is commonly used for full-context integration tests. It loads the entire Spring Boot application context, making all beans available for testing. \n    - **`TestRestTemplate` or `WebTestClient`**: Used to test REST endpoints in integration tests. `TestRestTemplate` is for traditional servlet-based applications, while `WebTestClient` is for reactive WebFlux applications. They provide convenient methods to send HTTP requests to your application's endpoints and assert responses. \n    - **Embedded Databases**: For database integration tests, Spring Boot can automatically configure embedded databases like H2, HSQLDB, or Derby. `@DataJpaTest` and `@JdbcTest` slices often use embedded databases. \n    - **Testcontainers**: Testcontainers is a library that allows you to run Docker containers as part of your integration tests. Useful for testing against real databases (e.g., PostgreSQL, MySQL), message queues (e.g., RabbitMQ, Kafka), or other containerized services. \n    - **Transaction Management**: Spring Test framework automatically manages transactions in integration tests. By default, each test method is run within a transaction that is rolled back after the test completes, ensuring test isolation.",
      "example": "// Spring Boot Integration Testing Example - REST Endpoint Integration Test\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport org.springframework.boot.test.web.client.TestRestTemplate;\nimport org.springframework.boot.test.web.server.LocalServerPort;\nimport org.springframework.http.HttpStatus;\nimport org.springframework.http.ResponseEntity;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\n@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT) // Start full app, random port\npublic class GreetingControllerIntegrationTest {\n\n    @LocalServerPort // Inject the randomly assigned port\n    private int port;\n\n    @Autowired\n    private TestRestTemplate restTemplate;\n\n    @Test\n    void greetingEndpoint_NoNameParam_ReturnsDefaultGreeting() {\n        // Act\n        ResponseEntity<String> response = restTemplate.getForEntity(\"http://localhost:\" + port + \"/greeting\", String.class);\n\n        // Assert\n        assertEquals(HttpStatus.OK, response.getStatusCode());\n        assertEquals(\"Hello, World!\", response.getBody());\n    }\n\n    @Test\n    void greetingEndpoint_WithNameParam_ReturnsCustomGreeting() {\n        // Act\n        ResponseEntity<String> response = restTemplate.getForEntity(\"http://localhost:\" + port + \"/greeting?name=TestUser\", String.class);\n\n        // Assert\n        assertEquals(HttpStatus.OK, response.getStatusCode());\n        assertEquals(\"Hello, TestUser!\", response.getBody());\n    }\n\n    // ... more integration test methods for different scenarios and endpoints ...\n}",
      "keyPoints": [
        "Integration Testing: Test interactions between components and external systems.",
        "Load full or partial Spring context (`@SpringBootTest`, testing slices).",
        "Verify component wiring, dependency injection, and collaboration.",
        "Test interactions with databases, message queues, REST APIs.",
        "`@SpringBootTest`: Load full application context for end-to-end tests.",
        "`TestRestTemplate` or `WebTestClient`: Test REST endpoints.",
        "Embedded databases for database integration tests.",
        "Testcontainers for testing against real containerized dependencies.",
        "Transaction management in tests (automatic rollback)."
      ],
      "quiz": [
        {
          "question": "What is the main focus of integration testing in Spring Boot?",
          "options": ["Testing individual classes in isolation.", "Testing interactions between components and external systems.", "Testing UI components.", "Testing compile-time errors."],
          "correctAnswer": 1
        },
        {
          "question": "Which annotation is commonly used for full-context integration tests in Spring Boot?",
          "options": ["@WebMvcTest", "@DataJpaTest", "@SpringBootTest", "@UnitTest"],
          "correctAnswer": 2
        },
        {
          "question": "Which class is used to test REST endpoints in Spring Boot integration tests?",
          "options": ["MockMvc", "RestTemplate", "TestRestTemplate", "WebClient"],
          "correctAnswer": 2
        }
      ],
      "interactiveExamples": [
        {
          "title": "Writing Integration Test for a REST Controller",
          "code": "// Interactive Example: Writing Integration Test for a REST Controller\n\n// 1. Create a REST Controller (e.g., ProductController) with an endpoint that returns product information.\n// 2. Create an Integration Test class (e.g., ProductControllerIntegrationTest).\n// 3. Annotate the test class with @SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT).\n// 4. Use @Autowired to inject TestRestTemplate.\n// 5. Use @LocalServerPort to inject the random port.\n// 6. Write a test method (e.g., testGetProductById_ValidId_ReturnsProduct).\n// 7. Use restTemplate.getForEntity() to send a GET request to your controller endpoint.\n// 8. Assert the HTTP status code and response body using JUnit assertions.\n\n// Example code structure (Controller and IntegrationTest class skeletons) to guide interactive coding."
        }
      ]
    },
    {
      "id": "spring-boot-security-advanced",
      "title": "Spring Boot Security Advanced Authentication and Authorization",
      "description": "Advanced Spring Boot Security topics: OAuth 2.0, JWT, Custom Authentication Providers, Role Hierarchies, and ACL.",
      "difficulty": "advanced",
      "category": "spring-security",
      "explanation": "Spring Boot Security provides extensive capabilities for advanced authentication and authorization scenarios beyond basic form login and HTTP Basic authentication. Advanced topics include OAuth 2.0 integration, JWT (JSON Web Tokens) based authentication, custom authentication providers, role hierarchies, and ACL (Access Control Lists).\n\n**OAuth 2.0**: OAuth 2.0 is an authorization framework that enables secure delegated access. Spring Security OAuth 2.0 module simplifies integration with OAuth 2.0 providers (e.g., Google, Facebook, Azure AD). \n    - **OAuth 2.0 Client**: Configure Spring Security OAuth 2.0 Client to allow your application to act as an OAuth 2.0 client, authenticating users via external OAuth 2.0 providers. \n    - **OAuth 2.0 Resource Server**: Configure Spring Security OAuth 2.0 Resource Server to protect your APIs using OAuth 2.0 access tokens. \n    - **OAuth 2.0 Authorization Server**: You can even build your own OAuth 2.0 Authorization Server using Spring Authorization Server project (part of Spring Security).\n\n**JWT (JSON Web Tokens)**: JWT is a standard for creating access tokens for authentication and authorization. JWTs are self-contained and can be used in stateless RESTful APIs. Spring Security JWT integration allows you to:\n    - Generate JWTs upon successful authentication. \n    - Validate JWTs for each request to authorize access to resources. \n    - Customize JWT claims, signing keys, and token expiration.\n\n**Custom Authentication Providers**: For authentication mechanisms not covered by default providers, you can create custom authentication providers. \n    - Implement `AuthenticationProvider` interface. \n    - Implement `supports()` method to indicate which authentication type the provider supports. \n    - Implement `authenticate()` method to perform custom authentication logic (e.g., LDAP, custom database authentication). \n    - Register your custom `AuthenticationProvider` with Spring Security configuration.\n\n**Role Hierarchies**: Define role hierarchies to establish inheritance between roles. For example, `ROLE_ADMIN` can implicitly inherit permissions of `ROLE_USER`. Spring Security supports role hierarchies, allowing you to define them in configuration and simplify authorization rules.\n\n**ACL (Access Control Lists)**: ACL provides fine-grained, instance-based authorization. Instead of role-based access control, ACL allows you to define permissions for individual objects or resources. Spring Security ACL module enables:\n    - Defining ACLs for domain objects. \n    - Managing permissions (read, write, delete, admin) for users or roles on specific objects. \n    - Using ACLs for method-level or web request authorization.",
      "example": "// Spring Boot Security Advanced Example - JWT Authentication (Conceptual)\n\n// 1. Add Spring Security and JWT dependencies.\n// 2. Configure a JWT filter to intercept requests and validate JWT tokens.\n// 3. Create a JWT utility class to generate and verify JWT tokens.\n// 4. Implement an AuthenticationEntryPoint to handle unauthorized requests.\n// 5. Configure Spring Security to use JWT filter and disable session management (for statelessness).\n\n// Conceptual code snippet for JWT Filter:\n// public class JwtRequestFilter extends OncePerRequestFilter {\n//     @Autowired\n//     private JwtUserDetailsService jwtUserDetailsService;\n//     @Autowired\n//     private JwtTokenUtil jwtTokenUtil;\n\n//     @Override\n//     protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain)\n//             throws ServletException, IOException {\n//         final String requestTokenHeader = request.getHeader(\"Authorization\");\n//         String username = null; String jwtToken = null;\n//         // ... extract JWT from header, validate token, get username, load user details, set authentication in SecurityContext ...\n//         chain.doFilter(request, response);\n//     }\n// }",
      "keyPoints": [
        "OAuth 2.0: Delegated authorization, OAuth 2.0 Client, Resource Server, Authorization Server.",
        "JWT (JSON Web Tokens): Stateless authentication, JWT generation, validation, custom claims.",
        "Custom Authentication Providers: Implement `AuthenticationProvider` for custom auth mechanisms.",
        "Role Hierarchies: Define role inheritance to simplify authorization rules.",
        "ACL (Access Control Lists): Fine-grained, instance-based authorization, object-level permissions.",
        "Spring Security OAuth 2.0 module for OAuth 2.0 integration.",
        "JWT-based authentication for stateless REST APIs."
      ],
      "quiz": [
        {
          "question": "What is OAuth 2.0 primarily used for?",
          "options": ["Authentication only.", "Authorization only.", "Both Authentication and Authorization.", "Data encryption."],
          "correctAnswer": 1
        },
        {
          "question": "What does JWT stand for in Spring Security context?",
          "options": ["Java Web Token", "JSON Web Token", "JavaScript Web Token", "Java Wire Transfer"],
          "correctAnswer": 1
        },
        {
          "question": "Which interface do you implement to create a custom authentication provider in Spring Security?",
          "options": ["UserDetailsService", "AuthenticationManager", "AuthenticationProvider", "UserDetailsService"],
          "correctAnswer": 2
        }
      ],
      "interactiveExamples": [
        {
          "title": "Role Hierarchy Configuration",
          "code": "// Interactive Example: Role Hierarchy Configuration\n\n// 1. Configure Role Hierarchy in Spring Security configuration (e.g., WebSecurityConfigurerAdapter or SecurityFilterChain bean).\n// 2. Define a role hierarchy string, e.g., \"ROLE_ADMIN > ROLE_MANAGER > ROLE_USER\".\n// 3. Assign ROLE_MANAGER to a user.\n// 4. Define security rules that require ROLE_ADMIN for certain endpoints or methods.\n// 5. Test authorization: user with ROLE_MANAGER should NOT be able to access resources requiring ROLE_ADMIN, but SHOULD be able to access resources requiring ROLE_USER (due to hierarchy).\n\n// Example Role Hierarchy configuration snippet:\n// @Configuration\n// public class SecurityConfig extends WebSecurityConfigurerAdapter {\n//     @Override\n//     protected void configure(HttpSecurity http) throws Exception {\n//         http\n//             // ... other configurations ...\n//             .authorizeRequests()\n//                 .antMatchers(\"/admin/**\").hasRole(\"ADMIN\")\n//                 .antMatchers(\"/user/**\").hasRole(\"USER\")\n//                 .anyRequest().permitAll();\n//     }\n\n//     @Bean\n//     public RoleHierarchy roleHierarchy() {\n//         RoleHierarchyImpl roleHierarchy = new RoleHierarchyImpl();\n//         roleHierarchy.setHierarchy(\"ROLE_ADMIN > ROLE_MANAGER > ROLE_USER\");\n//         return roleHierarchy;\n//     }\n// }"
        },
        {
          "title": "OAuth2 Client Configuration",
          "code": "// Interactive Example: OAuth2 Client Configuration (Conceptual Steps)\n\n// 1. Add spring-boot-starter-oauth2-client dependency.\n// 2. Configure OAuth2 Client properties in application.yml:\n//    spring:\n//      security:\n//        oauth2:\n//          client:\n//            registration:\n//              google:\n//                client-id: YOUR_GOOGLE_CLIENT_ID\n//                client-secret: YOUR_GOOGLE_CLIENT_SECRET\n//                redirect-uri: '{baseUrl}/login/oauth2/code/{registrationId}'\n//                scope: openid,profile,email\n//            provider:\n//              google:\n//                issuer-uri: https://accounts.google.com\n// 3. Create a Controller to handle login and access user info.\n// 4. Use @RegisteredOAuth2AuthorizedClient to inject OAuth2AuthorizedClient.\n// 5. Build UI with login button that redirects to OAuth2 provider's authorization endpoint.\n\n// Conceptual code snippet for Controller:\n// @Controller\n// public class OAuth2LoginController {\n//     @GetMapping(\"/oauth2/login-success\")\n//     public String loginSuccess(@RegisteredOAuth2AuthorizedClient(\"google\") OAuth2AuthorizedClient authorizedClient, Model model) {\n//         OAuth2User oAuth2User = authorizedClient.getPrincipal();\n//         model.addAttribute(\"userName\", oAuth2User.getName());\n//         model.addAttribute(\"userAttributes\", oAuth2User.getAttributes());\n//         return \"oauth2-success\"; // View name\n//     }\n// }"
        }
      ]
    },
    {
      "id": "rest-api-versioning",
      "title": "REST API Versioning",
      "description": "Implementing API versioning strategies for RESTful APIs: URI versioning, header versioning, and parameter versioning.",
      "difficulty": "intermediate",
      "category": "rest-api",
      "explanation": "API Versioning is a crucial aspect of REST API design, especially for public APIs that evolve over time. Versioning allows you to introduce changes to your API without breaking existing clients. It enables backward compatibility and provides a smooth transition for clients to adopt new API versions. Common API versioning strategies include URI versioning, header versioning, and parameter versioning.\n\n**URI Versioning**: Version information is included directly in the URI path. This is a widely adopted and explicit approach. \n    - Example: `/v1/resources`, `/v2/resources`. \n    - Pros: Clear, explicit, easily discoverable via URI. \n    - Cons: Can lead to URI proliferation, might be considered less RESTful by some.\n\n**Header Versioning (Content Negotiation)**: Version information is provided in HTTP headers, typically using `Accept` or custom headers. \n    - Example: `Accept: application/vnd.company.app-v1+json`, `X-API-Version: 1`. \n    - Pros: Cleaner URIs, aligns with content negotiation principles. \n    - Cons: Less discoverable, clients need to be aware of headers, browser testing might be less straightforward.\n\n**Parameter Versioning**: Version information is passed as a query parameter. \n    - Example: `/resources?api-version=1`. \n    - Pros: Simple to implement. \n    - Cons: URI pollution with version parameter, less RESTful, might conflict with other query parameters.\n\n**Choosing a Versioning Strategy**: The choice of versioning strategy depends on factors like API maturity, client base, frequency of changes, and organizational standards. URI versioning is often preferred for public APIs due to its explicitness and discoverability. Header versioning can be a good option for more mature APIs where clean URIs are prioritized and clients are sophisticated enough to handle headers. Parameter versioning is generally less recommended for public APIs due to URI pollution.\n\n**Implementation in Spring Boot**: Spring MVC provides flexibility to implement any of these versioning strategies. You can use `@RequestMapping`, `@GetMapping`, etc., with URI patterns, request header conditions (`headers` attribute), or request parameter conditions (`params` attribute) to map requests to different controller methods based on the version information.",
      "example": "// REST API Versioning Example - URI Versioning in Spring MVC\n\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\n@RequestMapping(\"/api\") // Base path for API\npublic class VersionedApiController {\n\n    @GetMapping(\"/v1/products/{id}\") // Version 1 endpoint\n    public String getProductV1(@PathVariable Long id) {\n        return \"Product V1: \" + id;\n    }\n\n    @GetMapping(\"/v2/products/{id}\") // Version 2 endpoint\n    public String getProductV2(@PathVariable Long id) {\n        return \"Product V2: \" + id + \" - with updated details\";\n    }\n}",
      "keyPoints": [
        "API Versioning: Manage API evolution without breaking clients.",
        "URI Versioning: Version in URI path (e.g., `/v1/resources`).",
        "Header Versioning: Version in HTTP headers (e.g., `Accept`, custom headers).",
        "Parameter Versioning: Version as query parameter (e.g., `/resources?api-version=1`).",
        "URI versioning: Explicit, discoverable, common for public APIs.",
        "Header versioning: Cleaner URIs, content negotiation, for mature APIs.",
        "Parameter versioning: Simple, but less RESTful, URI pollution.",
        "Spring MVC: Flexible to implement any versioning strategy using `@RequestMapping`, etc."
      ],
      "quiz": [
        {
          "question": "Which API versioning strategy involves including the version information in the URL path?",
          "options": ["Header Versioning", "Parameter Versioning", "URI Versioning", "Content Negotiation"],
          "correctAnswer": 2
        },
        {
          "question": "Which versioning strategy uses HTTP headers to specify the API version?",
          "options": ["URI Versioning", "Parameter Versioning", "Header Versioning", "Path Versioning"],
          "correctAnswer": 2
        },
        {
          "question": "Which versioning strategy is generally considered most explicit and discoverable for public APIs?",
          "options": ["Parameter Versioning", "Header Versioning", "URI Versioning", "Content-Based Versioning"],
          "correctAnswer": 2
        }
      ],
      "interactiveExamples": [
        {
          "title": "Header Versioning Example in Spring MVC",
          "code": "// Interactive Example: Header Versioning in Spring MVC\n\n// 1. Create a Spring Boot REST Controller (e.g., HeaderVersionController).\n// 2. Define two methods to handle different API versions.\n// 3. Use `@GetMapping` with `headers` attribute to map methods to specific versions based on custom header (e.g., \"X-API-Version=1\", \"X-API-Version=2\").\n// 4. Return different responses for each version.\n// 5. Test using curl or Postman, setting the 'X-API-Version' header to '1' and '2' to access different versions of the endpoint.\n\n// Example code snippet for HeaderVersionController:\n// @RestController\n// @RequestMapping(\"/api/header\")\n// public class HeaderVersionController {\n//     @GetMapping(value = \"/products\", headers = \"X-API-Version=1\")\n//     public String getProductsV1() {\n//         return \"Products V1\";\n//     }\n\n//     @GetMapping(value = \"/products\", headers = \"X-API-Version=2\")\n//     public String getProductsV2() {\n//         return \"Products V2 - updated\";\n//     }\n// }"
        }
      ]
    },
    {
      "id": "rest-api-error-handling",
      "title": "REST API Error Handling Best Practices",
      "description": "Best practices for REST API error handling: HTTP status codes, error responses, exception handling, and global exception handling.",
      "difficulty": "intermediate",
      "category": "rest-api",
      "explanation": "Effective error handling is crucial for robust and user-friendly REST APIs. Well-designed error handling provides meaningful feedback to clients when things go wrong, enabling them to understand and potentially recover from errors. Best practices for REST API error handling include using appropriate HTTP status codes, providing structured and informative error responses, implementing proper exception handling, and using global exception handling mechanisms.\n\n**HTTP Status Codes**: Use HTTP status codes semantically to indicate the outcome of API requests. \n    - **2xx Success**: 200 OK, 201 Created, 204 No Content. \n    - **4xx Client Errors**: 400 Bad Request, 401 Unauthorized, 403 Forbidden, 404 Not Found, 409 Conflict, 422 Unprocessable Entity. \n    - **5xx Server Errors**: 500 Internal Server Error, 503 Service Unavailable. \n    - Use specific 4xx and 5xx status codes to accurately reflect the error type.\n\n**Structured Error Responses**: Return error responses in a consistent and structured format (e.g., JSON or XML). Error responses should include: \n    - **Error Code**: A unique identifier for the error type (e.g., \"VALIDATION_ERROR\", \"RESOURCE_NOT_FOUND\"). \n    - **Message**: A human-readable error message describing the error. \n    - **Details (Optional)**: Additional details about the error, such as validation errors (field names, error messages), stack traces (in non-production environments), or links to documentation. \n    - **HTTP Status Code**: Include the relevant HTTP status code in the response.\n\n**Exception Handling**: Implement exception handling in your application code to catch exceptions and translate them into appropriate error responses. \n    - **Specific Exception Handling**: Handle specific exceptions in controller methods or service layers using `try-catch` blocks and return `ResponseEntity` with appropriate status codes and error responses. \n    - **Global Exception Handling**: Use `@ControllerAdvice` and `@ExceptionHandler` annotations to create global exception handlers that handle exceptions across all controllers. Global exception handling provides a centralized place to manage error responses and ensures consistency.\n\n**Logging**: Log errors server-side for debugging and monitoring purposes. Include error codes, messages, request details, and stack traces in logs (sensitive information should be logged carefully, especially in production).",
      "example": "// REST API Error Handling Example - Global Exception Handler in Spring MVC\n\nimport org.springframework.http.HttpStatus;\nimport org.springframework.http.ResponseEntity;\nimport org.springframework.web.bind.annotation.ControllerAdvice;\nimport org.springframework.web.bind.annotation.ExceptionHandler;\nimport org.springframework.web.bind.annotation.ResponseStatus;\n\n@ControllerAdvice // Global exception handler\npublic class GlobalExceptionHandler {\n\n    @ExceptionHandler(ResourceNotFoundException.class) // Handle ResourceNotFoundException\n    @ResponseStatus(HttpStatus.NOT_FOUND) // Set HTTP status code\n    public ResponseEntity<ErrorResponse> handleResourceNotFoundException(ResourceNotFoundException ex) {\n        ErrorResponse errorResponse = new ErrorResponse(\"RESOURCE_NOT_FOUND\", ex.getMessage());\n        return new ResponseEntity<>(errorResponse, HttpStatus.NOT_FOUND);\n    }\n\n    @ExceptionHandler(BadRequestException.class) // Handle BadRequestException\n    @ResponseStatus(HttpStatus.BAD_REQUEST) // Set HTTP status code\n    public ResponseEntity<ErrorResponse> handleBadRequestException(BadRequestException ex) {\n        ErrorResponse errorResponse = new ErrorResponse(\"BAD_REQUEST\", ex.getMessage());\n        return new ResponseEntity<>(errorResponse, HttpStatus.BAD_REQUEST);\n    }\n\n    @ExceptionHandler(Exception.class) // Generic exception handler for unhandled exceptions\n    @ResponseStatus(HttpStatus.INTERNAL_SERVER_ERROR) // Set HTTP status code\n    public ResponseEntity<ErrorResponse> handleGenericException(Exception ex) {\n        // Log the exception here\n        ErrorResponse errorResponse = new ErrorResponse(\"INTERNAL_SERVER_ERROR\", \"An unexpected error occurred.\");\n        return new ResponseEntity<>(errorResponse, HttpStatus.INTERNAL_SERVER_ERROR);\n    }\n}",
      "keyPoints": [
        "REST API Error Handling: Crucial for robust and user-friendly APIs.",
        "HTTP Status Codes: Use semantically (2xx, 4xx, 5xx).",
        "Structured Error Responses: Consistent format (JSON/XML), error code, message, details.",
        "Exception Handling: Catch exceptions and translate to error responses.",
        "Specific Exception Handling: `try-catch` in controllers/services.",
        "Global Exception Handling: `@ControllerAdvice`, `@ExceptionHandler` for centralized handling.",
        "Logging: Log errors server-side for debugging and monitoring.",
        "Return `ResponseEntity` for error responses in Spring MVC."
      ],
      "quiz": [
        {
          "question": "Which HTTP status code typically indicates a client-side error due to a bad request?",
          "options": ["200 OK", "404 Not Found", "500 Internal Server Error", "400 Bad Request"],
          "correctAnswer": 3
        },
        {
          "question": "What is the purpose of a global exception handler in Spring MVC?",
          "options": ["To handle only specific exceptions in controllers.", "To handle exceptions in service layers.", "To provide a centralized way to handle exceptions across all controllers.", "To improve API performance."],
          "correctAnswer": 2
        },
        {
          "question": "What should a structured error response typically include?",
          "options": ["Only the HTTP status code.", "Only a stack trace.", "Error code, message, and HTTP status code.", "Only a generic error message."],
          "correctAnswer": 2
        }
      ],
      "interactiveExamples": [
        {
          "title": "Implementing Global Exception Handling",
          "code": "// Interactive Example: Implementing Global Exception Handling in Spring Boot\n\n// 1. Create a custom exception class (e.g., ResourceNotFoundException).\n// 2. Create a global exception handler class annotated with `@ControllerAdvice`.\n// 3. In the exception handler, define a method annotated with `@ExceptionHandler(ResourceNotFoundException.class)`.\n// 4. In the exception handler method, create an ErrorResponse object (define ErrorResponse class with errorCode and message fields).\n// 5. Return a `ResponseEntity<ErrorResponse>` with appropriate HTTP status code (e.g., HttpStatus.NOT_FOUND).\n// 6. In your Controller, throw a ResourceNotFoundException when a resource is not found.\n// 7. Test the endpoint - when resource is not found, you should get the error response defined in your global exception handler.\n\n// Example ErrorResponse class:\n// public class ErrorResponse {\n//     private String errorCode;\n//     private String message;\n//     // ... constructor, getters, setters ...\n// }"
        }
      ]
    },
    {
      "id": "rest-api-hateoas",
      "title": "HATEOAS (Hypermedia as the Engine of Application State)",
      "description": "Understanding and implementing HATEOAS in REST APIs to improve API discoverability and evolvability.",
      "difficulty": "advanced",
      "category": "rest-api",
      "explanation": "HATEOAS (Hypermedia as the Engine of Application State) is a key constraint of the REST architectural style. It means that a client interacts with a network application entirely through hypermedia provided dynamically by the application servers. HATEOAS enables API discoverability, reduces client coupling, and enhances API evolvability. In a HATEOAS-compliant API, responses include not only data but also links to related resources and actions that the client can take next.\n\n**Benefits of HATEOAS**: \n    - **API Discoverability**: Clients can dynamically discover available resources and actions by following links in API responses. No need for hardcoded URLs in clients. \n    - **Reduced Client Coupling**: Clients are less coupled to specific URI structures. API evolution becomes easier as server-side URI changes are less likely to break clients if links are used. \n    - **API Evolvability**: APIs can evolve and change over time without breaking clients. Servers can guide clients through state transitions by providing relevant links in responses. \n    - **Self-descriptive APIs**: APIs become more self-descriptive. Clients can understand the API's capabilities and how to interact with it by examining hypermedia responses. \n    - **Improved Client Experience**: Clients can navigate the API more intuitively, leading to a better overall experience.\n\n**Implementing HATEOAS in Spring Boot**: Spring HATEOAS module simplifies HATEOAS implementation in Spring MVC REST APIs. Key components:\n    - **`RepresentationModel`**: Base class for resource representations that include links. \n    - **`EntityModel<T>`**: Wraps an entity and extends `RepresentationModel` to add links to it. \n    - **`CollectionModel<T>`**: Wraps a collection of entities and extends `RepresentationModel` for collections with links. \n    - **`Link`**: Represents a hypermedia link (rel, href). \n    - **`Links`**: Container for multiple `Link` objects. \n    - **`WebMvcLinkBuilder`**: Utility class to build links to Spring MVC controller methods in a type-safe way. \n    - **`ControllerLinkBuilder` (deprecated, use `WebMvcLinkBuilder`)**: Older utility for link building.\n\n**Example HATEOAS Response**: A typical HATEOAS response might include:\n```json\n{\n  \"id\": 123,\n  \"name\": \"Product Name\",\n  \"price\": 99.99,\n  \"_links\": {\n    \"self\": {\n      \"href\": \"http://localhost:8080/products/123\"\n    },\n    \"orders\": {\n      \"href\": \"http://localhost:8080/products/123/orders\"\n    }\n  }\n}\n```\nIn this example, `_links` section provides links to the resource itself (`self`) and related resources (`orders`).",
      "example": "// REST API HATEOAS Example - using Spring HATEOAS\n\nimport org.springframework.hateoas.EntityModel;\nimport org.springframework.hateoas.server.mvc.WebMvcLinkBuilder;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.PathVariable;\nimport org.springframework.web.bind.annotation.RestController;\nimport static org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.linkTo;\nimport static org.springframework.hateoas.server.mvc.WebMvcLinkBuilder.methodOn;\n\n@RestController\npublic class HATEOASController {\n\n    @GetMapping(\"/products/{id}\")\n    public EntityModel<Product> getProduct(@PathVariable Long id) {\n        Product product = new Product(id, \"Sample Product\", 29.99);\n\n        EntityModel<Product> productResource = EntityModel.of(product);\n\n        // Add self link\n        productResource.add(linkTo(methodOn(HATEOASController.class).getProduct(id)).withSelfRel());\n        // Add link to orders for this product\n        productResource.add(linkTo(methodOn(HATEOASController.class).getProductOrders(id)).withRel(\"orders\"));\n\n        return productResource;\n    }\n\n    @GetMapping(\"/products/{id}/orders\")\n    public String getProductOrders(@PathVariable Long id) {\n        return \"Orders for product: \" + id; // Replace with actual logic\n    }\n}",
      "keyPoints": [
        "HATEOAS: Hypermedia as the Engine of Application State, REST constraint.",
        "API Discoverability: Clients discover resources and actions via links.",
        "Reduced Client Coupling: Clients less dependent on fixed URIs.",
        "API Evolvability: APIs can evolve without breaking clients.",
        "Self-descriptive APIs: API capabilities are discoverable from responses.",
        "Spring HATEOAS module: Simplify HATEOAS implementation in Spring MVC.",
        "Key classes: `RepresentationModel`, `EntityModel`, `CollectionModel`, `Link`, `WebMvcLinkBuilder`."
      ],
      "quiz": [
        {
          "question": "What does HATEOAS stand for?",
          "options": ["Hypertext Application Transfer Engine Over Secure Sockets", "Hypermedia As The Engine Of Application State", "      ", "       "],
          "correctAnswer": 1
        },
        {
          "question": "What is a primary benefit of implementing HATEOAS in REST APIs?",
          "options": ["Improved API performance.", "Enhanced API security.", "Increased client-side complexity.", "Improved API discoverability and evolvability."],
          "correctAnswer": 3
        },
        {
          "question": "Which Spring module simplifies HATEOAS implementation in Spring MVC?",
          "options": ["Spring REST", "Spring WebFlux", "Spring HATEOAS", "Spring MVC REST"],
          "correctAnswer": 2
        }
      ],
      "interactiveExamples": [
        {
          "title": "Adding HATEOAS Links to a REST Resource",
          "code": "// Interactive Example: Adding HATEOAS Links to a REST Resource\n\n// 1. Add spring-boot-starter-hateoas dependency to your project.\n// 2. Create a Spring Boot REST Controller (e.g., ProductHATEOASController).\n// 3. Create a Product class (or use existing entity).\n// 4. In your controller method (e.g., getProductHATEOAS), fetch a Product.\n// 5. Wrap the Product object in an `EntityModel<Product>`. \n// 6. Use `WebMvcLinkBuilder.linkTo(methodOn(...).method(...)).withSelfRel()` to create a self link to the current endpoint.\n// 7. Add other relevant links (e.g., links to related resources or actions) using `withRel(\"relationName\")`.\n// 8. Return the `EntityModel<Product>`. \n// 9. Test the endpoint - response should include '_links' section with HATEOAS links in JSON.\n\n// Example code snippet for ProductHATEOASController (partial):\n// @RestController\n// public class ProductHATEOASController {\n//     @GetMapping(\"/hateoas/products/{id}\")\n//     public EntityModel<Product> getProductHATEOAS(@PathVariable Long id) {\n//         Product product = // ... fetch product ...\n//         EntityModel<Product> productResource = EntityModel.of(product);\n//         productResource.add(linkTo(methodOn(ProductHATEOASController.class).getProductHATEOAS(id)).withSelfRel());\n//         productResource.add( // ... add other links ...);\n//         return productResource;\n//     }\n// }"
        }
      ]
    },
    {
      "id": "microservices-service-discovery",
      "title": "Microservices Service Discovery",
      "description": "Implementing Service Discovery in microservices architectures using Netflix Eureka or Consul.",
      "difficulty": "advanced",
      "category": "microservices",
      "explanation": "Service Discovery is a key component in microservices architectures. In a microservices environment, services are dynamically located and scaled. Service discovery enables services to automatically discover and communicate with each other without hardcoding network locations. It solves the problem of service instances dynamically changing their IP addresses and ports.\n\n**Need for Service Discovery**: In traditional monolithic applications, components typically interact within the same process. In microservices, services are deployed independently and might be scaled in and out dynamically. Service discovery is essential for:\n    - **Dynamic Service Locations**: Services can be located at different IP addresses and ports, which can change. Service discovery provides a registry to track these locations dynamically. \n    - **Load Balancing**: Service discovery can integrate with load balancers to distribute requests across healthy service instances. \n    - **Fault Tolerance**: If a service instance fails, service discovery can help route traffic to healthy instances. \n    - **Scalability**: As services are scaled, service discovery automatically updates the registry with new instances.\n\n**Common Service Discovery Patterns**: \n    - **Client-side Discovery**: The client queries a service registry (e.g., Eureka, Consul, ZooKeeper) to get the locations of service instances and then load balances requests across them. Netflix Eureka Client, Consul Client are examples. \n    - **Server-side Discovery**: Clients send requests to a load balancer, which then queries the service registry to route requests to available service instances. Kubernetes Service, AWS ELB are examples.\n\n**Netflix Eureka**: Eureka is a service registry developed by Netflix and widely used in Spring Cloud microservices. \n    - **Eureka Server**: A standalone application that acts as the service registry. Services register themselves with Eureka Server, and clients query Eureka Server to discover service instances. \n    - **Eureka Client**: Services and clients act as Eureka Clients. Services register their metadata (host, port, health check URL) with Eureka Server. Clients use Eureka Client to query Eureka Server for service instance locations. \n    - **Spring Cloud Netflix Eureka**: Spring Cloud provides abstractions and auto-configuration to easily integrate Eureka into Spring Boot microservices.\n\n**Consul**: Consul is another popular service mesh solution that includes service discovery, configuration management, and service segmentation. \n    - **Consul Server**: Consul server cluster acts as the service registry and configuration store. \n    - **Consul Client**: Each service instance runs a Consul agent, which registers the service with Consul Server and performs health checks. \n    - **Spring Cloud Consul**: Spring Cloud provides integration with Consul for service discovery and configuration management.",
      "example": "// Microservices Service Discovery Example - Netflix Eureka (Conceptual)\n\n// 1. Eureka Server Application (Spring Boot):\n//    - Add spring-cloud-starter-netflix-eureka-server dependency.\n//    - Annotate main class with @EnableEurekaServer.\n//    - Configure application port (e.g., 8761).\n\n// 2. Eureka Client Service (Spring Boot Microservice):\n//    - Add spring-cloud-starter-netflix-eureka-client dependency.\n//    - Annotate main class with @EnableDiscoveryClient or @EnableEurekaClient.\n//    - Configure application name (spring.application.name) - used for service registration in Eureka.\n//    - Eureka client will automatically register with Eureka Server on startup.\n\n// 3. Client Application (Another Microservice or Client):\n//    - Add spring-cloud-starter-netflix-eureka-client dependency.\n//    - Use DiscoveryClient to query Eureka Server for service instances by service name.\n//    - Use LoadBalancerClient (e.g., Ribbon with Eureka) to load balance requests across service instances.\n\n// Conceptual code snippet for Client using DiscoveryClient:\n// @Autowired\n// private DiscoveryClient discoveryClient;\n// public List<ServiceInstance> getServiceInstances(String serviceName) {\n//     return discoveryClient.getInstances(serviceName);\n// }",
      "keyPoints": [
        "Service Discovery: Enables services to dynamically discover and communicate with each other.",
        "Solves dynamic service location problem in microservices.",
        "Client-side Discovery: Client queries registry, load balances requests.",
        "Server-side Discovery: Load balancer queries registry, routes requests.",
        "Netflix Eureka: Popular service registry, Eureka Server and Eureka Client components.",
        "Consul: Service mesh with service discovery, Consul Server and Consul Agent.",
        "Spring Cloud Netflix Eureka and Spring Cloud Consul: Simplify integration in Spring Boot."
      ],
      "quiz": [
        {
          "question": "What is the primary purpose of service discovery in microservices architecture?",
          "options": ["Load balancing.", "API Gateway routing.", "Enabling services to find and communicate with each other dynamically.", "Security and authentication."],
          "correctAnswer": 2
        },
        {
          "question": "Netflix Eureka is an example of which service discovery pattern?",
          "options": ["Server-side discovery.", "Client-side discovery.", "Both client-side and server-side.", "Neither client-side nor server-side."],
          "correctAnswer": 1
        },
        {
          "question": "Which Spring Cloud starter dependency is used to integrate Netflix Eureka client into a Spring Boot microservice?",
          "options": ["spring-cloud-starter-netflix-eureka-server", "spring-cloud-starter-netflix-eureka-client", "spring-cloud-starter-discovery", "spring-cloud-starter-consul-discovery"],
          "correctAnswer": 1
        }
      ],
      "interactiveExamples": [
        {
          "title": "Setting up Eureka Server and Client (Conceptual Steps)",
          "code": "// Interactive Example: Setting up Eureka Server and Client (Conceptual Steps)\n\n// 1. Create a Spring Boot project for Eureka Server (e.g., 'eureka-server').\n// 2. Add spring-cloud-starter-netflix-eureka-server dependency.\n// 3. Annotate main class with @EnableEurekaServer.\n// 4. Configure application port (e.g., 8761) in application.properties.\n// 5. Run the Eureka Server application.\n// 6. Create a Spring Boot microservice project (e.g., 'service-client').\n// 7. Add spring-cloud-starter-netflix-eureka-client dependency.\n// 8. Annotate main class with @EnableDiscoveryClient or @EnableEurekaClient.\n// 9. Configure application name (spring.application.name) in application.properties.\n// 10. Configure Eureka Server URL (eureka.client.serviceUrl.defaultZone) in application.properties.\n// 11. Run the microservice client application.\n// 12. Access Eureka Server dashboard (http://localhost:8761) to see the registered service client.\n\n// Note: This is a conceptual setup. Actual code implementation involves creating Spring Boot projects, adding dependencies, and writing configuration files."
        }
      ]
    },
    {
      "id": "microservices-api-gateway",
      "title": "Microservices API Gateway",
      "description": "Using API Gateway pattern in microservices: routing, security, and cross-cutting concerns with Spring Cloud Gateway or Netflix Zuul.",
      "difficulty": "advanced",
      "category": "microservices",
      "explanation": "API Gateway is a critical component in microservices architectures. It acts as a single entry point for all client requests, routing them to the appropriate backend microservices. API Gateway decouples clients from the internal microservice architecture and provides a centralized point for handling cross-cutting concerns such as security, rate limiting, monitoring, and routing.\n\n**Benefits of API Gateway**: \n    - **Single Entry Point**: Clients interact with a single endpoint (API Gateway) instead of multiple backend services, simplifying client communication. \n    - **Routing**: API Gateway intelligently routes requests to the appropriate backend microservices based on URL paths, headers, or other criteria. \n    - **Security**: Centralized security enforcement. API Gateway can handle authentication, authorization, and SSL termination for all incoming requests, securing backend services. \n    - **Load Balancing**: API Gateway can perform load balancing across backend service instances. \n    - **Rate Limiting**: Implement rate limiting and throttling to protect backend services from overload. \n    - **Request Transformation**: API Gateway can transform requests and responses as needed for different clients or backend services. \n    - **Monitoring and Logging**: Centralized monitoring and logging of all API traffic. \n    - **Service Aggregation**: API Gateway can aggregate responses from multiple backend services into a single response for clients.\n\n**Spring Cloud Gateway**: Spring Cloud Gateway is a modern, reactive API Gateway built on Spring WebFlux. It provides:\n    - **Reactive and Non-blocking**: Leverages Spring WebFlux for high performance and scalability. \n    - **Route Predicates**: Flexible route predicates based on path, headers, query parameters, etc., to match incoming requests. \n    - **Gateway Filters**: Powerful gateway filters to modify requests and responses, implement security, rate limiting, etc. Filters can be applied globally or to specific routes. \n    - **Integration with Service Discovery**: Integrates with service discovery (e.g., Eureka, Consul) for dynamic routing to backend services. \n    - **Load Balancing**: Built-in load balancer integration.\n\n**Netflix Zuul (Zuul 1 and Zuul 2)**: Netflix Zuul is another popular API Gateway, although Zuul 1 is in maintenance mode. Zuul 2 is a reactive, non-blocking evolution. \n    - **Zuul Filters**: Zuul uses filters for request interception and modification. Filters are categorized into pre-routing, routing, post-routing, and error filters. \n    - **Integration with Eureka**: Zuul integrates well with Netflix Eureka for service discovery and dynamic routing.",
      "example": "// Microservices API Gateway Example - Spring Cloud Gateway (Conceptual)\n\n// 1. API Gateway Application (Spring Boot):\n//    - Add spring-cloud-starter-gateway dependency.\n//    - Configure routes in application.yml or Java configuration:\n//      spring:\n//        cloud:\n//          gateway:\n//            routes:\n//              - id: product-service-route\n//                uri: lb://product-service # lb:// for load-balanced routing via service discovery\n//                predicates:\n//                  - Path=/products/**\n//              - id: order-service-route\n//                uri: lb://order-service\n//                predicates:\n//                  - Path=/orders/**\n\n// 2. Run API Gateway application.\n// 3. Client sends requests to API Gateway (e.g., http://localhost:8080/products/123). \n// 4. Spring Cloud Gateway routes requests to 'product-service' instances based on service discovery and load balancing (if 'lb://' URI is used).\n// 5. Gateway can also apply filters for security, logging, etc., before routing requests to backend services.",
      "keyPoints": [
        "API Gateway: Single entry point for microservices, decouples clients from backend services.",
        "Benefits: Routing, Security, Load Balancing, Rate Limiting, Monitoring, etc.",
        "Spring Cloud Gateway: Reactive, non-blocking API Gateway, Route Predicates and Gateway Filters.",
        "Netflix Zuul: Popular API Gateway (Zuul 1 maintenance, Zuul 2 reactive), Zuul Filters.",
        "Route Predicates: Match requests based on path, headers, params in Spring Cloud Gateway.",
        "Gateway Filters: Modify requests/responses, implement cross-cutting concerns in Spring Cloud Gateway.",
        "Integration with Service Discovery: Dynamic routing to backend services."
      ],
      "quiz": [
        {
          "question": "What is the primary role of an API Gateway in microservices architecture?",
          "options": ["Database management.", "Service discovery.", "Acting as a single entry point for client requests and routing them to backend services.", "Message queue management."],
          "correctAnswer": 2
        },
        {
          "question": "Spring Cloud Gateway is built on which reactive framework?",
          "options": ["Spring MVC", "Spring WebFlux", "Servlet API", "JAX-RS"],
          "correctAnswer": 1
        },
        {
          "question": "What are Gateway Filters used for in Spring Cloud Gateway?",
          "options": ["Defining routing rules.", "Implementing circuit breaker pattern.", "Modifying requests and responses, implementing security, rate limiting, etc.", "Service registration."],
          "correctAnswer": 2
        }
      ],
      "interactiveExamples": [
        {
          "title": "Configuring Basic Routing in Spring Cloud Gateway",
          "code": "// Interactive Example: Configuring Basic Routing in Spring Cloud Gateway\n\n// 1. Create a Spring Boot project for API Gateway (e.g., 'api-gateway').\n// 2. Add spring-cloud-starter-gateway dependency.\n// 3. Configure routes in application.yml:\n//    spring:\n//      cloud:\n//        gateway:\n//          routes:\n//            - id: httpbin-route\n//              uri: https://httpbin.org # Example external HTTP service\n//              predicates:\n//                - Path=/httpbin/** # Route requests starting with /httpbin to httpbin.org\n// 4. Run the API Gateway application.\n// 5. Send a request to your API Gateway to access httpbin.org through gateway routing:\n//    e.g., http://localhost:8080/httpbin/get\n// 6. Observe that the request is routed to httpbin.org and response is returned via API Gateway.\n\n// This demonstrates basic path-based routing in Spring Cloud Gateway."
        }
      ]
    },
    {
      "id": "microservices-circuit-breaker",
      "title": "Microservices Circuit Breaker Pattern",
      "description": "Implementing Circuit Breaker pattern for fault tolerance in microservices using Resilience4j or Netflix Hystrix.",
      "difficulty": "advanced",
      "category": "microservices",
      "explanation": "Circuit Breaker pattern is a crucial design pattern for building fault-tolerant microservices. In distributed systems, failures are inevitable. The Circuit Breaker pattern prevents cascading failures by stopping requests to a failing service for a certain period, giving the failing service time to recover and protecting the calling service from being blocked or overwhelmed by retries. It acts like an electrical circuit breaker that trips when there's a fault.\n\n**States of Circuit Breaker**: \n    - **Closed**: In normal operation, requests are passed through to the service. Failure counter is monitored. \n    - **Open**: When the failure threshold is reached (e.g., too many failures in a time window), the circuit breaker trips to the Open state. Requests are no longer forwarded to the service. Instead, a fallback response (or exception) is returned immediately. \n    - **Half-Open**: After a timeout period in the Open state, the circuit breaker enters the Half-Open state. A limited number of test requests are allowed to pass through to the service to check if it has recovered. If test requests succeed, the circuit breaker transitions back to the Closed state. If they fail, it goes back to the Open state.\n\n**Benefits of Circuit Breaker**: \n    - **Fault Tolerance**: Prevents cascading failures in microservices architectures. \n    - **Resilience**: Improves system resilience by gracefully handling service failures. \n    - **Stability**: Protects calling services from being overwhelmed by retries to failing services. \n    - **Fast Fail**: Fail fast mechanism returns fallback responses quickly when service is unavailable, improving responsiveness. \n    - **Recovery**: Allows failing services time to recover and automatically re-establishes connection when service becomes healthy again.\n\n**Resilience4j**: Resilience4j is a lightweight, fault tolerance library inspired by Hystrix, but designed for modern Java and reactive programming. \n    - **CircuitBreaker Registry**: Manages CircuitBreaker instances. \n    - **Annotations**: `@CircuitBreaker` annotation to decorate methods and apply circuit breaker behavior. \n    - **Programmatic API**: API to create and configure CircuitBreaker programmatically. \n    - **Metrics**: Provides metrics for monitoring circuit breaker state and performance.\n\n**Netflix Hystrix (Maintenance Mode)**: Hystrix was a widely used circuit breaker library by Netflix, but it's now in maintenance mode. Resilience4j is often considered a more actively developed and modern alternative. Hystrix also provides circuit breaker functionality and other fault tolerance patterns.",
      "example": "// Microservices Circuit Breaker Example - Resilience4j (Conceptual)\n\n// 1. Add Resilience4j Circuit Breaker dependency (e.g., resilience4j-spring-boot2).\n// 2. Configure Circuit Breaker in application.yml (optional, defaults are often sufficient).\n// 3. Annotate service methods that interact with external services with `@CircuitBreaker` annotation:\n//    @Service\n//    public class MyService {\n//        @CircuitBreaker(name = \"productServiceCB\", fallbackMethod = \"productServiceFallback\")\n//        public String getProductDetails(Long productId) {\n//            // ... call to external Product Service ...\n//        }\n//        public String productServiceFallback(Long productId, Throwable t) {\n//            // Fallback logic to execute when circuit is open or call fails\n//            return \"Product service unavailable. Please try again later.\";\n//        }\n//    }\n\n// 4. When calls to 'getProductDetails' fail and exceed the failure threshold, CircuitBreaker 'productServiceCB' will transition to Open state.\n// 5. Subsequent calls will directly execute 'productServiceFallback' method without calling the failing service, until circuit breaker transitions to Half-Open and Closed states again.",
      "keyPoints": [
        "Circuit Breaker Pattern: Prevents cascading failures, improves fault tolerance in microservices.",
        "States: Closed, Open, Half-Open.",
        "Benefits: Fault Tolerance, Resilience, Stability, Fast Fail, Recovery.",
        "Resilience4j: Modern, lightweight circuit breaker library, annotations and programmatic API.",
        "Netflix Hystrix: Older circuit breaker library (maintenance mode), Resilience4j often preferred now.",
        "`@CircuitBreaker` annotation in Resilience4j to apply circuit breaker behavior.",
        "Fallback method: Provides alternative logic when circuit is open or call fails."
      ],
      "quiz": [
        {
          "question": "What is the primary goal of the Circuit Breaker pattern?",
          "options": ["Load balancing.", "API routing.", "Preventing cascading failures and improving fault tolerance.", "Service discovery."],
          "correctAnswer": 2
        },
        {
          "question": "In the Circuit Breaker pattern, what happens when the circuit breaker is in the 'Open' state?",
          "options": ["Requests are passed through to the service.", "Requests are routed to a different service.", "Requests are no longer forwarded to the service, and a fallback response is returned.", "Requests are queued and retried later."],
          "correctAnswer": 2
        },
        {
          "question": "Resilience4j is a modern alternative to which older circuit breaker library?",
          "options": ["Ribbon", "Eureka", "Hystrix", "Zuul"],
          "correctAnswer": 2
        }
      ],
      "interactiveExamples": [
        {
          "title": "Implementing Circuit Breaker with Resilience4j",
          "code": "// Interactive Example: Implementing Circuit Breaker with Resilience4j\n\n// 1. Add Resilience4j Circuit Breaker dependency (resilience4j-spring-boot2) to your project.\n// 2. Create a Service class (e.g., ProductServiceClient) that calls an external Product Service (you can mock the external service for testing).\n// 3. Annotate a method in ProductServiceClient (e.g., fetchProductDetails) with `@CircuitBreaker(name = \"productServiceCB\", fallbackMethod = \"fetchProductDetailsFallback\")`.\n// 4. Implement the fallback method (fetchProductDetailsFallback) in the same class, with the same signature plus Throwable as the last parameter.\n// 5. In your test, simulate failures in the external Product Service calls (e.g., using Mockito to throw exceptions).\n// 6. Call the method with Circuit Breaker annotation (fetchProductDetails) and observe that after failures, the fallback method is invoked and circuit breaker transitions to Open state.\n\n// Example code snippet for Service with CircuitBreaker annotation:\n// @Service\n// public class ProductServiceClient {\n//     @CircuitBreaker(name = \"productServiceCB\", fallbackMethod = \"fetchProductDetailsFallback\")\n//     public String fetchProductDetails(String productId) {\n//         // ... code to call external Product Service that might fail ...\n//     }\n//     public String fetchProductDetailsFallback(String productId, Throwable t) {\n//         return \"Fallback response: Product service unavailable.\";\n//     }\n// }"
        }
      ]
    },
    {
      "id": "database-connection-pooling-advanced",
      "title": "Database Connection Pooling Advanced Configuration and Tuning",
      "description": "Advanced configuration and tuning of database connection pooling for performance optimization and resource management.",
      "difficulty": "advanced",
      "category": "database",
      "explanation": "Database connection pooling is essential for optimizing database performance in applications that frequently interact with databases. Advanced configuration and tuning of connection pools can further enhance performance, resource utilization, and application stability. Key aspects include pool sizing, connection timeout settings, leak detection, and monitoring.\n\n**Pool Sizing (Optimal Pool Size)**: Determining the right size for your connection pool is crucial. \n    - **Too Small Pool**: Can lead to connection starvation, increased latency, and application slowdowns under load. \n    - **Too Large Pool**: Can waste database resources, increase context switching overhead on both application and database servers, and potentially degrade performance. \n    - **Rule of Thumb**: Start with a pool size that is roughly equal to or slightly larger than the expected concurrent threads accessing the database. Monitor pool utilization and adjust based on application load and performance testing. \n    - **Consider Database Server Limits**: Ensure the pool size does not exceed the database server's connection limits and resource capacity.\n\n**Connection Timeout Settings**: Configure timeout settings to manage connection acquisition and idle connections. \n    - **Connection Timeout (Acquisition Timeout)**: Maximum time application will wait to acquire a connection from the pool if all connections are currently in use. Set an appropriate timeout to prevent indefinite waits but also avoid overly aggressive timeouts that might cause frequent connection failures. \n    - **Idle Timeout (Maximum Idle Time)**: Maximum time a connection can remain idle in the pool before being closed. Setting an idle timeout helps reclaim database resources used by idle connections. \n    - **Maximum Lifetime (Maximum Age)**: Maximum time a connection can live, regardless of idleness. Helps mitigate issues related to database server-side connection timeouts or resource leaks over long-lived connections.\n\n**Connection Leak Detection**: Connection leaks occur when application code fails to release connections back to the pool after use. Connection pool libraries often provide leak detection mechanisms to identify and log potential connection leaks. Configure leak detection thresholds and logging to help troubleshoot and fix connection leaks in your application code.\n\n**Monitoring and Metrics**: Monitor connection pool metrics to understand pool utilization, performance, and identify potential issues. Common metrics include: \n    - **Active Connections**: Number of connections currently in use. \n    - **Idle Connections**: Number of connections currently idle in the pool. \n    - **Wait Queue Size**: Number of threads waiting to acquire a connection. \n    - **Connection Timeouts**: Number of connection acquisition timeouts. \n    - **Connection Usage Time**: Time connections are held by application threads. \n    - **Metrics Tools**: Use monitoring tools (e.g., Actuator metrics, JMX, application monitoring dashboards) to track connection pool metrics and identify bottlenecks or performance issues.",
      "example": "// Database Connection Pooling Advanced Configuration Example - HikariCP (application.properties)\n\n// HikariCP specific properties (prefix: spring.datasource.hikari.*)\n// spring.datasource.hikari.maximum-pool-size=20 # Set maximum pool size\n// spring.datasource.hikari.connection-timeout=30000 # Connection timeout (milliseconds)\n// spring.datasource.hikari.idle-timeout=600000 # Idle timeout (milliseconds)\n// spring.datasource.hikari.max-lifetime=1800000 # Maximum connection lifetime (milliseconds)\n// spring.datasource.hikari.leak-detection-threshold=10000 # Leak detection threshold (milliseconds)\n// spring.datasource.hikari.validation-timeout=5000 # Validation timeout (milliseconds)\n// spring.datasource.hikari.pool-name=MyConnectionPool # Custom pool name for monitoring\n\n// Generic DataSource properties (prefix: spring.datasource.*)\n// spring.datasource.url=jdbc:h2:mem:testdb\n// spring.datasource.username=sa\n// spring.datasource.password=\n// spring.datasource.driver-class-name=org.h2.Driver",
      "keyPoints": [
        "Connection Pool Tuning: Optimize performance, resource utilization, and stability.",
        "Pool Sizing: Optimal pool size depends on concurrent threads and database server limits.",
        "Connection Timeout Settings: Connection Timeout, Idle Timeout, Maximum Lifetime.",
        "Connection Leak Detection: Identify and troubleshoot connection leaks.",
        "Monitoring and Metrics: Track Active Connections, Idle Connections, Wait Queue, Timeouts, etc.",
        "HikariCP: Popular high-performance connection pool, widely used in Spring Boot.",
        "Tune connection pool properties in `application.properties/yml` (e.g., HikariCP properties)."
      ],
      "quiz": [
        {
          "question": "What is the consequence of setting a database connection pool size too small?",
          "options": ["Database server overload.", "Increased application startup time.", "Connection starvation and application slowdowns.", "Improved database security."],
          "correctAnswer": 2
        },
        {
          "question": "What does 'Connection Timeout' in connection pool configuration typically refer to?",
          "options": ["Maximum lifetime of a connection.", "Maximum time a connection can be idle.", "Maximum time application waits to acquire a connection.", "Database server connection timeout."],
          "correctAnswer": 2
        },
        {
          "question": "Why is monitoring connection pool metrics important?",
          "options": ["To improve application security.", "To reduce database storage space.", "To understand pool utilization, performance, and identify potential issues.", "To simplify database configuration."],
          "correctAnswer": 2
        }
      ],
      "interactiveExamples": [
        {
          "title": "Monitoring HikariCP Connection Pool Metrics with Actuator",
          "code": "// Interactive Example: Monitoring HikariCP Connection Pool Metrics with Actuator\n\n// 1. Ensure you have spring-boot-starter-actuator and a database dependency (e.g., spring-boot-starter-jdbc, spring-boot-starter-data-jpa) in your project.\n// 2. Configure a database connection pool (HikariCP is default in Spring Boot).\n// 3. Run your Spring Boot application with Actuator enabled.\n// 4. Access Actuator metrics endpoint: http://localhost:8080/actuator/metrics/hikaricp.connections.active\n//    (Replace 'hikaricp.connections.active' with other HikariCP metrics like 'hikaricp.connections.idle', 'hikaricp.connections.creation.seconds.count', etc.)\n// 5. Observe the metrics related to your HikariCP connection pool. These metrics can be used for monitoring pool utilization and performance.\n\n// You can also use JMX monitoring tools (if JMX is enabled) to view HikariCP MBeans and connection pool metrics."
        }
      ]
    },
    {
      "id": "spring-cloud-config-server-client",
      "title": "Spring Cloud Config Server and Client",
      "description": "Externalized configuration management with Spring Cloud Config Server and Client for microservices.",
      "difficulty": "advanced",
      "category": "spring-cloud",
      "explanation": "Spring Cloud Config Server and Client provide a centralized and externalized configuration management solution for microservices architectures. Instead of embedding configuration directly within each microservice, configuration is stored externally (e.g., Git repository) and served by Config Server. Microservices (Config Clients) fetch their configuration from Config Server at startup and can receive configuration updates dynamically.\n\n**Benefits of Externalized Configuration**: \n    - **Centralized Configuration Management**: Manage configuration for all microservices in a single place (e.g., Git repository). Simplifies configuration updates and version control. \n    - **Environment-Specific Configuration**: Support different configurations for different environments (dev, test, prod) using profiles and environment-specific configuration files in the central repository. \n    - **Dynamic Configuration Updates**: Configuration changes can be applied without restarting microservices. Config Clients can refresh their configuration dynamically. \n    - **Security**: Securely manage sensitive configuration data (e.g., database passwords, API keys) using encryption and access control in the central configuration repository.\n\n**Spring Cloud Config Server**: \n    - **Configuration Repository**: Config Server reads configuration from a backend repository, typically a Git repository, but also supports other backends like Vault, JDBC, etc. \n    - **REST API**: Config Server exposes a REST API for clients to fetch configuration. Clients request configuration based on application name, profile, and label (branch or tag). \n    - **Encryption and Decryption**: Config Server can encrypt and decrypt sensitive configuration properties. \n    - **Spring Cloud Bus Integration**: Can integrate with Spring Cloud Bus to propagate configuration changes to clients dynamically.\n\n**Spring Cloud Config Client**: \n    - **Bootstrap Context**: Config Client bootstrap context is initialized before the main application context. It fetches initial configuration from Config Server during application startup. \n    - **`@RefreshScope`**: Annotate Spring beans to make them refreshable when configuration changes. When configuration is updated, beans annotated with `@RefreshScope` are re-created with the new configuration. \n    - **`/actuator/refresh` Endpoint**: Config Clients expose `/actuator/refresh` endpoint (when Actuator is enabled) to trigger manual configuration refresh. \n    - **Event-driven Refresh**: Spring Cloud Bus can be used for event-driven configuration refresh, propagating configuration changes from Config Server to clients automatically.",
      "example": "// Spring Cloud Config Server and Client Example (Conceptual)\n\n// 1. Config Server Application (Spring Boot):\n//    - Add spring-cloud-config-server dependency.\n//    - Annotate main class with @EnableConfigServer.\n//    - Configure configuration repository (e.g., Git repository URL) in application.properties:\n//      spring.cloud.config.server.git.uri=https://github.com/your-org/config-repo\n//      spring.cloud.config.server.git.search-paths=config-data\n//      server.port=8888\n\n// 2. Config Client Microservice (Spring Boot):\n//    - Add spring-cloud-starter-config dependency.\n//    - Configure application name (spring.application.name) - used to fetch configuration from Config Server.\n//    - Configure Config Server URL (spring.cloud.config.uri) in bootstrap.properties (or bootstrap.yml) - important to use bootstrap context for early configuration loading.\n//    - Application will fetch configuration from Config Server at startup and during refresh.\n\n// 3. Configuration Repository (Git):\n//    - Create a Git repository (e.g., 'config-repo').\n//    - Create configuration files in the repository, named according to Spring Cloud Config conventions:\n//      e.g., 'myapp-dev.properties', 'myapp-prod.yml', 'myapp.properties' (for application 'myapp').",
      "keyPoints": [
        "Spring Cloud Config: Centralized, externalized configuration management for microservices.",
        "Config Server: Serves configuration from backend repository (Git, etc.) via REST API.",
        "Config Client: Fetches configuration from Config Server at startup, dynamic refresh.",
        "Benefits: Centralized management, environment-specific config, dynamic updates, security.",
        "`@RefreshScope`: Make beans refreshable on configuration changes.",
        "`/actuator/refresh`: Endpoint to trigger manual configuration refresh.",
        "Bootstrap context: Loads initial configuration from Config Server before main context."
      ],
      "quiz": [
        {
          "question": "What is the primary benefit of using Spring Cloud Config Server and Client?",
          "options": ["Improved application performance.", "Centralized and externalized configuration management.", "Enhanced security for microservices.", "Simplified service discovery."],
          "correctAnswer": 1
        },
        {
          "question": "Which repository type is commonly used as a backend for Spring Cloud Config Server?",
          "options": ["Database.", "Message queue.", "Git repository.", "NoSQL database."],
          "correctAnswer": 2
        },
        {
          "question": "Which annotation is used to make a Spring bean refreshable when configuration changes in Spring Cloud Config Client?",
          "options": ["@ConfigurationProperties", "@Component", "@Refreshable", "@RefreshScope"],
          "correctAnswer": 3
        }
      ],
      "interactiveExamples": [
        {
          "title": "Setting up Spring Cloud Config Server and Client (Conceptual)",
          "code": "// Interactive Example: Setting up Spring Cloud Config Server and Client (Conceptual)\n\n// 1. Create a Git repository on GitHub or locally (e.g., 'spring-cloud-config-repo').\n// 2. Create application configuration files in the repository (e.g., 'config-client-dev.properties', 'config-client.properties').\n// 3. Create a Spring Boot project for Config Server ('config-server-app').\n// 4. Add spring-cloud-config-server dependency and @EnableConfigServer annotation.\n// 5. Configure Git repository URL in Config Server's application.properties.\n// 6. Create a Spring Boot project for Config Client ('config-client-app').\n// 7. Add spring-cloud-starter-config dependency.\n// 8. Configure Config Server URL in Config Client's bootstrap.properties (or bootstrap.yml).\n// 9. Run Config Server and Config Client applications.\n// 10. Verify that Config Client fetches configuration properties from Config Server (check logs or Actuator endpoints).\n// 11. Modify configuration in Git repository, commit changes, and trigger configuration refresh in Config Client (using `/actuator/refresh` endpoint or Spring Cloud Bus) to observe dynamic updates.\n\n// Note: This is a conceptual setup. Actual implementation requires creating Spring Boot projects, configuring dependencies, and setting up a Git repository with configuration files."
        }
      ]
    }
  ]
}