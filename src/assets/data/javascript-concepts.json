{
  "concepts": [
    {
      "id": "js-variables-datatypes",
      "title": "Variables and Data Types",
      "description": "Learn about JavaScript variables, declaration methods (var, let, const), and fundamental data types including numbers, strings, booleans, null, and undefined.",
      "difficulty": "beginner",
      "category": "fundamentals",
      "explanation": "JavaScript is a dynamically-typed language, meaning you don't explicitly declare the data type of a variable. The type is determined at runtime based on the value assigned. You have three keywords to declare variables: `var`, `let`, and `const`. `var` is function-scoped and has hoisting behavior, which can lead to confusion and bugs in modern JavaScript. It's generally recommended to avoid `var` in favor of `let` and `const`. `let` and `const` are block-scoped, meaning they are only accessible within the block they are defined (e.g., inside an `if` statement or a loop). `let` is used for variables that you intend to reassign, while `const` is for variables whose value should remain constant after initialization.  JavaScript has six primitive data types: String (textual data), Number (numeric data, including integers and floating-point numbers), Boolean (true/false values), Null (intentional absence of any object value), Undefined (value of a variable that has not been assigned a value), and Symbol (unique and immutable primitive value, often used as object keys, introduced in ES6). Understanding these data types and variable scopes is foundational for writing any JavaScript program.",
      "example": "// Variable declarations\nlet count = 0;           // Number - Initialized to 0, can be reassigned\nconst userName = 'John Doe'; // String - Constant, cannot be reassigned after this\nlet isLoggedIn = true;     // Boolean - Represents a true/false state, can be reassigned\nlet userData = null;         // Null - Explicitly set to no value, can be reassigned (though less common for null)\nlet address;              // Undefined - Declared but not initialized, will be undefined until assigned\n\n// Reassignment (allowed for let, not for const)\ncount = 10;\nisLoggedIn = false;\n// userName = 'Jane Doe'; // This would cause an error because userName is const\n\n// Type checking using typeof operator\nconsole.log('Type of count:', typeof count);    // 'number'\nconsole.log('Type of userName:', typeof userName);     // 'string'\nconsole.log('Type of isLoggedIn:', typeof isLoggedIn); // 'boolean'\nconsole.log('Type of userData:', typeof userData);     // 'object' (Note: typeof null is an historical anomaly and should be considered null)\nconsole.log('Type of address:', typeof address);    // 'undefined'\nconsole.log('Type of Symbol:', typeof Symbol('unique')); // 'symbol'",
      "keyPoints": [
        "Use `let` for variables that may be reassigned and `const` for variables intended to hold a constant value. Favor `const` by default and use `let` when reassignment is necessary.",
        "JavaScript has six primitive data types: string, number, boolean, null, undefined, and symbol. Understanding these types is crucial for manipulating data correctly.",
        "The `typeof` operator is essential for determining the data type of a value at runtime, which is useful for debugging and type checking (though not as strict as in statically-typed languages).",
        "Variables declared with `let` and `const` are block-scoped, which helps in writing cleaner and more maintainable code by preventing accidental variable leakage into larger scopes. This is a significant improvement over `var`'s function scope.",
        "`var` is function-scoped and hoisted, which can lead to unexpected behavior and is generally discouraged in modern JavaScript development. Avoid using `var` unless you have a specific legacy reason.",
        "While `typeof null` returns 'object', this is a known quirk in JavaScript. Logically, `null` is its own distinct type representing the intentional absence of a value.",
        "Symbols (ES6+) provide a way to create unique identifiers, often used for object properties to avoid naming collisions, especially in library development."
      ],
      "quiz": [
        {
          "question": "What is the primary difference between `let` and `const` in JavaScript?",
          "options": ["`let` is function-scoped, `const` is block-scoped", "`let` can be reassigned, `const` cannot", "`const` is used for numbers, `let` for strings", "There is no significant difference between `let` and `const`"],
          "correctAnswer": 1
        },
        {
          "question": "Which of the following is NOT a primitive data type in JavaScript?",
          "options": ["string", "boolean", "array", "undefined"],
          "correctAnswer": 2
        },
        {
          "question": "What is the scope of a variable declared with `var`?",
          "options": ["Block scope", "Global scope", "Function scope", "Lexical scope"],
          "correctAnswer": 2
        },
        {
          "question": "What will `typeof null` return in JavaScript?",
          "options": ["'null'", "'undefined'", "'object'", "'primitive'"],
          "correctAnswer": 3
        },
        {
          "question": "Which keyword is recommended for declaring variables that should not be reassigned after their initial assignment?",
          "options": ["`var`", "`let`", "`const`", "`static`"],
          "correctAnswer": 2
        }
      ],
      "interactiveExamples": [
        {
          "title": "Variable Declaration and Scope Experiment",
          "code": "// Experiment with let, const, and var scopes\nfunction checkScope() {\n  if (true) {\n    var varVariable = 'var scope';\n    let letVariable = 'let scope';\n    const constVariable = 'const scope';\n    console.log('Inside block - var:', varVariable); // Accessible\n    console.log('Inside block - let:', letVariable); // Accessible\n    console.log('Inside block - const:', constVariable); // Accessible\n  }\n  console.log('Outside block - var:', varVariable); // Accessible - function scope\n  // console.log('Outside block - let:', letVariable); // Error - block scope\n  // console.log('Outside block - const:', constVariable); // Error - block scope\n}\ncheckScope();\n\n// Observe which variables are accessible outside the if block and understand scoping"
        },
        {
          "title": "Data Type Exploration",
          "code": "// Explore different data types and typeof operator\nlet myString = 'Hello, JavaScript!';\nlet myNumber = 123;\nlet myBoolean = false;\nlet myNull = null;\nlet myUndefined;\nlet mySymbol = Symbol('uniqueSymbol');\n\nconsole.log('Type of myString:', typeof myString, ', Value:', myString);\nconsole.log('Type of myNumber:', typeof myNumber, ', Value:', myNumber);\nconsole.log('Type of myBoolean:', typeof myBoolean, ', Value:', myBoolean);\nconsole.log('Type of myNull:', typeof myNull, ', Value:', myNull);\nconsole.log('Type of myUndefined:', typeof myUndefined, ', Value:', myUndefined);\nconsole.log('Type of mySymbol:', typeof mySymbol, ', Value:', mySymbol.toString());\n\n// Change the values and declarations to see how types change"
        }
      ]
    },
    {
      "id": "js-functions-basics",
      "title": "Functions Fundamentals",
      "description": "Master JavaScript functions including function declarations, expressions, arrow functions, and function parameters.",
      "difficulty": "beginner",
      "category": "functions",
      "explanation": "Functions are fundamental building blocks in JavaScript. They are reusable blocks of code designed to perform a specific task. Functions help in organizing code, making it modular and easier to maintain. In JavaScript, functions are first-class citizens, meaning they can be treated like any other value - assigned to variables, passed as arguments to other functions, and returned from functions. There are several ways to define functions in JavaScript: Function declarations, function expressions, and arrow functions (introduced in ES6). Function declarations are hoisted, meaning they can be called before they are defined in the code. Function expressions are not hoisted and are created when the line of code where they are defined is reached. Arrow functions provide a more concise syntax and have lexical `this` binding, which can be beneficial in certain contexts. Functions can accept parameters (inputs) and return values (outputs). Parameters allow you to pass data into a function, and the `return` statement allows a function to send a value back to the caller. Understanding function types and their behavior is essential for writing effective JavaScript code.",
      "example": "// Function Declaration\nfunction greet(name) { // 'name' is a parameter\n  return `Hello, ${name}!`; // Returns a string value\n}\n\n// Function Expression\nconst sayGoodbye = function(name) { // Assigning an anonymous function to a variable\n  return `Goodbye, ${name}!`;\n};\n\n// Arrow Function (Concise syntax, especially for simple functions)\nconst add = (a, b) => a + b; // Implicit return for single expression\nconst multiply = (x, y) => { // Explicit return for multi-line functions\n  const result = x * y;\n  return result;\n};\n\n// Using the functions\nconsole.log(greet('Alice'));      // Output: Hello, Alice!\nconsole.log(sayGoodbye('Bob')); // Output: Goodbye, Bob!\nconsole.log(add(5, 3));          // Output: 8\nconsole.log(multiply(4, 6));     // Output: 24\n\n// Function with default parameters (ES6 feature)\nfunction power(base, exponent = 2) { // Default exponent is 2 if not provided\n  return Math.pow(base, exponent);\n}\nconsole.log(power(3));       // Output: 9 (3^2)\nconsole.log(power(3, 3));    // Output: 27 (3^3)",
      "keyPoints": [
        "Function declarations are hoisted, which means you can call them before their declaration in your code. This is not the case for function expressions.",
        "Arrow functions offer a more concise syntax compared to traditional function expressions, especially for short, simple functions. They also lexically bind `this`, which can be advantageous in certain scenarios like callbacks.",
        "Functions can accept zero or more parameters, allowing them to operate on different inputs. Parameters are placeholders for values that will be passed when the function is called.",
        "Functions can return values using the `return` statement. If no `return` statement is present, or if `return` is used without a value, the function implicitly returns `undefined`.",
        "Functions in JavaScript are 'first-class citizens', meaning they can be assigned to variables, passed as arguments to other functions (callbacks), and returned as values from other functions. This is a powerful feature enabling functional programming paradigms.",
        "Default parameters (ES6+) allow you to set default values for function parameters, making functions more flexible and easier to use with optional arguments.",
        "Understanding the difference between function declarations and expressions, and when to use arrow functions, is crucial for writing clean and efficient JavaScript code."
      ],
      "quiz": [
        {
          "question": "What is the key difference between function declaration and function expression regarding hoisting?",
          "options": ["Function expressions are hoisted, function declarations are not", "Function declarations are hoisted, function expressions are not", "Both function declarations and expressions are hoisted", "Neither function declarations nor expressions are hoisted"],
          "correctAnswer": 1
        },
        {
          "question": "Which of the following is NOT a valid way to define a function in JavaScript?",
          "options": ["Function declaration", "Function expression", "Arrow function", "Method function"],
          "correctAnswer": 3
        },
        {
          "question": "What is the return value of a JavaScript function if it does not have a `return` statement?",
          "options": ["`null`", "`0`", "`undefined`", "An error"],
          "correctAnswer": 2
        },
        {
          "question": "What is a 'first-class citizen' in the context of JavaScript functions?",
          "options": ["Functions can only be used for simple tasks", "Functions are treated like any other data type and can be assigned to variables and passed as arguments", "Functions are less important than objects", "Functions cannot be returned from other functions"],
          "correctAnswer": 1
        },
        {
          "question": "Which type of function syntax is generally more concise and often used for short, simple functions?",
          "options": ["Function declaration", "Function expression", "Arrow function", "Anonymous function expression"],
          "correctAnswer": 2
        }
      ],
      "interactiveExamples": [
        {
          "title": "Function Types and Hoisting",
          "code": "// Try calling functionDeclaration before its definition - Works due to hoisting\nconsole.log(functionDeclaration(5));\n\nfunction functionDeclaration(num) {\n  return num * 2;\n}\n\n// Try calling functionExpression before its definition - Error due to no hoisting\n// console.log(functionExpression(5)); // Uncommenting this will cause an error\n\nconst functionExpression = function(num) {\n  return num * 2;\n};\nconsole.log(functionExpression(5));\n\n// Experiment with calling each type of function before and after its definition to observe hoisting"
        },
        {
          "title": "Arrow Functions vs. Function Expressions",
          "code": "// Function Expression\nconst addExpression = function(a, b) {\n  return a + b;\n};\nconsole.log('Function Expression add:', addExpression(10, 5));\n\n// Arrow Function - more concise\nconst addArrow = (a, b) => a + b;\nconsole.log('Arrow Function add:', addArrow(10, 5));\n\n// Arrow Function with block body and explicit return\nconst multiplyArrow = (a, b) => {\n  const result = a * b;\n  return result;\n};\nconsole.log('Arrow Function multiply:', multiplyArrow(7, 3));\n\n// Convert function expressions to arrow functions and see how the syntax simplifies"
        }
      ]
    },
    {
      "id": "js-objects-prototypes",
      "title": "Objects and Prototypes",
      "description": "Deep dive into JavaScript objects, object methods, prototypal inheritance, and the prototype chain.",
      "difficulty": "intermediate",
      "category": "objects",
      "explanation": "Objects are fundamental in JavaScript, serving as collections of key-value pairs, where keys are strings (or Symbols) and values can be any JavaScript data type (including other objects). JavaScript uses prototypal inheritance, a paradigm where objects inherit properties and methods directly from other objects, known as prototypes. Unlike class-based inheritance found in languages like Java or C++, JavaScript inheritance is based on delegation. Every object in JavaScript, except for objects created with `Object.create(null)`, has a prototype object. When you try to access a property on an object, JavaScript first looks for the property directly on the object itself. If not found, it then searches the object's prototype, and if still not found, it continues up the prototype chain until it reaches `null` (the end of the chain). This chain of prototypes is called the prototype chain.  Understanding prototypal inheritance is crucial for object-oriented programming in JavaScript. You can create objects using object literals, constructor functions, or ES6 classes (which are syntactic sugar over prototypes). Methods are functions associated with objects and are defined as properties whose values are functions. Manipulating prototypes allows for powerful patterns of code reuse and inheritance.",
      "example": "// Creating an object using object literal\nconst person = {\n  name: 'John',\n  age: 30,\n  city: 'New York',\n  greet() { // Method definition\n    return `Hello, I'm ${this.name} from ${this.city}.`;\n  }\n};\n\n// Accessing object properties\nconsole.log('Person's name:', person.name);     // Output: John (dot notation)\nconsole.log('Person's age:', person['age']);    // Output: 30 (bracket notation)\nconsole.log('Greeting:', person.greet());        // Output: Hello, I'm John from New York.\n\n// Prototypal Inheritance using Object.create()\nconst animal = {\n  type: 'animal',\n  speak() {\n    return 'Generic animal sound';\n  }\n};\n\nconst dog = Object.create(animal); // dog inherits from animal\ndog.breed = 'Labrador'; // Adding a property specific to dog\ndog.speak = function() { // Overriding the speak method for dog\n  return 'Woof!';\n};\n\nconsole.log('Dog type:', dog.type);        // Output: animal (inherited from animal prototype)\nconsole.log('Dog breed:', dog.breed);       // Output: Labrador (own property)\nconsole.log('Dog sound:', dog.speak());       // Output: Woof! (own method, overrides animal's speak)\nconsole.log('Animal sound:', animal.speak());  // Output: Generic animal sound (original animal method)\n\n// Checking the prototype chain\nconsole.log('Dog's prototype is animal:', Object.getPrototypeOf(dog) === animal); // Output: true\nconsole.log('Animal's prototype is Object.prototype:', Object.getPrototypeOf(animal) === Object.prototype); // Output: true",
      "keyPoints": [
        "Objects in JavaScript are collections of key-value pairs. Keys are strings or Symbols, and values can be any JavaScript data type, including other objects, functions (methods), primitives.",
        "Properties of objects can be accessed using dot notation (`object.property`) or bracket notation (`object['property']`). Bracket notation is necessary when property names are not valid identifiers or are determined dynamically.",
        "`Object.create(proto)` creates a new object with the specified `proto` object as its prototype. This is a fundamental way to establish prototypal inheritance in JavaScript.",
        "Prototypal inheritance allows objects to inherit properties and methods from their prototypes. When a property is accessed on an object, the JavaScript engine first looks at the object itself, then its prototype, and so on, up the prototype chain.",
        "The prototype chain is a sequence of prototypes, ending with `null`. Most objects inherit from `Object.prototype`, which is at the top of the chain for standard objects.",
        "Modern JavaScript provides `class` syntax (introduced in ES6) as syntactic sugar over the prototypal inheritance model. Classes provide a more familiar syntax for developers coming from class-based languages, but they are still based on prototypes under the hood.",
        "Understanding prototypes is key to mastering object-oriented JavaScript, including inheritance, method overriding, and creating reusable object patterns."
      ],
      "quiz": [
        {
          "question": "What is prototypal inheritance in JavaScript?",
          "options": ["Objects inherit from classes", "Objects inherit directly from other objects", "Inheritance based on interfaces", "Multiple inheritance from different classes"],
          "correctAnswer": 1
        },
        {
          "question": "What is the prototype chain in JavaScript?",
          "options": ["A chain of classes", "A sequence of objects linked together by prototype relationships", "A list of properties of an object", "A method for creating objects"],
          "correctAnswer": 1
        },
        {
          "question": "How do you create an object that inherits from another object in JavaScript using prototypal inheritance?",
          "options": ["Using the `extends` keyword", "Using `Object.create()`", "Using the `new` keyword with a class", "By directly assigning properties from one object to another"],
          "correctAnswer": 1
        },
        {
          "question": "What happens when you try to access a property on an object that is not directly on the object itself?",
          "options": ["JavaScript throws an error", "JavaScript returns `undefined`", "JavaScript searches for the property in the object's prototype chain", "JavaScript creates a new property on the object"],
          "correctAnswer": 2
        },
        {
          "question": "Are ES6 classes in JavaScript fundamentally based on prototypal inheritance or class-based inheritance?",
          "options": ["Class-based inheritance", "Prototypal inheritance", "A hybrid of both", "Neither, they are a new form of inheritance"],
          "correctAnswer": 1
        }
      ],
      "interactiveExamples": [
        {
          "title": "Object Creation and Property Access",
          "code": "// Create a simple object\nconst book = {\n  title: 'The JavaScript Way',\n  author: 'John Smith',\n  pages: 300,\n  read: function() {\n    return 'Reading ' + this.title;\n  }\n};\n\n// Access properties using dot and bracket notation\nconsole.log('Book Title (dot notation):', book.title);\nconsole.log('Book Author (bracket notation):', book['author']);\nconsole.log('Book Reading:', book.read());\n\n// Add a new property\nbook.genre = 'Programming';\nconsole.log('Book Genre:', book.genre);\n\n// Try accessing and modifying properties, and calling methods"
        },
        {
          "title": "Prototypal Inheritance in Action",
          "code": "// Define a prototype object\nconst vehicle = {\n  wheels: 4,\n  startEngine: function() {\n    return 'Engine started';\n  }\n};\n\n// Create a car object inheriting from vehicle\nconst car = Object.create(vehicle);\ncar.model = 'Sedan';\n\n// Create a motorcycle object inheriting from vehicle\nconst motorcycle = Object.create(vehicle);\nmotorcycle.wheels = 2; // Override wheels property\n\nconsole.log('Car wheels:', car.wheels);         // Inherited from vehicle\nconsole.log('Car model:', car.model);          // Own property\nconsole.log('Car start engine:', car.startEngine()); // Inherited method\nconsole.log('Motorcycle wheels:', motorcycle.wheels); // Overridden property\nconsole.log('Motorcycle start engine:', motorcycle.startEngine()); // Inherited method\n\n// Experiment with creating more objects and modifying prototype properties and methods"
        }
      ]
    },
    {
      "id": "js-async-programming",
      "title": "Asynchronous Programming",
      "description": "Learn about callbacks, promises, async/await, and handling asynchronous operations in JavaScript.",
      "difficulty": "advanced",
      "category": "async",
      "explanation": "Asynchronous programming in JavaScript is crucial for handling operations that might take some time to complete, such as network requests, file I/O, or timers, without blocking the main thread. This ensures that the user interface remains responsive and the application doesn't freeze during these operations. JavaScript is single-threaded, meaning it executes code line by line in a single sequence. To manage asynchronous operations, JavaScript uses mechanisms like callbacks, Promises, and async/await (which is built on Promises). Callbacks are functions passed as arguments to asynchronous operations, which are executed once the operation completes. However, heavy use of callbacks can lead to 'callback hell' (deeply nested callbacks), making code hard to read and maintain. Promises provide a more structured way to handle asynchronous operations. A Promise represents the eventual result of an asynchronous operation, which can be in one of three states: pending, fulfilled (with a value), or rejected (with a reason). Promises make asynchronous code easier to manage and chain. Async/await, introduced in ES8, is built on Promises and provides a more synchronous-looking way to write asynchronous code. `async` functions always return a Promise, and `await` can be used inside an `async` function to pause execution until a Promise resolves, making asynchronous code look and behave more like synchronous code. Understanding these asynchronous patterns is essential for modern JavaScript development, especially for frontend applications that frequently interact with APIs and handle user events.",
      "example": "// Using Callbacks (Traditional approach, can lead to callback hell)\nfunction fetchDataCallback(callback) {\n  setTimeout(() => {\n    const data = { id: 1, name: 'Callback Data' };\n    callback(data); // Execute callback with fetched data\n  }, 1000);\n}\n\nfetchDataCallback(function(data) {\n  console.log('Data from callback:', data);\n  // Nested callback example (can get complex)\n  setTimeout(() => {\n    const moreData = { details: 'More callback info' };\n    // callback hell can start forming here...\n    console.log('More data:', moreData);\n  }, 500);\n});\n\n// Using Promises (More structured approach)\nfunction fetchDataPromise() {\n  return new Promise((resolve, reject) => { // Promise constructor\n    setTimeout(() => {\n      const data = { id: 2, name: 'Promise Data' };\n      resolve(data); // Resolve the promise with data\n      // reject('Error fetching data'); // Reject the promise in case of error\n    }, 1000);\n  });\n}\n\nfetchDataPromise()\n  .then(data => {\n    console.log('Data from promise:', data);\n    return fetchDataPromise(); // Promise chaining\n  })\n  .then(moreData => {\n    console.log('More promise data:', moreData);\n  })\n  .catch(error => {\n    console.error('Promise error:', error);\n  });\n\n// Using Async/Await (Simplifies promise handling, synchronous style)\nasync function fetchDataAsync() {\n  try {\n    console.log('Fetching data...');\n    const data = await fetchDataPromise(); // Await promise resolution\n    console.log('Data from async/await:', data);\n    const moreData = await fetchDataPromise(); // Await another promise\n    console.log('More async/await data:', moreData);\n    return data;\n  } catch (error) {\n    console.error('Async/await error:', error);\n  }\n}\n\nfetchDataAsync();",
      "keyPoints": [
        "Asynchronous programming allows JavaScript to handle long-running operations without blocking the main thread, keeping the UI responsive.",
        "Callbacks were the original way to handle asynchronous operations in JavaScript, but they can lead to complex and hard-to-maintain 'callback hell'.",
        "Promises provide a more structured and manageable way to deal with asynchronous operations. They represent the eventual result of an operation and can be chained for sequential asynchronous tasks.",
        "Async/await is syntactic sugar built on top of Promises, making asynchronous code look and behave more like synchronous code, improving readability and reducing complexity.",
        "`async` functions always return a Promise. `await` can only be used inside an `async` function and pauses the execution until the Promise it's awaiting resolves.",
        "Error handling in asynchronous code using Promises and async/await is typically done using `.catch()` for Promises and `try/catch` blocks for async/await, providing clear and centralized error management.",
        "`Promise.all()` and `Promise.race()` are useful for handling multiple promises concurrently, allowing for parallel execution of asynchronous tasks.",
        "The JavaScript event loop is the underlying mechanism that enables asynchronous behavior. It manages the execution of asynchronous tasks and callbacks in a non-blocking way."
      ],
      "quiz": [
        {
          "question": "What is the primary purpose of asynchronous programming in JavaScript?",
          "options": ["To make code run faster", "To handle long-running operations without blocking the main thread", "To simplify synchronous code", "To replace synchronous programming completely"],
          "correctAnswer": 1
        },
        {
          "question": "Which of the following is NOT a common approach for handling asynchronous operations in JavaScript?",
          "options": ["Callbacks", "Promises", "Async/await", "Synchronous functions"],
          "correctAnswer": 3
        },
        {
          "question": "What does a Promise represent in JavaScript?",
          "options": ["An immediate result of an operation", "The eventual result of an asynchronous operation", "A function that will be called later", "An error in asynchronous code"],
          "correctAnswer": 1
        },
        {
          "question": "Which keyword is used to pause the execution of an async function until a Promise resolves?",
          "options": ["`async`", "`await`", "`promise`", "`resolve`"],
          "correctAnswer": 2
        },
        {
          "question": "What is 'callback hell'?",
          "options": ["A type of error in JavaScript", "Deeply nested and hard-to-read callbacks in asynchronous code", "A feature of Promises", "A way to simplify asynchronous code"],
          "correctAnswer": 1
        }
      ],
      "interactiveExamples": [
        {
          "title": "Promise Example - Simulating API Call",
          "code": "// Function that returns a Promise simulating an API call\nfunction simulateApiCall(delay, data) {\n  return new Promise((resolve) => {\n    setTimeout(() => {\n      resolve(data);\n    }, delay);\n  });\n}\n\nsimulateApiCall(2000, { message: 'Data fetched after 2 seconds' })\n  .then(result => {\n    console.log('API Call Result:', result);\n  });\n\nconsole.log('This message appears before the API call resolves because it's asynchronous.');\n\n// Modify the delay and data to experiment with Promise behavior"
        },
        {
          "title": "Async/Await Example - Fetching Data",
          "code": "// Async function to fetch data (simulated)\nasync function fetchDataAsyncExample() {\n  try {\n    console.log('Fetching data...');\n    const userData = await simulateApiCall(1500, { name: 'Async User', id: 123 });\n    console.log('User Data:', userData);\n    const productData = await simulateApiCall(1000, { product: 'Laptop', price: 1200 });\n    console.log('Product Data:', productData);\n    console.log('Data fetching complete.');\n  } catch (error) {\n    console.error('Error fetching data:', error);\n  }\n}\n\nfetchDataAsyncExample();\n\n// Observe how async/await makes asynchronous operations look sequential"
        }
      ]
    },
    {
      "id": "js-es6-features",
      "title": "Modern JavaScript (ES6+)",
      "description": "Explore modern JavaScript features including destructuring, spread operator, modules, and template literals.",
      "difficulty": "intermediate",
      "category": "es6",
      "explanation": "ES6 (ECMAScript 2015) and subsequent versions have introduced a wealth of powerful and convenient features to JavaScript, significantly enhancing the language's capabilities and developer productivity. These features streamline common tasks, improve code readability, and enable more sophisticated programming patterns. Destructuring allows you to unpack values from arrays or properties from objects into distinct variables, making code cleaner and more expressive. The spread operator (`...`) provides a concise way to expand elements of an iterable (like arrays or strings) or properties of objects, useful for creating copies, combining arrays or objects, and passing variable arguments to functions. Template literals, using backticks (``), offer a powerful way to define strings, allowing for easy string interpolation (embedding expressions directly within strings) and multiline strings without concatenation. Modules (ES modules) enable better code organization by allowing you to split code into reusable, self-contained files, and import/export functionalities between them, which is crucial for building large-scale applications. These ES6+ features are now fundamental to modern JavaScript development and are widely used in frontend frameworks and libraries.",
      "example": "// Destructuring - Extracting values from objects and arrays\nconst person = { firstName: 'John', lastName: 'Doe', age: 30, city: 'London' };\nconst { firstName, lastName, age } = person; // Object destructuring\nconsole.log('Name:', firstName, lastName, 'Age:', age); // Output: Name: John Doe Age: 30\n\nconst colors = ['red', 'green', 'blue'];\nconst [firstColor, secondColor] = colors; // Array destructuring\nconsole.log('First color:', firstColor, 'Second color:', secondColor); // Output: First color: red Second color: green\n\n// Spread Operator - Expanding arrays and objects\nconst numbers = [1, 2, 3];\nconst moreNumbers = [...numbers, 4, 5]; // Spread array to create a new array\nconsole.log('Combined numbers:', moreNumbers); // Output: Combined numbers: [1, 2, 3, 4, 5]\n\nconst address = { street: '123 Main St', country: 'USA' };\nconst fullPerson = { ...person, ...address }; // Spread objects to merge properties\nconsole.log('Full person info:', fullPerson); // Output: Full person info: {firstName: 'John', lastName: 'Doe', age: 30, city: 'London', street: '123 Main St', country: 'USA'}\n\n// Template Literals - String interpolation and multiline strings\nconst name = 'Alice';\nconst greeting = `Hello, ${name}! Welcome to ES6+ features.`; // String interpolation\nconsole.log(greeting); // Output: Hello, Alice! Welcome to ES6+ features.\n\nconst multilineText = `This is a\nmultiline string\nusing template literals.`; // Multiline string\nconsole.log(multilineText);\n\n// Modules - Export and Import (Conceptual example, requires module setup)\n// math.js (module file)\n// export const add = (a, b) => a + b;\n// app.js (another module file)\n// import { add } from './math.js';\n// console.log('Module add function:', add(10, 20));",
      "keyPoints": [
        "Destructuring simplifies the process of extracting values from arrays and objects, making code more readable and less verbose. It works for both object properties and array elements.",
        "The spread operator (`...`) is incredibly versatile. It can be used to create shallow copies of arrays and objects, concatenate arrays, merge objects, and provide arguments to functions.",
        "Template literals provide a cleaner and more intuitive way to work with strings, especially when you need to embed expressions or create multiline strings. They eliminate the need for complex string concatenation.",
        "ES modules (using `export` and `import`) are essential for organizing JavaScript code into modular, reusable components, improving maintainability and scalability of applications. Modules help avoid global scope pollution and promote code encapsulation.",
        "ES6+ features collectively aim to make JavaScript more expressive, efficient, and developer-friendly. Adopting these features is crucial for writing modern JavaScript code and working with contemporary frontend frameworks and libraries.",
        "These features are widely supported in modern browsers and Node.js environments, making them practical for use in almost all new JavaScript projects."
      ],
      "quiz": [
        {
          "question": "What is the primary purpose of destructuring in JavaScript?",
          "options": ["To create new objects", "To extract values from arrays and objects into variables", "To modify object properties", "To delete array elements"],
          "correctAnswer": 1
        },
        {
          "question": "Which operator is used for spread syntax in ES6+?",
          "options": ["`->`", "`...`", "`::`", "`=>`"],
          "correctAnswer": 1
        },
        {
          "question": "What are template literals in JavaScript?",
          "options": ["Strings created with single quotes", "Strings created with double quotes", "Strings created with backticks, allowing for interpolation and multiline strings", "Strings that cannot be modified"],
          "correctAnswer": 2
        },
        {
          "question": "What benefit do ES modules provide in JavaScript?",
          "options": ["Improved code performance", "Better code organization and reusability", "Automatic error handling", "Simplified syntax for loops"],
          "correctAnswer": 1
        },
        {
          "question": "Which of the following is NOT a common use case for the spread operator?",
          "options": ["Creating copies of arrays", "Merging objects", "Defining function parameters", "Destructuring objects"],
          "correctAnswer": 3
        }
      ],
      "interactiveExamples": [
        {
          "title": "Destructuring Objects and Arrays",
          "code": "// Object destructuring\nconst config = { apiKey: 'YOUR_API_KEY', timeout: 5000, endpoint: '/api/data' };\nconst { apiKey, endpoint } = config; // Extract apiKey and endpoint\nconsole.log('API Key:', apiKey);\nconsole.log('Endpoint:', endpoint);\n\n// Array destructuring\nconst dataPoints = [100, 200, 150, 300];\nconst [firstValue, secondValue, ...restValues] = dataPoints; // Get first two and rest\nconsole.log('First Value:', firstValue);\nconsole.log('Second Value:', secondValue);\nconsole.log('Rest of Values:', restValues);\n\n// Experiment with destructuring different objects and arrays"
        },
        {
          "title": "Spread Operator for Array and Object Manipulation",
          "code": "// Spread operator for array copy and concatenation\nconst originalArray = [1, 2, 3];\nconst copiedArray = [...originalArray]; // Create a copy\nconst extraElements = [4, 5, 6];\nconst combinedArray = [...originalArray, ...extraElements]; // Concatenate\nconsole.log('Copied Array:', copiedArray);\nconsole.log('Combined Array:', combinedArray);\n\n// Spread operator for object copy and merge\nconst baseObject = { a: 1, b: 2 };\nconst extendedObject = { ...baseObject, c: 3, d: 4 }; // Merge and extend\nconsole.log('Extended Object:', extendedObject);\n\n// Try different spread operations and observe the results"
        }
      ]
    },
    {
      "id": "js-closures",
      "title": "Closures and Scope",
      "description": "Understanding JavaScript closures, lexical scope, and practical applications in modern JavaScript.",
      "difficulty": "advanced",
      "category": "functions",
      "explanation": "Closures are a powerful and sometimes initially confusing feature in JavaScript. A closure is created when a function is defined inside another function (nested function), and the inner function has access to the outer function's variables (lexical scope), even after the outer function has finished executing. This 'remembers' or 'closes over' the variables from its surrounding scope, hence the name 'closure'. Lexical scope means that the scope of a variable is determined by where it is written in the code, not where the function is called. Closures are essential for data privacy and encapsulation in JavaScript, as they allow you to create private variables that are only accessible through the inner function. They are also fundamental to many JavaScript patterns, including the module pattern, function factories, and maintaining state in asynchronous operations. Understanding closures is key to writing more sophisticated and efficient JavaScript code, especially in frontend development where managing state and event handlers is crucial.",
      "example": "// Basic closure example - Counter function\nfunction counterCreator() {\n  let count = 0; // Variable in the outer function's scope\n\n  return {\n    increment: function() {\n      count++; // Inner function accessing 'count' from outer scope\n      return count;\n    },\n    decrement: function() {\n      count--;\n      return count;\n    },\n    getCount: function() {\n      return count;\n    }\n  };\n}\n\nconst myCounter = counterCreator(); // myCounter now holds the returned object with closures\nconsole.log('Increment 1:', myCounter.increment()); // Output: 1\nconsole.log('Increment 2:', myCounter.increment()); // Output: 2\nconsole.log('Decrement 1:', myCounter.decrement()); // Output: 1\nconsole.log('Current Count:', myCounter.getCount());  // Output: 1\n\n// Another closure example - Function factory\nfunction multiplierFactory(factor) {\n  return function(number) { // Returns a function that 'remembers' 'factor'\n    return number * factor;\n  };\n}\n\nconst multiplyBy5 = multiplierFactory(5); // 'factor' is now 5 within multiplyBy5's closure\nconst multiplyBy10 = multiplierFactory(10); // 'factor' is now 10 within multiplyBy10's closure\n\nconsole.log('5 times 3:', multiplyBy5(3));   // Output: 15 (3 * 5)\nconsole.log('10 times 3:', multiplyBy10(3));  // Output: 30 (3 * 10)\n\n// Practical use case - Event handlers in loops\nfunction createButtonListeners() {\n  for (var i = 1; i <= 3; i++) { // Using var for demonstration (closure issue with var)\n    const button = document.createElement('button');\n    button.textContent = `Button ${i}`;\n    button.addEventListener('click', function() { // Closure over 'i'\n      alert(`This is button ${i}`); // 'i' will be 4 after loop completes due to var's scope\n    });\n    document.body.appendChild(button);\n  }\n}\n// createButtonListeners(); // Run this to see the issue with var and closures in loops (fixed with let)",
      "keyPoints": [
        "Closures are created when a function is defined inside another function and the inner function accesses variables from the outer function's scope. The inner function 'closes over' these variables.",
        "Closures maintain access to the variables from their lexical scope (the scope in which they were defined), even after the outer function has returned. This is a key characteristic of closures.",
        "Closures are commonly used for data privacy and encapsulation. By using variables within the outer function's scope, you can create private variables that are not directly accessible from outside the closure.",
        "Each closure has its own scope chain. When a function is executed, its scope chain includes its own scope, the scope of its outer function, and so on, up to the global scope.",
        "Closures are the foundation of many JavaScript design patterns, such as the module pattern, which uses closures to create modules with private state and public methods.",
        "Function factories (functions that return other functions) often rely on closures to 'remember' configuration or parameters from the outer scope, allowing for the creation of specialized functions.",
        "Be mindful of memory management when working with closures, especially in long-running applications. Closures keep variables from their outer scope in memory as long as the closure itself is reachable. In loops, using `let` instead of `var` can prevent common closure-related issues due to `let`'s block scope."
      ],
      "quiz": [
        {
          "question": "What is a closure in JavaScript?",
          "options": ["A function with no return statement", "A function that is immediately invoked", "A function that has access to its outer (lexical) scope even after the outer function has closed", "A function that can only access global variables"],
          "correctAnswer": 2
        },
        {
          "question": "What is 'lexical scope' in the context of closures?",
          "options": ["The scope determined by where a function is called", "The scope determined by where a function is defined", "Global scope", "Block scope"],
          "correctAnswer": 1
        },
        {
          "question": "Which of the following is a common use case for closures?",
          "options": ["Creating global variables", "Data encapsulation and privacy", "Replacing loops", "Simplifying synchronous code"],
          "correctAnswer": 1
        },
        {
          "question": "In the counter example (`counterCreator`), where is the `count` variable stored?",
          "options": ["In the global scope", "Inside the `increment` and `decrement` functions' scope", "In the closure created by `counterCreator`", "It's not stored, it's recalculated each time"],
          "correctAnswer": 2
        },
        {
          "question": "Why is using `let` instead of `var` important when creating closures in loops?",
          "options": ["`let` is faster than `var`", "`let` is block-scoped, creating a new closure for each iteration, while `var` is function-scoped and shares the same closure across iterations", "`let` prevents memory leaks in closures", "`var` cannot be used in loops"],
          "correctAnswer": 1
        }
      ],
      "interactiveExamples": [
        {
          "title": "Closure for Data Encapsulation",
          "code": "// Closure to create a private counter\nfunction createSecretCounter(initialValue = 0) {\n  let secretCount = initialValue; // Private variable\n\n  return {\n    increment: function() {\n      secretCount++;\n    },\n    decrement: function() {\n      secretCount--;\n    },\n    getValue: function() {\n      return secretCount;\n    }\n  };\n}\n\nconst secretCounter = createSecretCounter(100); // Initialize with 100\nsecretCounter.increment();\nsecretCounter.decrement();\n// console.log(secretCounter.secretCount); // Error - cannot access private variable directly\nconsole.log('Secret Counter Value:', secretCounter.getValue()); // Access via public method\n\n// Try to access secretCount directly - should be inaccessible due to closure"
        },
        {
          "title": "Function Factory using Closures",
          "code": "// Function factory to create custom greeting functions\nfunction greetFactory(greeting) {\n  return function(name) {\n    return `${greeting}, ${name}!`; // Closure over 'greeting'\n  };\n}\n\nconst sayHello = greetFactory('Hello'); // Create a 'Hello' greeting function\nconst sayGoodbye = greetFactory('Goodbye'); // Create a 'Goodbye' greeting function\n\nconsole.log(sayHello('Alice'));   // Output: Hello, Alice!\nconsole.log(sayGoodbye('Bob')); // Output: Goodbye, Bob!\n\n// Create more greeting functions with different greetings and names"
        }
      ]
    },
    {
      "id": "js-operators",
      "title": "Operators in JavaScript",
      "description": "Explore different types of operators in JavaScript, including arithmetic, assignment, comparison, logical, and more.",
      "difficulty": "beginner",
      "category": "fundamentals",
      "explanation": "JavaScript operators are special symbols that instruct the JavaScript engine to perform operations on operands (values and variables). They are the backbone of any JavaScript program, enabling you to perform calculations, make decisions, manipulate data, and control the flow of your application. Operators are broadly categorized based on their function: Arithmetic operators are used for mathematical computations (+, -, *, /, %, **, ++, --). Assignment operators assign values to variables (=, +=, -=, *=, /=, %=, **=). Comparison operators compare two values and return a boolean result (true or false) based on the comparison (==, ===, !=, !==, >, <, >=, <=). Logical operators perform logical AND, OR, and NOT operations on boolean values (&&, ||, !). Bitwise operators operate on the binary representation of numbers (&, |, ^, ~, <<, >>, >>>). Understanding each type of operator and their precedence is crucial for writing correct and efficient JavaScript code. For example, understanding the difference between loose equality (==) and strict equality (===) is vital to avoid unexpected type coercion issues. Also, knowing operator precedence helps in correctly interpreting complex expressions without relying solely on parentheses.",
      "example": "// Arithmetic Operators\nlet x = 10;\nlet y = 3;\nconsole.log('Addition (x + y):', x + y);       // Output: 13\nconsole.log('Subtraction (x - y):', x - y);    // Output: 7\nconsole.log('Multiplication (x * y):', x * y); // Output: 30\nconsole.log('Division (x / y):', x / y);       // Output: 3.333...\nconsole.log('Remainder (x % y):', x % y);      // Output: 1 (Modulus)\nconsole.log('Exponentiation (x ** y):', x ** y); // Output: 1000 (x to the power of y)\nconsole.log('Increment (x++):', x++);       // Output: 10 (Post-increment, x becomes 11 after this line)\nconsole.log('Decrement (--y):', --y);       // Output: 2 (Pre-decrement, y becomes 2 before this line)\n\n// Assignment Operators\nlet a = 5;\na += 5; // Equivalent to a = a + 5\nconsole.log('Assignment += (a += 5):', a);      // Output: 10\na -= 3; // Equivalent to a = a - 3\nconsole.log('Assignment -= (a -= 3):', a);      // Output: 7\na *= 2; // Equivalent to a = a * 2\nconsole.log('Assignment *= (a *= 2):', a);      // Output: 14\n\n// Comparison Operators\nlet num1 = 10;\nlet num2 = '10';\nconsole.log('Equal (==, value comparison):', num1 == num2);   // Output: true (Type coercion occurs)\nconsole.log('Strict Equal (===, value and type comparison):', num1 === num2); // Output: false (No type coercion)\nconsole.log('Not Equal (!=):', num1 != num2);   // Output: false\nconsole.log('Strict Not Equal (!==):', num1 !== num2); // Output: true\nconsole.log('Greater than (>):', num1 > 5);       // Output: true\nconsole.log('Less than (<):', num1 < 5);          // Output: false\nconsole.log('Greater than or equal to (>=):', num1 >= 10);  // Output: true\nconsole.log('Less than or equal to (<=):', num1 <= 10);     // Output: true\n\n// Logical Operators\nlet isAdult = true;\nlet isStudent = false;\nconsole.log('Logical AND (&&, isAdult && !isStudent):', isAdult && !isStudent); // Output: true (Both conditions must be true)\nconsole.log('Logical OR (||, isAdult || isStudent):', isAdult || isStudent);  // Output: true (At least one condition must be true)\nconsole.log('Logical NOT (!, !isStudent):', !isStudent);       // Output: true (Inverts the boolean value)\n\n// Ternary Operator (Conditional Operator)\nconst age = 20;\nconst canVote = age >= 18 ? 'Yes' : 'No'; // Condition ? valueIfTrue : valueIfFalse\nconsole.log('Can vote (ternary):', canVote); // Output: Yes",
      "keyPoints": [
        "Arithmetic operators are used for performing mathematical calculations. Understand the behavior of increment (++), decrement (--), and exponentiation (**) operators.",
        "Assignment operators provide shorthand for updating variable values. Compound assignment operators like `+=`, `-=`, `*=`, etc., combine an arithmetic operation with assignment.",
        "Comparison operators are essential for decision-making in programs. Differentiate clearly between loose equality (`==`) and strict equality (`===`). Prefer `===` and `!==` to avoid unexpected type coercion and ensure type and value comparison.",
        "Logical operators (`&&`, `||`, `!`) are used to combine or negate boolean expressions. Understand truth tables for AND, OR, and NOT operations.",
        "`==` checks for value equality but performs type coercion if operands are of different types, which can lead to unexpected results. `===` checks for strict equality, meaning both value and type must be the same, without type coercion.",
        "Understand operator precedence. For example, multiplication and division have higher precedence than addition and subtraction. Use parentheses `()` to explicitly control the order of operations in complex expressions.",
        "Unary operators like increment (++), decrement (--), unary plus (+), and unary minus (-) operate on a single operand.",
        "The ternary operator (`condition ? exprIfTrue : exprIfFalse`) provides a concise syntax for simple conditional assignments, acting as a shorthand for `if-else` statements.",
        "Bitwise operators, while less common in typical frontend development, are used to perform operations on the binary representations of numbers and are important in certain performance-critical or low-level contexts."
      ],
      "quiz": [
        {
          "question": "What is the difference between the `==` and `===` operators in JavaScript?",
          "options": ["`==` is for assignment, `===` is for comparison", "`==` checks value and type equality, `===` only checks value equality", "`==` checks value equality with type coercion, `===` checks strict equality without type coercion", "They are interchangeable, but `===` is newer"],
          "correctAnswer": 2
        },
        {
          "question": "Which operator is used to calculate the remainder of a division operation in JavaScript?",
          "options": ["`/`", "`%`", "`//`", "`rem`"],
          "correctAnswer": 1
        },
        {
          "question": "What is the result of `true && false`?",
          "options": ["`true`", "`false`", "`undefined`", "`null`"],
          "correctAnswer": 1
        },
        {
          "question": "What does the exponentiation operator `**` do?",
          "options": ["Calculates the square root of a number", "Raises the first operand to the power of the second operand", "Multiplies two numbers", "Divides the first operand by the second operand"],
          "correctAnswer": 1
        },
        {
          "question": "Which type of operator is `+=`?",
          "options": ["Arithmetic operator", "Assignment operator", "Comparison operator", "Logical operator"],
          "correctAnswer": 1
        }
      ],
      "interactiveExamples": [
        {
          "title": "Arithmetic and Assignment Operator Exploration",
          "code": "let num = 10;\nconsole.log('Initial num:', num);\nnum = num + 5; // Addition\nconsole.log('num + 5 (assignment):', num);\nnum -= 3;      // Subtraction assignment\nconsole.log('num -= 3:', num);\nnum *= 2;      // Multiplication assignment\nconsole.log('num *= 2:', num);\nnum %= 4;      // Modulus assignment\nconsole.log('num %= 4:', num);\nnum++;       // Increment\nconsole.log('num++:', num);\nnum--;       // Decrement\nconsole.log('num--:', num);\n\n// Experiment with different arithmetic and assignment operators"
        },
        {
          "title": "Comparison and Logical Operators in Conditionals",
          "code": "let value1 = 20;\nlet value2 = '20';\nlet value3 = 30;\n\n// Comparison operators\nconsole.log('value1 == value2:', value1 == value2);   // Value equality (coercion)\nconsole.log('value1 === value2:', value1 === value2);  // Strict equality (no coercion)\nconsole.log('value1 != value3:', value1 != value3);   // Not equal\nconsole.log('value1 !== value3:', value1 !== value3);  // Strict not equal\n\n// Logical operators in if statements\nif (value1 > 15 && value2 == 20) {\n  console.log('value1 > 15 AND value2 == 20 is true');\n}\nif (value1 < 10 || value3 > 25) {\n  console.log('value1 < 10 OR value3 > 25 is true');\n}\nif (!(value1 < 10)) {\n  console.log('NOT (value1 < 10) is true');\n}\n\n// Modify values and conditions to see different outcomes"
        }
      ]
    },
    {
      "id": "js-control-flow",
      "title": "Control Flow Statements",
      "description": "Learn about control flow statements in JavaScript, including if-else, switch, for loops, while loops, and break/continue.",
      "difficulty": "beginner",
      "category": "fundamentals",
      "explanation": "Control flow statements in JavaScript are the mechanisms that determine the order in which your code is executed. They allow you to create dynamic and responsive programs by making decisions, repeating actions, and altering the sequence of execution based on conditions. Mastering control flow is fundamental to programming in JavaScript, as it enables you to handle different scenarios, process data collections, and create complex logic. The primary control flow statements in JavaScript are: `if`, `else if`, `else` for conditional execution based on boolean expressions. `switch` for selecting one of several code blocks to execute based on the value of an expression, often more efficient than nested `if-else if` for multiple discrete choices. `for` loops for iterating a block of code a known number of times, ideal for working with arrays or ranges. `while` and `do...while` loops for repeating a block of code as long as a condition remains true. `while` checks the condition before each iteration, whereas `do...while` executes the block at least once before checking the condition. `break` to immediately exit a loop or switch statement, often used when a condition is met that makes further iterations unnecessary. `continue` to skip the rest of the current iteration of a loop and proceed to the next iteration, useful for skipping certain elements in a loop based on a condition.",
      "example": "// If-else statements - Conditional execution\nlet age = 20;\nif (age >= 18) {\n  console.log('Adult'); // Executed if age is 18 or greater\n} else {\n  console.log('Minor'); // Executed if age is less than 18\n}\n\n// If-else if-else statements - Multiple conditions\nlet score = 75;\nif (score >= 90) {\n  console.log('Grade A');\n} else if (score >= 80) {\n  console.log('Grade B');\n} else if (score >= 70) {\n  console.log('Grade C'); // Executed for scores 70-79\n} else {\n  console.log('Grade D or F'); // Executed for scores below 70\n}\n\n// Switch statement - Selecting one of many code blocks\nlet day = 'Monday';\nswitch (day) {\n  case 'Monday':\n    console.log('Start of the week');\n    break; // Exit switch after executing this case\n  case 'Friday':\n    console.log('Almost weekend');\n    break;\n  default:\n    console.log('Mid-week day'); // Default case if no other case matches\n}\n\n// For loop - Iterating a known number of times\nfor (let i = 0; i < 5; i++) {\n  console.log('For loop iteration:', i); // Iterates 5 times, i from 0 to 4\n}\n\n// While loop - Iterating while a condition is true\nlet count = 0;\nwhile (count < 3) {\n  console.log('While loop count:', count); // Iterates as long as count < 3\n  count++;\n}\n\n// Do-while loop - Execute at least once, then check condition\nlet j = 0;\ndo {\n  console.log('Do-while loop:', j); // Executes once, then checks condition\n  j++;\n} while (j < 2);\n\n// Break and continue - Altering loop flow\nfor (let k = 0; k < 5; k++) {\n  if (k === 3) {\n    break; // Exit loop immediately when k is 3\n  }\n  if (k === 1) {\n    continue; // Skip current iteration when k is 1, proceed to next\n  }\n  console.log('Loop with break/continue:', k); // Output: 0, then skip 1, then 2, then loop breaks at 3\n}",
      "keyPoints": [
        "`if`, `else if`, `else` statements provide conditional branching based on boolean conditions. Use `else if` to check multiple conditions sequentially and `else` to provide a default action if no conditions are met.",
        "`switch` statement offers an efficient way to handle multiple discrete cases based on the value of an expression. Remember to use `break` at the end of each `case` block to prevent 'fall-through' to the next case unintentionally.",
        "`for` loops are designed for definite iteration, where the number of iterations is known or can be predetermined. They consist of initialization, condition check, and increment/decrement steps, making them ideal for array traversal and count-based loops.",
        "`while` loops are used for indefinite iteration, repeating a block of code as long as a specified condition remains true. The condition is checked before each iteration, and if initially false, the loop body might not execute at all.",
        "`do...while` loops are similar to `while` loops but guarantee that the code block is executed at least once because the condition is checked after the first execution. They are useful when you need to perform an action at least once regardless of the initial condition.",
        "`break` statement is used to terminate the execution of a loop or a `switch` statement prematurely. It's commonly used to exit a loop when a certain condition is met or to prevent fall-through in `switch` cases.",
        "`continue` statement is used within loops to skip the current iteration and proceed directly to the next iteration. It's helpful for skipping processing for certain elements based on conditions within a loop.",
        "Nested control flow structures (e.g., loops inside loops, `if` statements inside loops) are common for implementing complex logic. Be mindful of readability and complexity when nesting control flow structures deeply.",
        "Choosing the appropriate control flow statement depends on the specific logic and iteration requirements of your program. Consider whether you need conditional execution, definite or indefinite iteration, and how you need to alter the flow within loops or conditional blocks."
      ],
      "quiz": [
        {
          "question": "Which control flow statement is used to execute a block of code repeatedly as long as a condition is true, and checks the condition *before* each execution?",
          "options": ["`for` loop", "`while` loop", "`do...while` loop", "`switch` statement"],
          "correctAnswer": 1
        },
        {
          "question": "What is the primary function of the `break` statement in a loop or `switch` statement?",
          "options": ["To skip to the next iteration", "To terminate the loop or `switch` statement immediately", "To pause the execution temporarily", "To continue to the next case in a `switch` statement"],
          "correctAnswer": 1
        },
        {
          "question": "Which loop type guarantees that the code block will be executed at least once, regardless of the initial condition?",
          "options": ["`for` loop", "`while` loop", "`do...while` loop", "All loop types"],
          "correctAnswer": 2
        },
        {
          "question": "When is it most appropriate to use a `switch` statement instead of multiple `if-else if` statements?",
          "options": ["When checking conditions based on ranges of values", "When you have many possible discrete values for a single expression to check against", "When conditions are complex boolean expressions", "When you need to iterate over an array"],
          "correctAnswer": 1
        },
        {
          "question": "What does the `continue` statement do within a loop?",
          "options": ["Terminates the loop", "Skips the rest of the current iteration and goes to the next iteration", "Pauses the loop execution", "Resets the loop counter"],
          "correctAnswer": 1
        }
      ],
      "interactiveExamples": [
        {
          "title": "If-Else and Switch for Decision Making",
          "code": "// If-else example: Check if a number is positive, negative, or zero\nlet numberToCheck = 5;\nif (numberToCheck > 0) {\n  console.log('Number is positive');\n} else if (numberToCheck < 0) {\n  console.log('Number is negative');\n} else {\n  console.log('Number is zero');\n}\n\n// Switch example: Determine day of the week based on a number (1-7)\nlet dayNumber = 3;\nlet dayName;\nswitch (dayNumber) {\n  case 1:\n    dayName = 'Monday';\n    break;\n  case 2:\n    dayName = 'Tuesday';\n    break;\n  case 3:\n    dayName = 'Wednesday';\n    break;\n  case 4:\n    dayName = 'Thursday';\n    break;\n  case 5:\n    dayName = 'Friday';\n    break;\n  case 6:\n    dayName = 'Saturday';\n    break;\n  case 7:\n    dayName = 'Sunday';\n    break;\n  default:\n    dayName = 'Invalid day number';\n}\nconsole.log('Day of the week:', dayName);\n\n// Change numberToCheck and dayNumber to test different conditions"
        },
        {
          "title": "Looping Constructs: For, While, Do-While",
          "code": "// For loop: Print numbers from 1 to 5\nconsole.log('For loop output:');\nfor (let i = 1; i <= 5; i++) {\n  console.log(i);\n}\n\n// While loop: Countdown from 5 to 1\nconsole.log('While loop output:');\nlet countdown = 5;\nwhile (countdown >= 1) {\n  console.log(countdown);\n  countdown--;\n}\n\n// Do-while loop: Print 'Hello' at least once, condition is initially false\nconsole.log('Do-while loop output:');\nlet condition = false;\ndo {\n  console.log('Hello from do-while');\n} while (condition);\n\n// Modify loop conditions and code blocks to explore different iteration scenarios"
        }
      ]
    },
    {
      "id": "js-arrays-basics",
      "title": "Arrays Fundamentals",
      "description": "Learn about JavaScript arrays, array creation, accessing elements, common array methods, and array iteration.",
      "difficulty": "beginner",
      "category": "data-structures",
      "explanation": "Arrays in JavaScript are ordered lists of values. They are versatile data structures that can hold elements of any data type, including primitives (numbers, strings, booleans), objects, functions, and even other arrays (creating multi-dimensional arrays). Arrays are zero-indexed, meaning the first element in an array is at index 0, the second at index 1, and so on. JavaScript arrays are dynamic in size, automatically adjusting as you add or remove elements, unlike arrays in some other languages that have a fixed size. Arrays are fundamental for storing and manipulating collections of data in JavaScript. You can create arrays using array literals `[]` or the `Array()` constructor, although array literals are the more common and recommended approach. Accessing elements is done using bracket notation `array[index]`. JavaScript provides a rich set of built-in methods for array manipulation, including adding and removing elements (`push()`, `pop()`, `shift()`, `unshift()`), extracting portions of arrays (`slice()`, `splice()`), combining arrays (`concat()`), searching for elements (`indexOf()`, `includes()`), and iterating over arrays (`for` loops, `for...of` loops, `forEach()`, `map()`, `filter()`, `reduce()`). Understanding arrays and their methods is crucial for efficiently managing and processing lists of data in JavaScript applications.",
      "example": "// Array creation - Using array literal (recommended)\nconst numbers = [1, 2, 3, 4, 5]; // Array of numbers\nconst fruits = ['apple', 'banana', 'orange']; // Array of strings\nconst mixedArray = [1, 'hello', true, null, { key: 'value' }]; // Array with mixed data types\n\n// Array creation - Using Array constructor (less common)\nconst colors = new Array('red', 'green', 'blue');\n// Note: Avoid using 'new Array(number)' if you intend to create an array with initial elements, as it behaves differently for single number arguments.\n\n// Accessing elements - Using bracket notation (zero-indexed)\nconsole.log('First number:', numbers[0]);    // Output: 1\nconsole.log('Second fruit:', fruits[1]);     // Output: banana\nconsole.log('Array length:', numbers.length); // Output: 5 (number of elements)\nconsole.log('Last element of numbers:', numbers[numbers.length - 1]); // Output: 5 (accessing last element)\n\n// Modifying elements - Arrays are mutable\nnumbers[2] = 10; // Change element at index 2\nconsole.log('Modified numbers:', numbers); // Output: [1, 2, 10, 4, 5]\n\n// Adding elements\nnumbers.push(6); // Add to the end of the array\nconsole.log('Numbers after push(6):', numbers); // Output: [1, 2, 10, 4, 5, 6]\nnumbers.unshift(0); // Add to the beginning of the array\nconsole.log('Numbers after unshift(0):', numbers); // Output: [0, 1, 2, 10, 4, 5, 6]\n\n// Removing elements\nnumbers.pop(); // Remove the last element from the array\nconsole.log('Numbers after pop():', numbers); // Output: [0, 1, 2, 10, 4, 5]\nnumbers.shift(); // Remove the first element from the array\nconsole.log('Numbers after shift():', numbers); // Output: [1, 2, 10, 4, 5]\n\n// Slicing and splicing - Extracting and modifying array portions\nconst slicedArray = numbers.slice(1, 3); // Extract elements from index 1 up to (but not including) 3\nconsole.log('Sliced array (slice(1, 3)):', slicedArray); // Output: [2, 10]\nnumbers.splice(1, 2, 7, 8); // Remove 2 elements starting from index 1, and insert 7, 8\nconsole.log('Numbers after splice(1, 2, 7, 8):', numbers); // Output: [1, 7, 8, 4, 5]\n\n// Iterating through array - Using for loop and forEach method\nconsole.log('Iterating with for loop:');\nfor (let i = 0; i < numbers.length; i++) {\n  console.log('Element at index', i, ':', numbers[i]);\n}\n\nconsole.log('Iterating with forEach:');\nnumbers.forEach(function(number, index) { // forEach method with callback function\n  console.log('Element at index', index, ':', number);\n});",
      "keyPoints": [
        "Arrays are ordered collections of values, indexed starting from 0, and dynamically resizable. They are a fundamental data structure for managing lists of items in JavaScript.",
        "Arrays can store elements of any JavaScript data type, allowing for flexible data organization. They are mutable, meaning their contents can be changed after creation.",
        "Array literals `[]` are the preferred and most common way to create arrays due to their simplicity and readability. Avoid using the `Array` constructor unnecessarily, especially with single number arguments.",
        "Access array elements using bracket notation `array[index]`. The `length` property provides the number of elements in an array, useful for accessing the last element at `array[array.length - 1]`.",
        "`push()` adds elements to the end of an array, `pop()` removes and returns the last element, `unshift()` adds elements to the beginning, `shift()` removes and returns the first element. These methods modify the original array.",
        "`slice(start, end)` extracts a portion of an array and returns a new array without modifying the original array. `splice(start, deleteCount, ...items)` changes the content of an array by removing or replacing existing elements and/or adding new elements in place.",
        "`concat()` merges two or more arrays and returns a new array. `join(separator)` converts all elements of an array into a string, separated by the specified separator. `indexOf(element)` finds the first index of a specified element, and `includes(element)` checks if an array contains a certain element, returning a boolean.",
        "Common array iteration methods include `for` loop, `for...of` loop (for iterating over values), `forEach()`, `map()`, `filter()`, `reduce()`. Choose the appropriate method based on the task: simple iteration (`forEach`, `for...of`), transforming elements (`map`), filtering elements (`filter`), or aggregating values (`reduce`).",
        "Arrays in JavaScript are technically objects, but they have special behavior and optimized methods for handling ordered collections. They are a cornerstone of data manipulation in JavaScript, especially in frontend development for managing lists of items, processing data from APIs, and handling user inputs."
      ],
      "quiz": [
        {
          "question": "What is the index of the first element in a JavaScript array?",
          "options": ["1", "0", "-1", "Depends on the array"],
          "correctAnswer": 1
        },
        {
          "question": "Which array method adds a new element to the *end* of an array and also returns the new length of the array?",
          "options": ["`push()`", "`pop()`", "`shift()`", "`unshift()`"],
          "correctAnswer": 0
        },
        {
          "question": "What does the `slice()` method do to the original array it is called upon?",
          "options": ["Modifies the original array by removing elements", "Returns a new array containing a portion of the original array", "Removes elements from the original array and returns them", "Returns the length of the original array"],
          "correctAnswer": 1
        },
        {
          "question": "Which of the following is NOT a valid method for iterating over elements in a JavaScript array?",
          "options": ["`for` loop", "`while` loop", "`forEach()` method", "`map()` method"],
          "correctAnswer": 1
        },
        {
          "question": "Are JavaScript arrays fixed in size or dynamic?",
          "options": ["Fixed size", "Dynamic size", "Size is defined at creation and cannot be changed", "Depends on the browser"],
          "correctAnswer": 1
        }
      ],
      "interactiveExamples": [
        {
          "title": "Array Manipulation - Adding and Removing Elements",
          "code": "const colors = ['red', 'green', 'blue'];\nconsole.log('Initial array:', colors);\n\n// Adding elements\ncolors.push('yellow');\nconsole.log('After push('yellow'):', colors);\ncolors.unshift('purple');\nconsole.log('After unshift('purple'):', colors);\n\n// Removing elements\ncolors.pop();\nconsole.log('After pop():', colors);\ncolors.shift();\nconsole.log('After shift():', colors);\n\n// Experiment with push, pop, unshift, shift to see how arrays change"
        },
        {
          "title": "Array Slicing and Splicing - Extracting and Modifying Portions",
          "code": "const numbers = [10, 20, 30, 40, 50];\nconsole.log('Original array:', numbers);\n\n// Slicing - Extract a portion\nconst slicedPart = numbers.slice(1, 4); // Indices 1, 2, 3\nconsole.log('Sliced array (slice(1, 4)):', slicedPart);\nconsole.log('Original array after slice:', numbers); // Original array unchanged\n\n// Splicing - Modify original array by removing and inserting\nconst removedElements = numbers.splice(2, 2, 'a', 'b'); // Remove 2 from index 2, insert 'a', 'b'\nconsole.log('Array after splice(2, 2, 'a', 'b'):', numbers);\nconsole.log('Removed elements by splice:', removedElements);\n\n// Experiment with different slice and splice parameters to understand their effects"
        }
      ]
    },
    {
      "id": "js-strings-basics",
      "title": "Strings Fundamentals",
      "description": "Explore JavaScript strings, string creation, immutability, string methods, template literals, and string manipulation.",
      "difficulty": "beginner",
      "category": "data-types",
      "explanation": "Strings in JavaScript are sequences of characters used to represent text. They are a primitive data type and are immutable, meaning once a string is created, its value cannot be changed. Any operation that appears to modify a string actually creates a new string in memory. Strings can be created using single quotes (`'`), double quotes (`\"`), or backticks (template literals ``). Single and double quotes are largely interchangeable, but it's common to choose one style and be consistent within a project. Template literals, introduced in ES6, offer enhanced capabilities, including string interpolation (embedding expressions inside strings) and multiline strings. JavaScript provides a rich set of built-in methods for string manipulation, allowing you to perform operations like accessing individual characters, searching for substrings, replacing parts of strings, extracting substrings, changing case (uppercase/lowercase), trimming whitespace, and splitting strings into arrays. Understanding strings and their methods is essential for working with text data in JavaScript, which is a common task in web development for handling user input, displaying text content, and processing data from APIs.",
      "example": "// String creation - Using single quotes, double quotes, and template literals\nconst singleQuoteString = 'Hello';\nconst doubleQuoteString = \"World\";\nconst templateLiteralString = `Hello, World!`;\n\nconsole.log('Single quote string:', singleQuoteString);\nconsole.log('Double quote string:', doubleQuoteString);\nconsole.log('Template literal string:', templateLiteralString);\n\n// String immutability - Original string remains unchanged after methods\nlet message = 'JavaScript';\nconsole.log('Original message:', message); // Output: JavaScript\nmessage.toUpperCase(); // This method call does not modify 'message'\nconsole.log('Message after toUpperCase() (still original):', message); // Output: JavaScript\nmessage = message.toUpperCase(); // Assign the result of toUpperCase() back to 'message'\nconsole.log('Uppercase message (after reassignment):', message); // Output: JAVASCRIPT\n\n// Common String methods\nconst text = '  Example String  ';\nconsole.log('Length of text:', text.length);         // Output: 18 (includes spaces)\nconsole.log('Character at index 0 (charAt(0)):', text.charAt(0));   // Output: ' ' (space)\nconsole.log('Index of 'E' (indexOf('E')):', text.indexOf('E')); // Output: 2\nconsole.log('Substring from index 2 to 9 (slice(2, 9)):', text.slice(2, 9));   // Output: 'Example'\nconsole.log('Substring from index 2 to 9 (substring(2, 9)):', text.substring(2, 9)); // Output: 'Example'\nconsole.log('Uppercase version (toUpperCase()):', text.toUpperCase()); // Output: '  EXAMPLE STRING  '\nconsole.log('Lowercase version (toLowerCase()):', text.toLowerCase()); // Output: '  example string  '\nconsole.log('String after trimming whitespace (trim()):', text.trim());           // Output: 'Example String' (removes leading/trailing spaces)\nconsole.log('Split string into array by space (split(' ')):', text.split(' '));     // Output: ['', '', 'Example', 'String', '', '']\n\n// Template literals for string interpolation and multiline strings\nconst name = 'Alice';\nconst age = 30;\nconst greeting = `Hello, ${name}! You are ${age} years old.`; // Interpolation\nconsole.log('Greeting using template literal:', greeting); // Output: Hello, Alice! You are 30 years old.\n\nconst multiline = `This is a\nmultiline string\nusing template literals.`; // Multiline string\nconsole.log('Multiline string using template literal:\n', multiline);",
      "keyPoints": [
        "Strings are sequences of characters and a primitive data type in JavaScript, used for representing textual data.",
        "Strings are immutable in JavaScript. Operations that appear to modify a string actually create and return a new string, leaving the original string unchanged.",
        "Strings can be created using single quotes (`'`), double quotes (`\"`), or template literals (backticks ``). Template literals offer additional features like interpolation and multiline support.",
        "Template literals allow for string interpolation using `${expression}`, embedding JavaScript expressions directly into strings, and for creating multiline strings without special characters.",
        "`length` property returns the number of characters in a string. String indices are zero-based, starting from 0 for the first character.",
        "`charAt(index)` method returns the character at a specified index. `indexOf(substring)` finds the index of the first occurrence of a substring within a string.",
        "`slice(start, end)` and `substring(start, end)` methods extract a portion of a string and return it as a new string. `slice` can also handle negative indices, counting from the end of the string.",
        "`toUpperCase()` and `toLowerCase()` methods convert a string to uppercase or lowercase, respectively, returning new strings.",
        "`trim()` method removes whitespace characters from both ends of a string, returning a new trimmed string.",
        "`split(separator)` method splits a string into an array of substrings, using a specified separator string to determine where to make each split.",
        "Strings are fundamental for displaying text, processing user input, working with text-based data formats, and many other common tasks in web development."
      ],
      "quiz": [
        {
          "question": "Are JavaScript strings mutable or immutable?",
          "options": ["Mutable", "Immutable", "Mutable under certain conditions", "Depends on the declaration type"],
          "correctAnswer": 1
        },
        {
          "question": "Which string method is used to remove whitespace from both ends of a string?",
          "options": ["`trim()`", "`slice()`", "`substring()`", "`replace()`"],
          "correctAnswer": 0
        },
        {
          "question": "What is the primary advantage of using template literals over single or double quoted strings in JavaScript?",
          "options": ["Template literals are more performant", "Template literals are automatically escaped to prevent security issues", "Template literals allow for string interpolation and multiline strings", "Template literals are only supported in modern browsers"],
          "correctAnswer": 2
        },
        {
          "question": "If you have a string `str = 'example'`, what will `str.slice(1, 4)` return?",
          "options": ["`'xamp'`", "`'xampl'`", "`'ample'`", "`'exam'`"],
          "correctAnswer": 3
        },
        {
          "question": "Which method would you use to convert a string to an array of substrings, separated by commas?",
          "options": ["`join(',')`", "`split(',')`", "`toArray(',')`", "`substring(',')`"],
          "correctAnswer": 1
        }
      ],
      "interactiveExamples": [
        {
          "title": "String Method Exploration - Manipulation and Extraction",
          "code": "let sampleText = 'JavaScript is fun!';\nconsole.log('Original text:', sampleText);\nconsole.log('Length:', sampleText.length);\nconsole.log('Substring (0, 10) using substring():', sampleText.substring(0, 10));\nconsole.log('Substring from index 5 to end using slice(5):', sampleText.slice(5)); // Slice from index 5 to the end\nconsole.log('Replace 'fun' with 'awesome' using replace():', sampleText.replace('fun', 'awesome'));\nconsole.log('Uppercase version using toUpperCase():', sampleText.toUpperCase());\nconsole.log('Lowercase version using toLowerCase():', sampleText.toLowerCase());\n\n// Original string remains unchanged\nconsole.log('Original text after methods:', sampleText);\n\n// Experiment with different string methods and parameters"
        },
        {
          "title": "Template Literals in Practice - Dynamic String Generation",
          "code": "const productName = 'Laptop';\nconst productPrice = 1200;\nconst discountPercentage = 10;\n\n// Using template literals for dynamic string creation\nconst productDescription = `\n  Product Name: ${productName}\n  Price: $${productPrice}\n  Discount: ${discountPercentage}%\n  Final Price: $${productPrice * (1 - discountPercentage / 100)}\n`;\nconsole.log('Product Description using template literal:\n', productDescription);\n\n// Experiment with different expressions and variables inside template literals"
        }
      ]
    },
    {
      "id": "js-numbers-math",
      "title": "Numbers and Math",
      "description": "Learn about numbers in JavaScript, number types, numeric operators, the Math object, and common math functions.",
      "difficulty": "beginner",
      "category": "data-types",
      "explanation": "JavaScript has a single number type, which is used for both integers and floating-point numbers. Internally, JavaScript numbers are represented as double-precision 64-bit floating point format (IEEE 754), which allows for a wide range of values and precision. In addition to standard numeric values, JavaScript also includes special numeric values like `NaN` (Not-a-Number), `Infinity`, and `-Infinity`, which represent results of operations that are not valid numbers or exceed the representable range. JavaScript supports standard arithmetic operators (+, -, *, /, %, **) for basic mathematical operations, as well as the `Math` object, which is a built-in object that provides a collection of mathematical functions and constants. The `Math` object is static, meaning you can use its methods and properties directly without creating an instance of `Math`. It includes functions for rounding, ceiling, flooring, absolute value, exponentiation, square root, random number generation, trigonometric functions, and constants like PI and E. Understanding numbers and the `Math` object is crucial for performing calculations, handling numeric data, and implementing mathematical logic in JavaScript applications, from simple arithmetic to complex scientific computations.",
      "example": "// Number types in JavaScript\nlet integerNumber = 10; // Integer\nlet floatNumber = 3.14; // Floating-point number\nlet scientificNotation = 1.23e5; // Scientific notation (1.23 * 10^5 = 123000)\nlet negativeNumber = -5; // Negative number\n\nconsole.log('Integer number:', integerNumber, ', Type:', typeof integerNumber); // Output: number\nconsole.log('Float number:', floatNumber, ', Type:', typeof floatNumber);     // Output: number\nconsole.log('Scientific notation:', scientificNotation, ', Type:', typeof scientificNotation); // Output: number\nconsole.log('Negative number:', negativeNumber, ', Type:', typeof negativeNumber);   // Output: number\n\n// Special numeric values - NaN, Infinity, -Infinity\nconsole.log('NaN (Not-a-Number):', NaN);             // Output: NaN (result of invalid numeric operations)\nconsole.log('Infinity:', Infinity);     // Output: Infinity (result of division by zero, or exceeding max number)\nconsole.log('-Infinity:', -Infinity);   // Output: -Infinity\nconsole.log('Is NaN (isNaN('hello')):', isNaN('hello'));    // Output: true (checks if value is NaN)\nconsole.log('Is Finite (isFinite(1000)):', isFinite(1000)); // Output: true (checks if value is a finite number)\nconsole.log('Is Finite (isFinite(Infinity)):', isFinite(Infinity)); // Output: false\n\n// Arithmetic operations\nlet num1 = 20;\nlet num2 = 5;\nconsole.log('Addition (num1 + num2):', num1 + num2);       // Output: 25\nconsole.log('Subtraction (num1 - num2):', num1 - num2);    // Output: 15\nconsole.log('Multiplication (num1 * num2):', num1 * num2); // Output: 100\nconsole.log('Division (num1 / num2):', num1 / num2);       // Output: 4\nconsole.log('Modulus (num1 % num2):', num1 % num2);        // Output: 0 (remainder of division)\nconsole.log('Exponentiation (num2 ** 3):', num2 ** 3);     // Output: 125 (num2 to the power of 3)\n\n// Math object methods and constants\nconsole.log('Math.PI:', Math.PI);          // Output: 3.14159... (constant for Pi)\nconsole.log('Math.round(4.6):', Math.round(4.6)); // Output: 5 (rounds to nearest integer)\nconsole.log('Math.ceil(4.2):', Math.ceil(4.2));   // Output: 5 (rounds up to nearest integer)\nconsole.log('Math.floor(4.8):', Math.floor(4.8)); // Output: 4 (rounds down to nearest integer)\nconsole.log('Math.abs(-5):', Math.abs(-5));     // Output: 5 (absolute value, positive value)\nconsole.log('Math.pow(2, 3):', Math.pow(2, 3));    // Output: 8 (base to the power of exponent)\nconsole.log('Math.sqrt(25):', Math.sqrt(25));   // Output: 5 (square root)\nconsole.log('Math.random():', Math.random());   // Output: Random float between 0 (inclusive) and 1 (exclusive)\nconsole.log('Math.max(1, 5, 2):', Math.max(1, 5, 2)); // Output: 5 (returns the largest of given numbers)\nconsole.log('Math.min(1, 5, 2):', Math.min(1, 5, 2)); // Output: 1 (returns the smallest of given numbers)",
      "keyPoints": [
        "JavaScript has a single `number` data type for both integers and floating-point numbers, represented internally as double-precision 64-bit floating point numbers (IEEE 754).",
        "Special numeric values include `NaN` (Not-a-Number), `Infinity`, and `-Infinity`. Use `isNaN()` to check for `NaN` and `isFinite()` to determine if a value is a finite number.",
        "Standard arithmetic operators in JavaScript are: addition (+), subtraction (-), multiplication (*), division (/), modulus (%) for remainder, and exponentiation (**) for raising to a power. Increment (++) and decrement (--) are also arithmetic operators.",
        "The `Math` object is a built-in static object that provides a wide range of mathematical functions and constants. You access its properties and methods directly using `Math.property` or `Math.method()`, without needing to create an instance.",
        "Commonly used `Math` methods include: `Math.round()`, `Math.ceil()`, `Math.floor()` for rounding numbers; `Math.abs()` for absolute value; `Math.pow()` for exponentiation; `Math.sqrt()` for square root; `Math.random()` for generating pseudo-random numbers; `Math.max()` and `Math.min()` for finding maximum and minimum values.",
        "`Math.random()` generates a pseudo-random floating-point number in the range [0, 1) (inclusive of 0, but not 1). To get random numbers in other ranges, you need to scale and shift the result.",
        "`parseInt()` and `parseFloat()` functions are used to convert strings to numbers. `parseInt()` parses a string and returns an integer, while `parseFloat()` parses a string and returns a floating-point number. Be aware of `parseInt`'s behavior with non-numeric strings and leading zeros.",
        "Number methods like `toFixed(digits)` and `toPrecision(precision)` are used for formatting numbers as strings, controlling the number of decimal places or total significant digits.",
        "JavaScript numbers can accurately represent integers up to `Number.MAX_SAFE_INTEGER`. For working with integers larger than this, consider using `BigInt` (introduced in ES2020) for arbitrary-precision integers."
      ],
      "quiz": [
        {
          "question": "What is the primary data type for numbers in JavaScript?",
          "options": ["`integer`", "`float`", "`number`", "`numeric`"],
          "correctAnswer": 2
        },
        {
          "question": "Which `Math` method rounds a number to the nearest integer?",
          "options": ["`Math.ceil()`", "`Math.floor()`", "`Math.round()`", "`Math.abs()`"],
          "correctAnswer": 2
        },
        {
          "question": "What range of values does `Math.random()` return?",
          "options": ["Integers from 0 to 1", "Floating-point numbers from 0 to 1 (inclusive)", "Floating-point numbers from 0 (inclusive) to 1 (exclusive)", "Integers from 1 to 100"],
          "correctAnswer": 2
        },
        {
          "question": "What special numeric value does JavaScript use to represent the result of an invalid numeric operation (e.g., dividing zero by zero)?",
          "options": ["`Infinity`", "`-Infinity`", "`null`", "`NaN`"],
          "correctAnswer": 3
        },
        {
          "question": "Which function is used to check if a value is *not* a number (NaN)?",
          "options": ["`isNumber()`", "`isNaN()`", "`isNotNumber()`", "`checkNaN()`"],
          "correctAnswer": 1
        }
      ],
      "interactiveExamples": [
        {
          "title": "Exploring Math Object Methods - Rounding and Absolute Value",
          "code": "let numberValue = 4.567;\nconsole.log('Original number:', numberValue);\nconsole.log('Math.round():', Math.round(numberValue)); // Round to nearest integer\nconsole.log('Math.ceil():', Math.ceil(numberValue));   // Round up to nearest integer\nconsole.log('Math.floor():', Math.floor(numberValue)); // Round down to nearest integer\nconsole.log('Math.abs(-numberValue):', Math.abs(-numberValue)); // Absolute value (positive)\n\nlet anotherNumber = -7.89;\nconsole.log('Math.ceil() of negative number:', Math.ceil(anotherNumber)); // Ceil of negative\nconsole.log('Math.floor() of negative number:', Math.floor(anotherNumber)); // Floor of negative\n\n// Experiment with different Math.round, Math.ceil, Math.floor values"
        },
        {
          "title": "Number Conversion and Formatting - String to Number and Number to String",
          "code": "// String to number conversion using parseInt and parseFloat\nlet stringNumberInt = '123';\nlet stringNumberFloat = '123.45';\nlet parsedInt = parseInt(stringNumberInt); // Parse as integer\nlet parseFloatNum = parseFloat(stringNumberFloat); // Parse as float\nconsole.log('parseInt(' + stringNumberInt + '):', parsedInt, ', Type:', typeof parsedInt);\nconsole.log('parseFloat(' + stringNumberFloat + '):', parseFloatNum, ', Type:', typeof parseFloatNum);\n\n// Number formatting using toFixed and toPrecision\nlet numToFormat = 1234.5678;\nconsole.log('toFixed(2):', numToFormat.toFixed(2));      // Format to 2 decimal places (string)\nconsole.log('toPrecision(4):', numToFormat.toPrecision(4)); // Format to 4 significant digits (string)\nconsole.log('toString():', numToFormat.toString());      // Convert number to string\n\n// Experiment with different string inputs and formatting options"
        }
      ]
    },
    {
      "id": "js-booleans-conditionals",
      "title": "Booleans and Conditionals",
      "description": "Understand boolean data type, logical operations, truthy and falsy values, and conditional statements in JavaScript.",
      "difficulty": "beginner",
      "category": "fundamentals",
      "explanation": "Booleans are a fundamental data type in JavaScript representing logical values: `true` or `false`. They are essential for decision-making and controlling program flow. Boolean values are often the result of comparison operations (e.g., `x > y`, `a === b`) or logical operations. JavaScript provides logical operators (`&&` - AND, `||` - OR, `!` - NOT) to combine or negate boolean values, allowing for complex conditional logic. An important concept in JavaScript is truthy and falsy values. Every value in JavaScript inherently evaluates to either truthy or falsy when used in a boolean context (like in an `if` condition). Falsy values are `false`, `0`, `''` (empty string), `null`, `undefined`, and `NaN`. All other values are considered truthy, including non-empty strings, any number other than 0, objects, and arrays. Conditional statements (`if`, `else if`, `else`, ternary operator) use boolean expressions to control the flow of execution based on whether a condition evaluates to `true` or `false`. Mastering booleans, truthy/falsy values, and conditional statements is crucial for creating dynamic, responsive, and logic-driven JavaScript code.",
      "example": "// Boolean values - true and false literals\nlet isTrue = true;\nlet isFalse = false;\n\nconsole.log('Boolean true:', isTrue, ', Type:', typeof isTrue);   // Output: true, boolean\nconsole.log('Boolean false:', isFalse, ', Type:', typeof isFalse); // Output: false, boolean\n\n// Comparison operators resulting in boolean values\nlet num1 = 10;\nlet num2 = 5;\nconsole.log('num1 > num2:', num1 > num2);    // Output: true (10 is greater than 5)\nconsole.log('num1 === num2:', num1 === num2); // Output: false (10 is not strictly equal to 5)\nconsole.log('num1 <= num2:', num1 <= num2);    // Output: false (10 is not less than or equal to 5)\n\n// Logical operators - AND (&&), OR (||), NOT (!)\nlet condition1 = true;\nlet condition2 = false;\nconsole.log('condition1 && condition2:', condition1 && condition2); // Output: false (AND - both must be true)\nconsole.log('condition1 || condition2:', condition1 || condition2); // Output: true (OR - at least one must be true)\nconsole.log('!condition1:', !condition1);         // Output: false (NOT - inverts the boolean value)\n\n// Truthy and falsy values - Implicit boolean conversion\nconsole.log('Boolean of 0:', Boolean(0));         // Output: false (falsy)\nconsole.log('Boolean of '':', Boolean(''));        // Output: false (falsy - empty string)\nconsole.log('Boolean of null:', Boolean(null));       // Output: false (falsy)\nconsole.log('Boolean of undefined:', Boolean(undefined)); // Output: false (falsy)\nconsole.log('Boolean of NaN:', Boolean(NaN));        // Output: false (falsy)\nconsole.log('Boolean of 1:', Boolean(1));         // Output: true (truthy - non-zero number)\nconsole.log('Boolean of 'hello':', Boolean('hello'));   // Output: true (truthy - non-empty string)\nconsole.log('Boolean of {}:', Boolean({}));        // Output: true (truthy - object)\nconsole.log('Boolean of []:', Boolean([]));        // Output: true (truthy - array)\n\n// Conditional statements - if, else if, else, ternary operator\nlet age = 15;\nif (age >= 18) {\n  console.log('You are an adult.');\n} else {\n  console.log('You are a minor.'); // Executed if age < 18\n}\n\nlet isLoggedIn = true;\nlet message = isLoggedIn ? 'Welcome back!' : 'Please log in.'; // Ternary operator: condition ? valueIfTrue : valueIfFalse\nconsole.log('Conditional message:', message); // Output: Welcome back! (if isLoggedIn is true)",
      "keyPoints": [
        "Boolean data type in JavaScript has only two values: `true` and `false`. They are used to represent logical states and are the result of comparisons and logical operations.",
        "Boolean values are often produced by comparison operators (>, <, >=, <=, ==, ===, !=, !==) and logical operators (&&, ||, !).",
        "Logical operators are `&&` (AND - returns true if both operands are true), `||` (OR - returns true if at least one operand is true), and `!` (NOT - inverts the boolean value of its operand).",
        "Truthy values are values that evaluate to `true` in a boolean context. Falsy values are those that evaluate to `false`. Understanding truthy and falsy values is crucial for conditional logic in JavaScript.",
        "The six falsy values in JavaScript are: `false`, `0`, `''` (empty string), `null`, `undefined`, and `NaN`. Every other value is truthy, including objects, arrays, non-empty strings, and non-zero numbers.",
        "Conditional statements (`if`, `else if`, `else`) allow you to execute different blocks of code based on boolean conditions. `if` executes a block if the condition is truthy. `else if` provides additional conditions to check if the preceding `if` or `else if` conditions are falsy. `else` provides a default block if no preceding conditions are truthy.",
        "The ternary operator `condition ? exprIfTrue : exprIfFalse` is a concise shorthand for a simple `if-else` statement. It evaluates a condition and returns one of two expressions based on whether the condition is truthy or falsy.",
        "Boolean logic and conditional statements are fundamental for decision-making, branching, and controlling the flow of execution in JavaScript programs. They are used extensively in all types of JavaScript applications, from frontend interactions to backend logic.",
        "Being able to effectively use booleans and conditionals is essential for writing dynamic and responsive JavaScript code that can handle different inputs and scenarios."
      ],
      "quiz": [
        {
          "question": "Which of the following is NOT considered a falsy value in JavaScript?",
          "options": ["`0`", "`''`", "`null`", "`'false'` (string 'false')"],
          "correctAnswer": 3
        },
        {
          "question": "What is the result of the logical OR operation: `true || false`?",
          "options": ["`true`", "`false`", "`undefined`", "`null`"],
          "correctAnswer": 0
        },
        {
          "question": "Which operator is a shorthand for a simple `if-else` statement in JavaScript?",
          "options": ["`if-else` statement", "`switch` statement", "Ternary operator (`?:`)", "Logical AND operator (`&&`)"],
          "correctAnswer": 2
        },
        {
          "question": "If a variable `value` is assigned `null`, what will `Boolean(value)` evaluate to?",
          "options": ["`true`", "`false`", "`undefined`", "It will throw an error"],
          "correctAnswer": 1
        },
        {
          "question": "Which statement allows you to execute one block of code if a condition is true and another block of code if the condition is false?",
          "options": ["`for` loop", "`switch` statement", "`if-else` statement", "`while` loop"],
          "correctAnswer": 2
        }
      ],
      "interactiveExamples": [
        {
          "title": "Truthy and Falsy Values - Experiment and Observe",
          "code": "// Explore truthy and falsy values using Boolean() constructor\nconsole.log('Boolean(0):', Boolean(0));\nconsole.log('Boolean(1):', Boolean(1));\nconsole.log('Boolean(''):', Boolean(''));\nconsole.log('Boolean('hello'):', Boolean('hello'));\nconsole.log('Boolean(null):', Boolean(null));\nconsole.log('Boolean(undefined):', Boolean(undefined));\nconsole.log('Boolean(NaN):', Boolean(NaN));\nconsole.log('Boolean([]):', Boolean([])); // Empty array is truthy\nconsole.log('Boolean({}):', Boolean({})); // Empty object is truthy\n\n// Try different values and observe the boolean output - understand truthy/falsy concept"
        },
        {
          "title": "Conditional Statements in Action - If-Else and Ternary Operator",
          "code": "// If-else example based on temperature\nlet currentTemperature = 20;\nif (currentTemperature >= 25) {\n  console.log('It's hot!');\n} else if (currentTemperature >= 15) {\n  console.log('It's warm.');\n} else {\n  console.log('It's cool.');\n}\n\n// Ternary operator example for even/odd check\nlet numberToCheck = 7;\nlet resultMessage = numberToCheck % 2 === 0 ? `${numberToCheck} is even.` : `${numberToCheck} is odd.`;\nconsole.log(resultMessage);\n\nlet userRole = 'admin';\nlet accessLevel = userRole === 'admin' ? 'Full Access' : 'Limited Access';\nconsole.log('Access Level:', accessLevel);\n\n// Modify temperature, numberToCheck, and userRole to see different conditional outputs"
        }
      ]
    },
    {
      "id": "js-null-undefined",
      "title": "Null and Undefined",
      "description": "Distinguish between `null` and `undefined` in JavaScript, understand their use cases and differences.",
      "difficulty": "beginner",
      "category": "data-types",
      "explanation": "`null` and `undefined` are two primitive values in JavaScript that represent the absence of a value, but they are used in distinct contexts and have subtle differences. `undefined` is typically JavaScript's way of saying 'value is not assigned yet'. It is the default value of a variable that has been declared but not initialized (assigned a value), or when a function does not explicitly return a value. It's also returned when you try to access a non-existent property of an object. In essence, `undefined` is often system-level and automatic, indicating something is missing or not yet available. `null`, on the other hand, is an assignment value. It represents the intentional absence of an object value. It must be explicitly assigned by the programmer to indicate that a variable or object property should intentionally have no value or object reference. While both represent 'no value', the key distinction is that `undefined` is often encountered due to the state of variables or properties by default, whereas `null` is a deliberate action by the programmer to signify 'no value'. Understanding their nuances is important for writing correct and debugging JavaScript code, especially when dealing with variables, function returns, and object properties.",
      "example": "// Undefined examples - Default value, no return, non-existent property\nlet myVariable; // Declared but not assigned a value\nconsole.log('myVariable:', myVariable, ', Type:', typeof myVariable);         // Output: undefined, undefined\n\nfunction noReturnValue() {\n  // Function with no explicit return statement\n}\nconsole.log('noReturnValue():', noReturnValue(), ', Type:', typeof noReturnValue());     // Output: undefined, undefined\n\nconst myObject = { name: 'Example' };\nconsole.log('Non-existent property (myObject.age):', myObject.age, ', Type:', typeof myObject.age); // Output: undefined, undefined\n\n// Null examples - Explicit assignment of null\nlet data = null; // Explicitly assigning null to a variable\nconsole.log('data:', data, ', Type:', typeof data);               // Output: null, object (Note: typeof null is a historical bug, should logically be 'null')\n\nfunction returnNull() {\n  return null; // Function explicitly returning null\n}\nconsole.log('returnNull():', returnNull(), ', Type:', typeof returnNull());       // Output: null, object\n\n// Checking for null and undefined - Using strict equality (===)\nlet valueToCheck;\nif (valueToCheck === undefined) {\n  console.log('valueToCheck is strictly undefined');\n}\n\nlet anotherValue = null;\nif (anotherValue === null) {\n  console.log('anotherValue is strictly null');\n}\n\n// Loose vs Strict equality - == vs ===\nconsole.log('null == undefined:', null == undefined);   // Output: true (loose equality considers them equal)\nconsole.log('null === undefined:', null === undefined);  // Output: false (strict equality - different types)\n\n// Common use cases - Initialization and intentional no value\n// Initialize a variable that might not get a value immediately, or to indicate absence initially\nlet userDetails = undefined; // Or simply: let userDetails;\n// Indicate that a variable should intentionally have no value, or reset a value to 'nothing'\nlet resetValue = null;",
      "keyPoints": [
        "`undefined` is the default value assigned by JavaScript to variables that are declared but not initialized, functions that do not return a value, and when accessing non-existent object properties. It indicates a system-level absence of value.",
        "`null` is an assignment value that represents the intentional absence of an object value. It must be explicitly set by the programmer to indicate that a variable should deliberately have no value.",
        "`typeof undefined` correctly returns 'undefined', while `typeof null` returns 'object'. This is a historical quirk in JavaScript; logically, `null` should have its own type 'null'.",
        "`undefined` is often system-generated, indicating that a variable or property is missing or uninitialized. `null` is programmer-assigned, signaling a deliberate non-value or absence of an object.",
        "In boolean contexts, both `null` and `undefined` are falsy values, meaning they will evaluate to `false` in conditions.",
        "Loose equality (`==`) in JavaScript considers `null` and `undefined` to be equal due to type coercion, whereas strict equality (`===`) correctly distinguishes between them as different types and values.",
        "For specific checks of `null` or `undefined`, use strict equality (`=== null` or `=== undefined`) to avoid type coercion and ensure accurate comparisons.",
        "Use `undefined` to check if a variable has been initialized or if an object property exists (or rather, does not exist). Use `null` to intentionally represent 'no value' or to reset a variable to a state of having no value.",
        "It is generally recommended to avoid explicitly assigning `undefined` in your code. Let JavaScript use `undefined` as its default for uninitialized variables. Prefer using `null` when you need to intentionally represent the absence of a value or object."
      ],
      "quiz": [
        {
          "question": "What is the default value assigned to a variable that is declared but not initialized in JavaScript?",
          "options": ["`null`", "`undefined`", "`0`", "`''` (empty string)"],
          "correctAnswer": 1
        },
        {
          "question": "What does `typeof null` return in JavaScript, and is this considered a quirk?",
          "options": ["`'null'`, and it is correct", "`'undefined'`, and it is incorrect", "`'object'`, and it is a historical quirk", "`'primitive'`, and it is correct"],
          "correctAnswer": 2
        },
        {
          "question": "Which value is used to represent the *intentional* absence of an object value and must be explicitly assigned by the programmer?",
          "options": ["`undefined`", "`null`", "`NaN`", "`0`"],
          "correctAnswer": 1
        },
        {
          "question": "In terms of loose equality (`==`), how do `null` and `undefined` compare?",
          "options": ["They are considered equal", "They are considered not equal", "`null` is loosely greater than `undefined`", "`undefined` is loosely greater than `null`"],
          "correctAnswer": 0
        },
        {
          "question": "When would you typically use `null` in your JavaScript code?",
          "options": ["To indicate that a variable has not been declared", "To represent a function that does not return a value", "To intentionally signify that a variable should have no value or object reference", "As the default value for uninitialized variables"],
          "correctAnswer": 2
        }
      ],
      "interactiveExamples": [
        {
          "title": "Undefined in Different Contexts - Variable, Function, Property",
          "code": "// Undefined variable - Declaration without initialization\nlet uninitializedVariable;\nconsole.log('Uninitialized variable:', uninitializedVariable, ', Type:', typeof uninitializedVariable);\n\n// Function with no explicit return - Implicitly returns undefined\nfunction funcWithoutReturn() {\n  console.log('Function executed, but no return value');\n}\nconsole.log('Function return value:', funcWithoutReturn(), ', Type:', typeof funcWithoutReturn());\n\n// Non-existent object property - Accessing a property that does not exist\nconst objExample = { name: 'Example Object' };\nconsole.log('Non-existent property (objExample.age):', objExample.age, ', Type:', typeof objExample.age);\n\n// Observe the output - all are undefined, indicating absence of value or property"
        },
        {
          "title": "Null Assignment and Checking - Explicitly Setting No Value",
          "code": "// Assigning null to a variable - Intentional absence of value\nlet dataValue = null;\nconsole.log('Data value assigned null:', dataValue, ', Type:', typeof dataValue);\n\n// Function returning null - Indicating no data found or operation failed\nfunction fetchData() {\n  // Simulate scenario where no data is found\n  return null;\n}\nlet fetchedData = fetchData();\nconsole.log('Fetched data (null):', fetchedData, ', Type:', typeof fetchedData);\n\n// Checking for null and undefined - Using == and ===\nlet checkValue;\nif (checkValue == null) { // Checks for both null and undefined due to loose equality\n  console.log('checkValue is null or undefined (using ==)');\n}\nif (checkValue === undefined) {\n  console.log('checkValue is strictly undefined (using ===)');\n}\n\n// Experiment with different checks and scenarios"
        }
      ]
    },
    {
      "id": "js-type-coercion",
      "title": "Type Coercion in JavaScript",
      "description": "Understand JavaScript's type coercion, how it works, and common scenarios where it occurs, especially with operators like `+`, `==`, and `!=`.",
      "difficulty": "intermediate",
      "category": "fundamentals",
      "explanation": "Type coercion in JavaScript is the automatic or implicit conversion of values from one data type to another. It's a feature of JavaScript's dynamically-typed nature, where the interpreter automatically attempts to convert values to the expected data type when operators or functions are used with values of different types. This often happens in situations where an operation expects a certain type but receives another. Common scenarios where type coercion is prevalent include: Arithmetic operators, especially the `+` operator, which can perform both addition (for numbers) and string concatenation (for strings). Comparison operators like `==` and `!=` (loose equality and inequality), which perform type coercion before comparison, unlike strict equality `===` and strict inequality `!==` that do not. Logical operators, which often convert values to booleans in boolean contexts (e.g., in `if` conditions). Understanding type coercion is crucial for avoiding unexpected behavior and writing predictable JavaScript code. While coercion can sometimes be convenient, it can also lead to subtle bugs if not fully grasped. Best practice often recommends using strict equality (`===` and `!==`) to avoid implicit type coercion in comparisons, unless type coercion is intentionally desired and well-understood.",
      "example": "// String coercion - Number converted to string for concatenation\nconsole.log('String + Number:', '5' + 3);       // Output: '53' (Number 3 is coerced to string '3')\nconsole.log('Number + String:', 3 + '5');       // Output: '35' (Number 3 is coerced to string '3')\nconsole.log('String + Boolean:', 'true' + true);  // Output: 'truetrue' (Boolean true is coerced to string 'true')\n\n// Number coercion - String converted to number for arithmetic operations\nconsole.log('String - Number:', '10' - 5);      // Output: 5 (String '10' is coerced to Number 10)\nconsole.log('String * Number:', '4' * 2);       // Output: 8 (String '4' is coerced to Number 4)\nconsole.log('String / Number:', '15' / 3);      // Output: 5 (String '15' is coerced to Number 15)\nconsole.log('String % Number:', '7' % 2);       // Output: 1 (String '7' is coerced to Number 7)\nconsole.log('String ** Number:', '2' ** 3);      // Output: 8 (String '2' is coerced to Number 2)\n\n// Boolean coercion - Values converted to boolean in logical contexts and comparisons\nconsole.log('Number == String (1 == '1'):', 1 == '1');      // Output: true (String '1' is coerced to Number 1 before comparison)\nconsole.log('Boolean == Number (true == 1):', true == 1);     // Output: true (Boolean true is coerced to Number 1)\nconsole.log('Boolean == String (false == '0'):', false == '0');   // Output: true (Boolean false is coerced to Number 0, String '0' to Number 0)\nconsole.log('Null == Undefined (null == undefined):', null == undefined); // Output: true (Both are loosely equal - special case)\nconsole.log('0 == false (0 == false):', 0 == false);         // Output: true (Boolean false is coerced to Number 0)\nconsole.log(''' == false ('' == false):', '' == false);        // Output: true (Boolean false is coerced to String '')\n\n// Falsy/Truthy coercion in logical context - Values coerced to boolean in if conditions\nif ('0') { // String '0' is truthy (non-empty string, even if it represents number 0)\n  console.log('String \"0\" is truthy in if condition'); // This block executes\n}\nif (0) { // Number 0 is falsy\n  console.log('Number 0 is truthy in if condition'); // This block does not execute\n}\nif (null) { // null is falsy\n  console.log('null is truthy in if condition'); // This block does not execute\n}\nif (undefined) { // undefined is falsy\n  console.log('undefined is truthy in if condition'); // This block does not execute\n}\n\n// Avoiding coercion with strict equality - No type conversion, strict comparison\nconsole.log('Strict Equal (1 === '1'):', 1 === '1');     // Output: false (No coercion, types are different - Number vs String)\nconsole.log('Strict Equal (true === 1):', true === 1);    // Output: false (No coercion, types are different - Boolean vs Number)\nconsole.log('Strict Equal (null === undefined):', null === undefined); // Output: false (No coercion, types are different - Null vs Undefined)",
      "keyPoints": [
        "Type coercion in JavaScript is the automatic, implicit conversion of values from one data type to another by the JavaScript engine, typically when operators are applied to values of different types.",
        "Coercion commonly occurs with operators like `+` (string concatenation or addition depending on operands), `==` and `!=` (loose equality and inequality comparisons).",
        "When using `+` operator, if one of the operands is a string, JavaScript usually coerces the other operand to a string and performs string concatenation. If both are numbers, it performs addition.",
        "With arithmetic operators other than `+` (like `-`, `*`, `/`, `%`, `**`), JavaScript generally attempts to coerce strings to numbers. If the string cannot be converted to a valid number, it often results in `NaN`.",
        "Loose equality (`==` and `!=`) performs type coercion before comparing values, which can sometimes lead to unexpected results. It attempts to convert operands to a common type, often number, before comparison.",
        "Falsy values (false, 0, '', null, undefined, NaN) are coerced to `false` in boolean contexts (like in `if` conditions or with logical operators). All other values are coerced to `true` (truthy).",
        "Strict equality (`===` and `!==`) does not perform type coercion. It checks for both value and type equality. If the types are different, the result is immediately `false` for `===` and `true` for `!==`.",
        "Understanding type coercion helps in debugging and writing predictable JavaScript code. Be aware of implicit type conversions, especially with loose equality and the `+` operator.",
        "For clearer and more predictable comparisons, especially when dealing with values of potentially different types, it is generally recommended to use strict equality (`===` and `!==`) to avoid unintended type coercion.",
        "Explicit type conversion (using functions like `Number()`, `String()`, `Boolean()`, `parseInt()`, `parseFloat()`) can be used to intentionally control type conversions and make code more readable and maintainable when type conversion is required."
      ],
      "quiz": [
        {
          "question": "What is type coercion in JavaScript?",
          "options": ["Explicit conversion of data types by the programmer", "Automatic or implicit conversion of data types by JavaScript", "A mechanism to prevent type conversion in JavaScript", "Throwing an error when data types mismatch"],
          "correctAnswer": 1
        },
        {
          "question": "What is the result of `'10' + 5` in JavaScript, and why?",
          "options": ["`15` (Number), because JavaScript performs addition", "`'15'` (String), because JavaScript converts '10' to a number and adds", "`5` (Number), because JavaScript subtracts 5 from 10", "`'105'` (String), because JavaScript coerces 5 to a string and concatenates"],
          "correctAnswer": 3
        },
        {
          "question": "Does strict equality (`===`) in JavaScript perform type coercion before comparison?",
          "options": ["Yes, it always performs type coercion", "No, it does not perform type coercion", "Sometimes, depending on the data types being compared", "Only when comparing numbers and strings"],
          "correctAnswer": 1
        },
        {
          "question": "In a boolean context (like an `if` condition), what is `'0'` (the string '0') coerced to?",
          "options": ["`true`", "`false`", "`null`", "`undefined`"],
          "correctAnswer": 0
        },
        {
          "question": "Which operator is more likely to lead to unexpected results due to type coercion: loose equality (`==`) or strict equality (`===`)?",
          "options": ["Loose equality (`==`)", "Strict equality (`===`)", "Both are equally likely to cause unexpected results", "Neither is likely to cause unexpected results"],
          "correctAnswer": 0
        }
      ],
      "interactiveExamples": [
        {
          "title": "Type Coercion with + Operator - String vs Number",
          "code": "// String concatenation vs. number addition with '+' operator\nconsole.log(''10' + 5 = ', '10' + 5); // String concatenation - Number 5 coerced to string '5'\nconsole.log('10 + 5 = ', 10 + 5);       // Number addition - Both operands are numbers\nconsole.log(''5' + '3' = ', '5' + '3'); // String concatenation - Both operands are strings\nconsole.log('5 + '3' = ', 5 + '3');   // String concatenation - Number 5 coerced to string '5'\n\n// Experiment with different combinations of strings and numbers using '+' and observe the results"
        },
        {
          "title": "Loose vs. Strict Equality - Observing Type Coercion in Comparisons",
          "code": "// Loose equality (==) - Demonstrating type coercion in comparisons\nconsole.log('1 == '1' : ', 1 == '1'); // String '1' coerced to Number 1, true\nconsole.log('true == 1 : ', true == 1); // Boolean true coerced to Number 1, true\nconsole.log('false == '0' : ', false == '0'); // Boolean false coerced to Number 0, String '0' to Number 0, true\nconsole.log('null == undefined : ', null == undefined); // Special case, true\n\n// Strict equality (===) - No type coercion, strict comparison\nconsole.log('1 === '1' : ', 1 === '1'); // Types are different (Number vs String), false\nconsole.log('true === 1 : ', true === 1); // Types are different (Boolean vs Number), false\nconsole.log('false === '0' : ', false === '0'); // Types are different (Boolean vs String), false\nconsole.log('null === undefined : ', null === undefined); // Types are different (Null vs Undefined), false\n\n// Observe the differences and understand how type coercion affects loose equality but not strict equality"
        }
      ]
    },
    {
      "id": "js-error-handling",
      "title": "Error Handling",
      "description": "Learn about error handling in JavaScript using try, catch, finally, and how to throw and handle exceptions.",
      "difficulty": "intermediate",
      "category": "fundamentals",
      "explanation": "Error handling in JavaScript is a critical aspect of writing robust and reliable code. It allows you to anticipate, manage, and gracefully recover from errors that may occur during program execution, rather than letting them crash your application or lead to unpredictable behavior. JavaScript provides structured error handling mechanisms using `try`, `catch`, and `finally` blocks. The `try` block encloses code that might potentially throw an error. If an error occurs within the `try` block, the normal flow of execution is interrupted, and control immediately jumps to the `catch` block. The `catch` block is designed to handle the error, allowing you to log the error, display a user-friendly error message, attempt to recover from the error, or perform other error-handling actions. The optional `finally` block is executed after both the `try` and `catch` blocks (or just after the `try` block if no error occurred), regardless of whether an error was thrown or caught. It's typically used for cleanup tasks like closing files, releasing resources, or finalizing operations that should always be performed. You can also explicitly generate errors using the `throw` statement, which allows you to create custom error objects or throw built-in error types like `Error`, `TypeError`, `RangeError`, etc., to signal exceptional conditions in your code. Effective error handling is essential for building applications that are resilient, user-friendly, and maintainable, especially in web development where unexpected inputs and network issues are common.",
      "example": "// Try, catch, finally example - Handling potential division by zero error\nfunction safeDivide(numerator, denominator) {\n  try { // Code that might throw an error is placed in try block\n    if (denominator === 0) {\n      throw new Error('Division by zero error!'); // Explicitly throw an Error object\n    }\n    return numerator / denominator;\n  } catch (error) { // Catch block to handle errors thrown in try block\n    console.error('Error occurred during division:', error.message); // Log the error message\n    return null; // Return null or handle error as needed\n  } finally { // Finally block always executes, for cleanup or finalization\n    console.log('Division operation attempt completed (finally block executed).');\n  }\n}\n\nconsole.log('Result of safeDivide(10, 2):', safeDivide(10, 2));   // Output: 5 (normal execution)\nconsole.log('Result of safeDivide(5, 0):', safeDivide(5, 0));    // Output: null (error handled, returns null)\n\n// Throwing different types of errors - Demonstrating specific error types\nfunction checkAge(age) {\n  if (typeof age !== 'number') {\n    throw new TypeError('Age must be a number'); // Throw TypeError for type mismatch\n  } else if (age < 0) {\n    throw new RangeError('Age cannot be negative'); // Throw RangeError for out-of-range value\n  } else if (age < 18) {\n    throw new Error('You are too young to proceed'); // Generic Error for business logic condition\n  } else {\n    console.log('Age is valid and access granted.');\n  }\n}\n\ntry {\n  checkAge('twenty'); // This will throw a TypeError\n} catch (error) {\n  if (error instanceof TypeError) { // Check if the error is a TypeError\n    console.error('Type Error caught:', error.message);\n  } else { // Generic error handling for other error types\n    console.error('Generic Error caught:', error.message);\n  }\n}\n\ntry {\n  checkAge(-5);      // This will throw a RangeError\n} catch (error) {\n  if (error instanceof RangeError) { // Check if the error is a RangeError\n    console.error('Range Error caught:', error.message);\n  } else {\n    console.error('Generic Error caught:', error.message);\n  }\n}\n\ntry {\n  checkAge(15);      // This will throw a generic Error\n} catch (error) {\n  console.error('Generic Error caught:', error.message);\n}\n\ncheckAge(25);       // No error thrown - normal execution",
      "keyPoints": [
        "Error handling in JavaScript is primarily managed using `try`, `catch`, and `finally` blocks. This structured approach helps in gracefully managing potential runtime errors.",
        "Code that is expected to potentially throw an error is placed within the `try` block. This block monitors for exceptions during its execution.",
        "If an error occurs within the `try` block, the execution flow immediately jumps to the `catch` block. The `catch` block is used to handle the error and prevent program crashes.",
        "The `catch` block receives an error object as its argument. This error object typically contains details about the error, such as `message` (error description), `name` (error type), and `stack` (call stack trace).",
        "The optional `finally` block always executes after the `try` and `catch` blocks have completed, regardless of whether an error occurred or was caught. It's used for cleanup operations that must always be performed.",
        "You can explicitly throw errors using the `throw` statement followed by an error object. You can throw built-in error types like `Error`, `TypeError`, `RangeError`, `SyntaxError`, or create custom error objects.",
        "Use the `instanceof` operator in the `catch` block to check the type of error. This allows for specific error handling logic based on the error type (e.g., different handling for `TypeError` vs. `RangeError`).",
        "Effective error handling is crucial for preventing application crashes, providing users with meaningful error messages, and ensuring a better user experience, especially in web applications.",
        "Unhandled errors can propagate up the call stack and potentially crash the application or lead to unexpected behavior. Proper error handling prevents this and makes applications more robust.",
        "Asynchronous error handling (e.g., with Promises and `async/await`) also utilizes `try...catch` blocks to handle promise rejections and errors in asynchronous operations, providing a consistent error handling pattern."
      ],
      "quiz": [
        {
          "question": "In JavaScript error handling, which block is used to enclose code that is expected to potentially throw an error?",
          "options": ["`error`", "`catch`", "`try`", "`finally`"],
          "correctAnswer": 2
        },
        {
          "question": "Which block in a `try-catch-finally` structure is guaranteed to be executed regardless of whether an error occurred in the `try` block?",
          "options": ["`error`", "`catch`", "`try`", "`finally`"],
          "correctAnswer": 3
        },
        {
          "question": "How do you explicitly generate or 'raise' an error in JavaScript code?",
          "options": ["Using the `error` keyword", "Using the `throw` keyword", "Using the `catch` keyword", "Errors are thrown automatically without a keyword"],
          "correctAnswer": 1
        },
        {
          "question": "What is the purpose of the `catch` block in error handling?",
          "options": ["To define code that might throw an error", "To handle and recover from errors that occur in the `try` block", "To ensure code always runs after `try` and `catch`", "To prevent errors from occurring in the first place"],
          "correctAnswer": 1
        },
        {
          "question": "What operator can you use in a `catch` block to check the specific type of error that was caught (e.g., `TypeError`, `RangeError`)?",
          "options": ["`typeof`", "`instanceof`", "`getErrorType()`", "`checkError()`"],
          "correctAnswer": 1
        }
      ],
      "interactiveExamples": [
        {
          "title": "Try-Catch-Finally in Action - Handling Division by Zero",
          "code": "function interactiveSafeDivide(numeratorStr, denominatorStr) {\n  let numerator = Number(numeratorStr);\n  let denominator = Number(denominatorStr);\n\n  try {\n    console.log('Attempting division...');\n    if (isNaN(numerator) || isNaN(denominator)) {\n      throw new TypeError('Numerator and denominator must be numbers');\n    }\n    if (denominator === 0) {\n      throw new Error('Cannot divide by zero');\n    }\n    const result = numerator / denominator;\n    return `Result of division: ${result}`;\n  } catch (error) {\n    console.error('Error caught:', error.message);\n    return `Error: ${error.message}`; // Return error message to display\n  } finally {\n    console.log('Division attempt completed.');\n  }\n}\n\n// Get input from user (simulated via prompts - in real browser, use input fields)\nconst numInput = prompt('Enter numerator:');\nconst denInput = prompt('Enter denominator:');\n\nconst divisionResult = interactiveSafeDivide(numInput, denInput);\nalert(divisionResult); // Display result in an alert box\n\n// Try different inputs, including non-numbers and zero denominator, to see error handling"
        },
        {
          "title": "Throwing Custom Errors - Input Validation Example",
          "code": "function validateUserInput(userInput) {\n  if (typeof userInput !== 'string') {\n    throw new TypeError('Input must be a string');\n  } else if (userInput.length < 5) {\n    throw new RangeError('Input string is too short (minimum 5 characters)');\n  } else if (userInput.includes('@')) {\n    throw new Error('Input cannot contain '@' symbol'); // Custom business rule violation\n  } else {\n    return 'Input is valid';\n  }\n}\n\nfunction processUserInput(inputData) {\n  try {\n    const validationResult = validateUserInput(inputData);\n    console.log('Validation result:', validationResult);\n    alert('Input is valid: ' + validationResult); // Alert on success\n  } catch (error) {\n    let errorMessage = 'Validation failed: ' + error.message;\n    if (error instanceof TypeError) {\n      errorMessage = 'Type Error: ' + error.message;\n    } else if (error instanceof RangeError) {\n      errorMessage = 'Length Error: ' + error.message;\n    }\n    console.error(errorMessage);\n    alert(errorMessage); // Alert with error message\n  }\n}\n\n// Get user input (simulated prompt)\nconst inputString = prompt('Enter some text:');\nprocessUserInput(inputString);\n\n// Experiment with valid and invalid inputs (too short, contains '@', wrong type) to test error handling"
        }
      ]
    },
    {
      "id": "js-dom-manipulation-basic",
      "title": "Basic DOM Manipulation",
      "description": "Introduction to Document Object Model (DOM) manipulation in JavaScript. Learn to select elements, modify content, attributes, and styles.",
      "difficulty": "beginner",
      "category": "dom",
      "explanation": "The Document Object Model (DOM) is a cross-platform and language-independent convention for representing and interacting with objects in HTML, XHTML, and XML documents. Think of the DOM as a structured representation of an HTML document, where each part of the HTML (like tags, attributes, and text content) is represented as an object. These objects are organized in a tree-like structure, reflecting the hierarchy of the HTML document.  DOM manipulation in JavaScript is the process of using JavaScript code to access and modify this DOM tree. This allows you to dynamically update the content, structure, and style of a web page in response to user interactions or other events, without needing to reload the entire page. Key aspects of basic DOM manipulation include: Selecting HTML elements using various methods provided by the `document` object (like `getElementById`, `querySelector`, `querySelectorAll`). Modifying the text content of elements using properties like `textContent`. Changing the HTML content of elements using `innerHTML`. Getting and setting HTML attributes (like `class`, `id`, `src`, `href`) using methods like `getAttribute` and `setAttribute`. Applying inline styles to elements using the `style` property. Basic DOM manipulation is fundamental for creating interactive and dynamic web pages, enabling JavaScript to bring HTML documents to life by responding to user actions and updating the interface in real-time.",
      "example": "// Selecting DOM elements - Different selection methods\nconst mainHeading = document.getElementById('main-heading'); // Select element by its ID\nconst paragraphElements = document.querySelectorAll('p');      // Select all paragraph <p> elements\nconst firstParagraph = document.querySelector('p:first-of-type');   // Select the very first paragraph\nconst containerDiv = document.querySelector('.content-area'); // Select the first element with class 'content-area'\n\nconsole.log('Heading element:', mainHeading); // Output: HTMLHeadingElement (if found)\nconsole.log('All paragraph elements:', paragraphElements); // Output: NodeList of paragraph elements\nconsole.log('First paragraph element:', firstParagraph); // Output: HTMLParagraphElement (if found)\nconsole.log('Container div element:', containerDiv); // Output: HTMLDivElement (if found)\n\n// Modifying text content - Changing the text displayed in elements\nif (mainHeading) {\n  mainHeading.textContent = 'Updated Heading Text via JavaScript'; // Change heading text\n}\nif (firstParagraph) {\n  firstParagraph.textContent = 'This paragraph's text content has been dynamically modified using textContent.'; // Change paragraph text\n}\n\n// Modifying HTML content - Injecting HTML markup into elements\nif (containerDiv) {\n  containerDiv.innerHTML = '<p>New paragraph added via <strong>innerHTML</strong>. <a href=\"#\">Example Link</a></p>'; // Add HTML content\n}\n\n// Modifying attributes - Setting attributes like href, class, id, etc.\nconst exampleLink = document.querySelector('#example-link'); // Select a link, assuming it was added via innerHTML above\nif (exampleLink) {\n  exampleLink.setAttribute('href', 'https://www.frontendmentor.io'); // Set href attribute\n  exampleLink.setAttribute('target', '_blank'); // Set target attribute to open in new tab\n  exampleLink.textContent = 'Visit Frontend Mentor'; // Change link text\n}\n\n// Modifying styles - Applying inline CSS styles to elements\nif (mainHeading) {\n  mainHeading.style.color = 'darkblue'; // Change text color\n  mainHeading.style.fontSize = '2.8em'; // Change font size\n  mainHeading.style.textAlign = 'center'; // Align text to center\n}\nif (firstParagraph) {\n  firstParagraph.style.backgroundColor = '#f0f0f0'; // Change background color\n  firstParagraph.style.padding = '12px'; // Add padding around text\n  firstParagraph.style.border = '1px solid #ccc'; // Add a border\n}",
      "keyPoints": [
        "The DOM (Document Object Model) is a platform-neutral interface that treats HTML, XML, or XHTML documents as a tree structure. Each node in the tree represents a part of the document, such as elements, attributes, or text.",
        "JavaScript can access and manipulate the DOM to dynamically update web page content, structure, and styles. This is the foundation of interactivity in web pages.",
        "Common methods for selecting DOM elements include: `document.getElementById(id)` (fastest for selecting by ID), `document.querySelector(selector)` (selects the first element matching a CSS selector), `document.querySelectorAll(selector)` (selects all elements matching a CSS selector), `document.getElementsByClassName(className)` (returns a live HTMLCollection of elements with a class name), `document.getElementsByTagName(tagName)` (returns a live HTMLCollection of elements with a tag name). For modern CSS selector-based selection, `querySelector` and `querySelectorAll` are generally preferred for their flexibility and power.",
        "`textContent` property is used to get or set the text content of an element, excluding any HTML markup. It is generally safer than `innerHTML`, especially when dealing with user-generated content, as it prevents XSS (Cross-Site Scripting) attacks by escaping HTML entities.",
        "`innerHTML` property is used to get or set the HTML content of an element, including HTML markup. Use with caution, especially when setting content that includes user input, due to potential security risks (XSS).",
        "`setAttribute(attributeName, attributeValue)` method is used to set or change the value of an attribute on an HTML element. `getAttribute(attributeName)` method retrieves the current value of an attribute.",
        "The `style` property of a DOM element is an object representing the inline styles of that element. You can modify CSS properties directly using JavaScript (e.g., `element.style.color = 'red'`, `element.style.fontSize = '1.5em'`). Styles set via JavaScript `style` property have higher precedence than styles from CSS stylesheets.",
        "DOM manipulation is essential for creating dynamic web applications, handling user events, updating UI elements based on data changes, and building interactive user interfaces.",
        "Performance considerations are important when manipulating the DOM, as frequent DOM operations can be relatively slow and impact page performance. It's best to batch DOM updates and minimize direct DOM manipulations where possible. Techniques like using document fragments or virtual DOM (in frameworks like React) can help optimize performance."
      ],
      "quiz": [
        {
          "question": "What does DOM stand for in the context of web development?",
          "options": ["Data Object Model", "Document Order Model", "Document Object Manipulation", "Document Object Model"],
          "correctAnswer": 3
        },
        {
          "question": "Which JavaScript method is most efficient for selecting a *single* HTML element by its unique ID?",
          "options": ["`document.querySelector()`", "`document.getElementsByClassName()`", "`document.getElementsByTagName()`", "`document.getElementById()`"],
          "correctAnswer": 3
        },
        {
          "question": "Which property should you use to change the *text* content of an HTML element, while avoiding potential security issues when handling user input?",
          "options": ["`innerHTML`", "`textContent`", "`innerText`", "`element.content`"],
          "correctAnswer": 1
        },
        {
          "question": "What is the primary way to apply *inline* CSS styles to an HTML element using JavaScript DOM manipulation?",
          "options": ["Using `element.setAttribute('style', '...')`", "Using `element.style.cssText = '...'`", "Using `element.style.setProperty('...', '...')`", "All of the above are valid"],
          "correctAnswer": 3
        },
        {
          "question": "Why is it important to be mindful of performance when performing DOM manipulation in JavaScript?",
          "options": ["DOM operations are always very fast and efficient", "Frequent DOM manipulations can be slow and impact page rendering performance", "DOM manipulation only affects backend performance, not frontend", "Modern browsers automatically optimize all DOM manipulations"],
          "correctAnswer": 1
        }
      ],
      "interactiveExamples": [
        {
          "title": "DOM Element Selection - Practice with Different Selectors",
          "code": "// HTML structure (in index.html):\n// <div id='selector-demo'>\n//   <h1 id='demo-title'>DOM Selector Demo</h1>\n//   <p class='demo-paragraph'>First paragraph with class 'demo-paragraph'.</p>\n//   <p class='demo-paragraph'>Second paragraph with class 'demo-paragraph'.</p>\n//   <ul id='demo-list'>\n//     <li class='list-item'>Item 1</li>\n//     <li class='list-item'>Item 2</li>\n//   </ul>\n// </div>\n\n// JavaScript code (in script.js):\nconst titleElementSelector = document.querySelector('#demo-title'); // Select by ID using querySelector\nconst paragraphElementsSelector = document.querySelectorAll('.demo-paragraph'); // Select by class using querySelectorAll\nconst listElementById = document.getElementById('demo-list'); // Select list by ID using getElementById\nconst listItemsByClass = document.getElementsByClassName('list-item'); // Select list items by class using getElementsByClassName\n\nconsole.log('Title Element (querySelector #id):', titleElementSelector);\nconsole.log('Paragraph Elements (querySelectorAll .class):', paragraphElementsSelector);\nconsole.log('List Element (getElementById):', listElementById);\nconsole.log('List Items (getElementsByClassName):', listItemsByClass);\n\n// Experiment by selecting other elements using different selectors and methods"
        },
        {
          "title": "Modifying DOM Content and Attributes - Dynamic Updates",
          "code": "// HTML structure (in index.html):\n// <div id='content-area-modify'>\n//   <h2 id='content-title'>Initial Title</h2>\n//   <p id='content-paragraph'>This is the initial paragraph content.</p>\n//   <button id='content-button'>Click to Change</button>\n//   <a href='#' id='content-link'>Example Link</a>\n// </div>\n\n// JavaScript code (in script.js):\nconst contentTitle = document.getElementById('content-title');\nconst contentParagraph = document.getElementById('content-paragraph');\nconst contentButton = document.getElementById('content-button');\nconst contentLink = document.getElementById('content-link');\n\ncontentButton.addEventListener('click', function() {\n  contentTitle.textContent = 'Title Updated by Button Click!'; // Change text content\n  contentParagraph.innerHTML = 'Paragraph content changed to <strong>emphasized text</strong> using innerHTML.'; // Change HTML content\n  contentLink.setAttribute('href', 'https://www.mozilla.org'); // Change link href attribute\n  contentLink.textContent = 'Visit MDN'; // Change link text\n});\n\n// Click the button to see the content and attributes of elements change dynamically"
        }
      ]
    },
     {
      "id": "js-events-basic",
      "title": "Basic JavaScript Events",
      "description": "Introduction to JavaScript events. Learn about event listeners, common event types, and handling user interactions.",
      "difficulty": "beginner",
      "category": "dom-events",
      "explanation": "JavaScript events are signals or notifications that something has happened in the browser environment. These occurrences can be triggered by user interactions (like mouse clicks, key presses, form submissions), browser actions (like page load completion, window resizing), or other system-level events. Events are the fundamental mechanism for making web pages interactive and responsive. To react to events, you need to use JavaScript to 'listen' for specific events on HTML elements. This is done by attaching event listeners to these elements. An event listener is essentially a function that you set up to be executed when a particular type of event occurs on the element it's attached to.  JavaScript provides a rich set of event types, categorized broadly into: Mouse events (e.g., `click`, `mouseover`, `mouseout`, `mousedown`, `mouseup`, `mousemove`) that are triggered by mouse interactions. Keyboard events (e.g., `keydown`, `keypress`, `keyup`) for handling keyboard input. Form events (e.g., `submit`, `focus`, `blur`, `change`, `input`) for managing form interactions. Document/Window events (e.g., `load`, `DOMContentLoaded`, `resize`, `scroll`) related to the browser window and document loading. Touch events (e.g., `touchstart`, `touchmove`, `touchend`, `touchcancel`) for touch interactions on touch devices. Understanding events and event handling is crucial for creating dynamic and interactive web experiences, allowing your JavaScript code to respond to user actions and browser states.",
      "example": "// Adding a click event listener to a button - Responding to button clicks\nconst clickMeButton = document.getElementById('clickMeButton');\nif (clickMeButton) {\n  clickMeButton.addEventListener('click', function() { // Anonymous function as event handler\n    alert('Button with ID 'clickMeButton' was clicked!'); // Action to perform on click\n  });\n}\n\n// Adding click event listener using arrow function - More concise syntax\nconst anotherButtonExample = document.getElementById('anotherButtonExample');\nif (anotherButtonExample) {\n  anotherButtonExample.addEventListener('click', () => { // Arrow function as event handler\n    console.log('Button with ID 'anotherButtonExample' clicked (Arrow function)!');\n  });\n}\n\n// Example of mouseover and mouseout events - Changing element style on hover\nconst hoverAreaElement = document.getElementById('hoverAreaElement');\nif (hoverAreaElement) {\n  hoverAreaElement.addEventListener('mouseover', function() { // Mouse pointer enters the element\n    hoverAreaElement.style.backgroundColor = 'lightcoral'; // Change background color on mouseover\n  });\n\n  hoverAreaElement.addEventListener('mouseout', function() { // Mouse pointer leaves the element\n    hoverAreaElement.style.backgroundColor = 'white'; // Reset background color on mouseout\n  });\n}\n\n// Example of keydown event on an input field - Logging key presses\nconst inputFieldElement = document.getElementById('inputFieldElement');\nif (inputFieldElement) {\n  inputFieldElement.addEventListener('keydown', function(event) { // Key press event listener\n    console.log('Key pressed:', event.key, ', Code:', event.code); // Log the key and key code\n  });\n}\n\n// Example of form submit event - Preventing default form submission\nconst sampleFormElement = document.getElementById('sampleFormElement');\nif (sampleFormElement) {\n  sampleFormElement.addEventListener('submit', function(event) { // Form submit event listener\n    event.preventDefault(); // Prevent the default form submission action (page reload)\n    alert('Form submission prevented by JavaScript!'); // Custom form handling message\n    // Here you would typically add your custom form data handling logic (e.g., AJAX request)\n  });\n}",
      "keyPoints": [
        "JavaScript events are actions or occurrences that happen in the browser, triggered by user interactions, browser actions, or system events. They are the basis for interactivity in web pages.",
        "Event listeners are functions that are attached to HTML elements to 'listen' for specific events. When the event occurs on the element, the listener function is executed.",
        "Event listeners are added using the `element.addEventListener(eventType, listenerFunction)` method. `eventType` is a string specifying the event type (e.g., 'click', 'mouseover'), and `listenerFunction` is the function to execute when the event occurs.",
        "Common event types include: Mouse events (click, mouseover, mouseout, mousedown, mouseup, mousemove, etc.), Keyboard events (keydown, keypress, keyup), Form events (submit, reset, focus, blur, change, input), Document/Window events (load, DOMContentLoaded, scroll, resize, unload, etc.), Touch events (touchstart, touchmove, touchend, touchcancel).",
        "When an event listener function is executed, it receives an event object as its first argument. This event object contains properties and methods that provide detailed information about the event that occurred.",
        "Key properties of the event object include: `event.type` (the type of event that occurred, e.g., 'click'), `event.target` (the DOM element that triggered the event), `event.currentTarget` (the element to which the event listener is attached), `event.key` and `event.code` (for keyboard events), `event.clientX` and `event.clientY` (mouse coordinates for mouse events), and `event.preventDefault()` method.",
        "The `event.preventDefault()` method is frequently used, especially with form `submit` events and link clicks, to prevent the browser's default action for that event (e.g., preventing form submission to a server or preventing navigation to a URL when a link is clicked).",
        "Event bubbling and event capturing are two phases in the DOM event flow model, describing the order in which event listeners are called when an event occurs on a nested element. By default, events propagate in the bubbling phase (from the target element up to the document root).",
        "Event delegation is a powerful technique for efficiently handling events for a large number of similar elements. Instead of attaching event listeners to each element, you attach a single listener to a common ancestor element and use event properties like `event.target` to determine which element within the ancestor triggered the event."
      ],
      "quiz": [
        {
          "question": "What is a JavaScript event listener primarily used for?",
          "options": ["To style HTML elements dynamically", "To execute code repeatedly at intervals", "To define HTML element structure", "To execute a function in response to a specific event on an HTML element"],
          "correctAnswer": 3
        },
        {
          "question": "Which method is used to attach an event listener to an HTML element in JavaScript?",
          "options": ["`element.attachListener()`", "`element.setEventListener()`", "`element.on()`", "`element.addEventListener()`"],
          "correctAnswer": 3
        },
        {
          "question": "When an event listener function is executed, what is passed as the first argument to this function?",
          "options": ["The HTML element that triggered the event", "The type of event that occurred (as a string)", "An event object containing details about the event", "The return value of the event listener function"],
          "correctAnswer": 2
        },
        {
          "question": "What is the purpose of `event.preventDefault()` in JavaScript event handling?",
          "options": ["To prevent the event listener from being executed", "To stop the event from propagating up the DOM tree (event bubbling)", "To cancel the default action associated with the event (e.g., form submission, link navigation)", "To pause the event handling process temporarily"],
          "correctAnswer": 2
        },
        {
          "question": "Which of the following is an example of a *form event* in JavaScript?",
          "options": ["`click`", "`mouseover`", "`keydown`", "`submit`"],
          "correctAnswer": 3
        }
      ],
      "interactiveExamples": [
        {
          "title": "Click Event Listener - Dynamically Changing Text",
          "code": "// HTML structure (in index.html):\n// <button id='clickButtonExample'>Click to Change Text</button>\n// <div id='textDisplayArea'>Initial Text</div>\n\n// JavaScript code (in script.js):\nconst buttonElementClick = document.getElementById('clickButtonExample');\nconst displayAreaElement = document.getElementById('textDisplayArea');\n\nbuttonElementClick.addEventListener('click', function() {\n  displayAreaElement.textContent = 'Text changed dynamically on button click!'; // Update text content\n});\n\n// Click the button to see the text in the div change dynamically"
        },
        {
          "title": "Mouseover and Mouseout Events - Interactive Style Change",
          "code": "// HTML structure (in index.html):\n// <div id='hoverDivArea' style='width: 150px; height: 100px; border: 2px solid blue; text-align: center; line-height: 100px;'>\n//   Hover Here\n// </div>\n\n// JavaScript code (in script.js):\nconst hoverDiv = document.getElementById('hoverDivArea');\n\nhoverDiv.addEventListener('mouseover', function() {\n  hoverDiv.style.backgroundColor = 'lightblue'; // Change background on mouseover\n  hoverDiv.style.color = 'white';\n  hoverDiv.textContent = 'Mouse Over!';\n});\n\nhoverDiv.addEventListener('mouseout', function() {\n  hoverDiv.style.backgroundColor = 'white'; // Reset background on mouseout\n  hoverDiv.style.color = 'black';\n  hoverDiv.textContent = 'Hover Here';\n});\n\n// Hover your mouse over and out of the div area to see the style and text change"
        }
      ]
    },
    {
      "id": "js-strict-mode",
      "title": "Strict Mode",
      "description": "Learn about JavaScript strict mode, how to enable it, and the benefits of using strict mode for writing safer and cleaner code.",
      "difficulty": "intermediate",
      "category": "best-practices",
      "explanation": "Strict mode in JavaScript is a deliberate choice to enforce stricter parsing and error handling rules on your JavaScript code at runtime. Introduced in ECMAScript 5, strict mode is enabled by adding `'use strict'` or `\"use strict\"` as the very first statement in a JavaScript file (script) or within a function. Once enabled, strict mode changes several JavaScript behaviors, making the language's semantics more rigorous and less forgiving of common coding mistakes that might otherwise be silently ignored or lead to unexpected behavior in 'sloppy' (non-strict) mode. The primary goals of strict mode are to eliminate some JavaScript 'silent errors' by changing them to explicit errors (making debugging easier), fix some quirks that could make it difficult for JavaScript engines to perform optimizations (potentially improving performance), and to forbid certain syntax that is likely to be problematic in future versions of ECMAScript (helping to future-proof code). Using strict mode is widely considered a best practice for writing modern, cleaner, more maintainable, and safer JavaScript code, especially in professional and collaborative projects. It helps catch errors early in development and promotes better coding habits.",
      "example": "// Strict mode enabled for an entire script (file)\n'use strict'; // Must be the first statement in the script\n\n// Undeclared variable assignment in strict mode - Throws ReferenceError\n// x = 10; // Uncommenting this line will throw ReferenceError: x is not defined\n\nlet y = 20; // Declared variable - Works fine in strict mode\nconsole.log('Declared variable y in strict mode:', y); // Output: 20\n\n// Strict mode enabled within a function - Scope of strict mode is function-local\nfunction exampleStrictFunction() {\n  'use strict'; // Strict mode is only active within this function\n  // Undeclared variable inside strict function - Throws ReferenceError\n  // z = 30; // Uncommenting this line will throw ReferenceError: z is not defined\n  let w = 40; // Declared variable - Works fine within strict function\n  console.log('Declared variable w in strict function:', w); // Output: 40\n}\nexampleStrictFunction();\n\n// 'this' keyword in strict mode - 'this' is undefined in functions called directly\nfunction checkThisInStrict() {\n  'use strict';\n  console.log('this' in strict function:', this === undefined ? 'undefined' : this); // Output: undefined\n}\ncheckThisInStrict(); // 'this' is undefined in strict mode for functions called directly\n\nfunction checkThisInNonStrict() {\n  console.log(''this' in non-strict function:', this === window ? 'global object (window)' : this); // Output: global object (window in browsers)\n}\ncheckThisInNonStrict(); // 'this' is the global object (window in browsers) in non-strict mode\n\n// Strict mode prevents duplicate parameter names in function definitions - SyntaxError\n// function functionWithDuplicateParams(a, a) { // Uncommenting this function declaration will cause SyntaxError\n//   'use strict';\n//   return a + a;\n// }\n\n// Octal numeric literals are not allowed in strict mode - SyntaxError\n// let octalNumber = 010; // In non-strict mode, 010 is octal for 8. In strict mode, it's a SyntaxError.\n// 'use strict';\n// let strictOctalNumber = 010; // Uncommenting this line will cause SyntaxError: Octal literals are not allowed in strict mode.",
      "keyPoints": [
        "Strict mode is enabled by adding the directive `'use strict'` or `\"use strict\"` as the first line of a JavaScript file (to apply to the entire script) or at the beginning of a function body (to apply strict mode only to that function).",
        "Strict mode prevents accidental creation of global variables. Assigning a value to an undeclared variable in strict mode throws a `ReferenceError`, making it easier to catch unintentional global variable leaks.",
        "In strict mode, the value of `this` inside functions called directly (not as methods or constructors) is `undefined` instead of the global object (`window` in browsers). This prevents accidental modification of the global object.",
        "Strict mode prohibits duplicate parameter names in function definitions. In non-strict mode, duplicate parameter names are allowed, but only the last occurrence is accessible within the function. Strict mode makes this a `SyntaxError`",
    "Strict mode disallows octal numeric literals (e.g., `010` which is 8 in octal). In strict mode, using octal literals results in a `SyntaxError`. Leading zeros in numbers are treated as decimal numbers in strict mode.",
            "Strict mode makes assignments to read-only properties on objects and attempts to add properties to non-extensible objects throw `TypeError` errors. In non-strict mode, these operations might fail silently.",
            "Attempting to delete undeletable properties (like built-in properties or variables declared with `var` in global scope in non-strict mode) will throw a `SyntaxError` in strict mode, whereas in non-strict mode, these delete operations might be ignored.",
            "`eval()` in strict mode operates in its own scope. Variables declared inside `eval()` in strict mode are not created in the surrounding scope, preventing potential scope pollution.",
            "Using strict mode is a proactive approach to writing cleaner, safer, and more maintainable JavaScript code. It helps catch common mistakes and encourages better coding practices by enforcing stricter language rules.",
            "It is highly recommended to use strict mode in all modern JavaScript projects, especially for web frontend development, to benefit from its error detection and code quality enhancements."
          ],
          "quiz": [
            {
              "question": "How do you enable strict mode for a single JavaScript function?",
              "options": ["By adding `\"strict mode\";` at the end of the function", "By adding `'use-strict';` at the beginning of the function body", "By adding `'use strict';` as the first statement inside the function body", "Strict mode cannot be enabled for individual functions, only for entire scripts"],
              "correctAnswer": 2
            },
            {
              "question": "In strict mode, what is the value of `this` in a regular function (not a method or arrow function) when called in the global context?",
              "options": ["The global object (window in browsers)", "The function itself", "`undefined`", "It depends on how the function is called"],
              "correctAnswer": 2
            },
            {
              "question": "Which of the following actions will result in an error in strict mode but might not in sloppy mode?",
              "options": ["Declaring a variable with `let`", "Assigning a value to a property of an object", "Assigning a value to an undeclared variable", "Calling a function"],
              "correctAnswer": 2
            },
            {
              "question": "What is one of the primary benefits of using strict mode in JavaScript?",
              "options": ["It makes JavaScript code run faster", "It prevents all types of errors in JavaScript", "It helps catch common coding mistakes and promotes cleaner code", "It automatically fixes errors in your code"],
              "correctAnswer": 2
            },
            {
              "question": "Are octal numeric literals allowed in JavaScript strict mode?",
              "options": ["Yes, they are allowed and treated as octal numbers", "Yes, they are allowed but treated as decimal numbers", "No, they are not allowed and result in a `SyntaxError`", "They are allowed only in specific contexts within strict mode"],
              "correctAnswer": 2
            }
          ],
          "interactiveExamples": [
            {
              "title": "Strict Mode - Undeclared Variable Error",
              "code": "// Run in non-strict mode (for comparison)\nfunction nonStrictModeTest() {\n  mistypedVar = 'Global in sloppy mode'; // No 'use strict', accidental global\n  console.log('Non-strict mode: mistypedVar is now global:', mistypedVar);\n}\nnonStrictModeTest();\nconsole.log('Global access in non-strict mode:', mistypedVar);\n\n// Run in strict mode\nfunction strictModeVarErrorTest() {\n  'use strict';\n  // mistypedVarStrict = 'Error in strict mode'; // Uncommenting this will throw ReferenceError\n  let declaredVar = 'Correct in strict mode';\n  console.log('Strict mode: declaredVar works:', declaredVar);\n}\nstrictModeVarErrorTest();\n// console.log('Global access attempt in strict mode:', mistypedVarStrict); // Error - mistypedVarStrict is not defined\n\n// Observe the ReferenceError in strict mode when trying to use an undeclared variable"
            },
            {
              "title": "Strict Mode - 'this' Keyword Behavior Difference",
              "code": "// 'this' in a function in non-strict mode\nfunction nonStrictThisContext() {\n  console.log('Non-strict mode 'this' === window:', this === window); // In browser, 'this' is global window object\n}\nnonStrictThisContext();\n\n// 'this' in a function in strict mode\nfunction strictThisContext() {\n  'use strict';\n  console.log('Strict mode 'this' === undefined:', this === undefined); // 'this' is undefined in strict mode\n}\nstrictThisContext();\n\n// Class methods and 'this' are implicitly in strict mode behavior in modern JS\nclass ExampleClass {\n  classMethodThis() {\n    console.log('Class method 'this' (implicitly strict):', this); // 'this' is instance of ExampleClass\n  }\n}\nconst classInstance = new ExampleClass();\nclassInstance.classMethodThis();\n\n// Compare 'this' behavior in strict vs. non-strict functions"
            }
          ]
        },
        {
          "id": "interview-js-concept-1",
          "title": "JavaScript Hoisting",
          "description": "Understand JavaScript hoisting, how variable and function declarations are moved to the top of their scope during compilation phase.",
          "difficulty": "intermediate",
          "category": "fundamentals",
          "explanation": "Hoisting is a JavaScript mechanism where variable and function declarations are moved to the top of their scope before code execution. It's important to note that only declarations are hoisted, not initializations. This means you can use variables and functions in your code before they are actually declared in the code, without JavaScript throwing an error (in many cases). However, for variables declared with `var`, only the declaration is hoisted, and the initialization remains in place. This can lead to `undefined` values if you try to use the variable before its line of initialization. Variables declared with `let` and `const` are also hoisted, but they are not initialized. Accessing them before their declaration will result in a `ReferenceError`, known as the 'temporal dead zone'. Function declarations are fully hoisted, meaning both the declaration and the function body are moved to the top, allowing you to call function declarations anywhere in their scope. Function expressions, however, are not hoisted in the same way; only the variable declaration is hoisted (if declared with `var`, `let`, or `const`), and the function body is assigned at the line of code where the function expression is defined. Understanding hoisting is crucial to avoid unexpected behavior and write cleaner, more predictable JavaScript code, especially when working with variables and functions defined across different parts of your script.",
          "example": "// Variable hoisting with var\nconsole.log(myVar); // Output: undefined (declaration hoisted, initialization not)\nvar myVar = 'Variable declared with var';\nconsole.log(myVar); // Output: Variable declared with var\n\n// Variable hoisting with let (Temporal Dead Zone)\n// console.log(myLet); // Uncommenting this line will throw ReferenceError: Cannot access 'myLet' before initialization\nlet myLet = 'Variable declared with let';\nconsole.log(myLet); // Output: Variable declared with let\n\n// Function declaration hoisting\nmyFunctionDeclaration(); // Output: Function declaration is called (works because function declaration is fully hoisted)\nfunction myFunctionDeclaration() {\n  console.log('Function declaration is called');\n}\n\n// Function expression hoisting\n// myFunctionExpression(); // Uncommenting this line will throw TypeError: myFunctionExpression is not a function (because only variable declaration is hoisted)\nvar myFunctionExpression = function() {\n  console.log('Function expression is called');\n};\nmyFunctionExpression(); // Output: Function expression is called",
          "keyPoints": [
            "Hoisting in JavaScript moves declarations of variables and functions to the top of their scope during the compilation phase, before execution.",
            "Only declarations are hoisted, not initializations. For `var` variables, this means you can access them before their declaration, but their value will be `undefined` until the line of initialization is reached.",
            "Variables declared with `let` and `const` are also hoisted, but they are in a 'temporal dead zone' until their declaration line is reached. Accessing them before declaration results in a `ReferenceError`.",
            "Function declarations are fully hoisted, allowing them to be called anywhere within their scope, even before their actual declaration in the code.",
            "Function expressions are not fully hoisted. If declared with `var`, the variable declaration is hoisted (but initially `undefined`). If declared with `let` or `const`, they are subject to the temporal dead zone.",
            "Understanding hoisting is essential for debugging and writing predictable JavaScript code, especially when dealing with variable and function scopes.",
            "In modern JavaScript, using `let` and `const` and declaring variables at the top of their scope can mitigate issues related to hoisting and improve code clarity."
          ],
          "quiz": [
            {
              "question": "What is hoisted in JavaScript?",
              "options": ["Only variable declarations", "Only function declarations", "Both variable and function declarations", "Neither variable nor function declarations"],
              "correctAnswer": 2
            },
            {
              "question": "What is the value of a `var` declared variable if accessed before its initialization?",
              "options": ["`null`", "`undefined`", "Throws a `ReferenceError`", "The initialized value (if initialized later in the scope)"],
              "correctAnswer": 1
            },
            {
              "question": "What happens if you try to access a `let` or `const` declared variable before its declaration?",
              "options": ["Returns `undefined`", "Returns `null`", "Throws a `ReferenceError`", "Works normally, accessing the initialized value (if any)"],
              "correctAnswer": 2
            },
            {
              "question": "Are function declarations hoisted?",
              "options": ["No, function declarations are not hoisted", "Yes, only the function name is hoisted", "Yes, function declarations are fully hoisted (declaration and body)", "Only function declarations inside objects are hoisted"],
              "correctAnswer": 2
            },
            {
              "question": "Are function expressions hoisted in the same way as function declarations?",
              "options": ["Yes, function expressions are hoisted the same way", "No, function expressions are not hoisted at all", "Function expressions are hoisted only if declared with `var`", "Only the variable declaration of a function expression is hoisted, not the function body"],
              "correctAnswer": 3
            }
          ],
          "interactiveExamples": [
            {
              "title": "Hoisting with `var` vs `let`",
              "code": "// var hoisting example\nconsole.log('Before declaration (var):', hoistedVar); // No error, outputs undefined\nvar hoistedVar = 'I am hoisted with var';\nconsole.log('After declaration (var):', hoistedVar);\n\n// let hoisting example (try uncommenting to see error)\n// console.log('Before declaration (let):', hoistedLet); // ReferenceError: Cannot access 'hoistedLet' before initialization\nlet hoistedLet = 'I am hoisted with let, but in TDZ';\nconsole.log('After declaration (let):', hoistedLet);\n\n// Observe the difference in behavior when accessing variables before their declarations using var and let"
            },
            {
              "title": "Function Declaration vs Function Expression Hoisting",
              "code": "// Function declaration - Hoisted and callable before declaration\ncallFunctionDeclaration(); // Works fine\nfunction callFunctionDeclaration() {\n  console.log('Function Declaration called');\n}\n\n// Function expression - Not callable before declaration (if using var, TypeError, if let/const, ReferenceError)\n// callFunctionExpression(); // TypeError: callFunctionExpression is not a function (if var) or ReferenceError (if let/const)\nvar callFunctionExpression = function() {\n  console.log('Function Expression called');\n};\ncallFunctionExpression(); // Works after declaration\n\n// Experiment by calling function declarations and expressions before and after their definitions to understand hoisting differences"
            }
          ]
        },
        {
          "id": "interview-js-concept-2",
          "title": "Event Bubbling and Capturing",
          "description": "Learn about DOM event flow: capturing and bubbling phases, and how events propagate through the DOM tree.",
          "difficulty": "intermediate",
          "category": "dom-events",
          "explanation": "When an event occurs on a DOM element, it goes through a process called event flow. This process has two phases: capturing and bubbling.  In the capturing phase, the event travels down the DOM tree from the window to the target element (the element where the event originated). Event listeners attached in the capturing phase are triggered first. After the capturing phase, the event reaches the target element. Event listeners attached directly to the target element are then triggered. Finally, in the bubbling phase, the event 'bubbles up' the DOM tree from the target element back to the window. Event listeners attached in the bubbling phase are triggered as the event moves up the tree. By default, event listeners in JavaScript are attached in the bubbling phase. This means that when an event occurs on an element, the listeners on the element's ancestors are triggered after the listeners on the element itself. You can specify whether an event listener should be triggered in the capturing or bubbling phase by using the third argument of the `addEventListener` method. Understanding event capturing and bubbling is crucial for effectively managing events in complex DOM structures, especially when dealing with nested elements and event delegation.",
          "example": "// HTML Structure:\n// <div id='outer' style='padding: 20px; background-color: lightblue;'>\n//   Outer Div\n//   <div id='inner' style='padding: 20px; background-color: lightcoral;'>\n//     Inner Div (Click Here)\n//   </div>\n// </div>\n\n// JavaScript Code:\nconst outerDiv = document.getElementById('outer');\nconst innerDiv = document.getElementById('inner');\n\n// Bubbling phase listener on outer div (default)\nouterDiv.addEventListener('click', function(event) {\n  console.log('Outer Div - Bubbling Phase');\n});\n\n// Bubbling phase listener on inner div (default)\ninnerDiv.addEventListener('click', function(event) {\n  console.log('Inner Div - Bubbling Phase');\n});\n\n// Capturing phase listener on outer div (using capture: true)\nouterDiv.addEventListener('click', function(event) {\n  console.log('Outer Div - Capturing Phase');\n}, true); // Third argument 'true' makes it capturing phase\n\n// Capturing phase listener on inner div (using capture: true)\ninnerDiv.addEventListener('click', function(event) {\n  console.log('Inner Div - Capturing Phase');\n}, true); // Third argument 'true' makes it capturing phase\n\n// When you click on the 'Inner Div', observe the console output order to understand capturing and bubbling phases.",
          "keyPoints": [
            "DOM event flow has two main phases: capturing and bubbling, which describe how events propagate through the DOM tree.",
            "The capturing phase is the first phase where the event travels down from the window to the target element.",
            "The target phase occurs when the event reaches the element that triggered the event. Listeners attached directly to this element are triggered.",
            "The bubbling phase is the second phase where the event travels up from the target element back to the window.",
            "By default, event listeners in JavaScript are attached in the bubbling phase. This is the most common and often more intuitive behavior.",
            "You can attach event listeners in the capturing phase by setting the third argument of `addEventListener` to `true` (or providing an options object with `capture: true`).",
            "Capturing phase listeners are triggered before bubbling phase listeners for the same event on the same element or its ancestors.",
            "Understanding event capturing and bubbling is essential for managing complex event interactions, especially in nested DOM structures and for implementing event delegation.",
            "Event propagation can be stopped using `event.stopPropagation()` method, which prevents the event from further bubbling up or capturing down the DOM tree."
          ],
          "quiz": [
            {
              "question": "What are the two phases of DOM event flow?",
              "options": ["Propagation and Execution", "Capturing and Handling", "Capturing and Bubbling", "Triggering and Listening"],
              "correctAnswer": 2
            },
            {
              "question": "In which phase of event flow does the event travel down the DOM tree?",
              "options": ["Bubbling Phase", "Target Phase", "Capturing Phase", "Handling Phase"],
              "correctAnswer": 2
            },
            {
              "question": "In which phase of event flow are event listeners triggered by default in JavaScript?",
              "options": ["Capturing Phase", "Target Phase", "Bubbling Phase", "Neither Capturing nor Bubbling Phase"],
              "correctAnswer": 2
            },
            {
              "question": "How do you attach an event listener in the capturing phase using `addEventListener`?",
              "options": ["By setting the second argument to `true`", "By setting the third argument to `capture`", "By setting the third argument to `true`", "It's not possible to attach listeners in the capturing phase"],
              "correctAnswer": 2
            },
            {
              "question": "What does `event.stopPropagation()` do?",
              "options": ["Prevents the default action of the event", "Stops the event from reaching the target element", "Stops the event from further bubbling up or capturing down the DOM tree", "Removes the event listener"],
              "correctAnswer": 2
            }
          ],
          "interactiveExamples": [
            {
              "title": "Event Capturing and Bubbling Visualization",
              "code": "// HTML Structure (similar to example, but with inline styles for clarity):\n// <div id='captureBubbleOuter' style='padding: 20px; background-color: lightblue; border: 1px solid blue;' onclick='console.log(\"Outer Div - Bubbling Inline\");'>\n//   Outer Div (Bubbling Inline)\n//   <div id='captureBubbleInner' style='padding: 20px; background-color: lightcoral; border: 1px solid red;' onclick='console.log(\"Inner Div - Bubbling Inline\");'>\n//     Inner Div (Bubbling Inline - Click Here)\n//   </div>\n// </div>\n\n// JavaScript Code (adding capturing listeners):\nconst captureBubbleOuterDiv = document.getElementById('captureBubbleOuter');\nconst captureBubbleInnerDiv = document.getElementById('captureBubbleInner');\n\ncaptureBubbleOuterDiv.addEventListener('click', function(event) {\n  console.log('Outer Div - Capturing Listener');\n}, true);\n\ncaptureBubbleInnerDiv.addEventListener('click', function(event) {\n  console.log('Inner Div - Capturing Listener');\n}, true);\n\n// Click on the 'Inner Div' and observe the console output order. Compare with inline 'onclick' handlers (bubbling) to see the phase order."
            },
            {
              "title": "Stopping Event Propagation",
              "code": "// HTML Structure:\n// <div id='stopPropOuter' style='padding: 20px; background-color: lightgreen;'>\n//   Outer Div\n//   <button id='stopPropButton'>Click to Stop Propagation</button>\n// </div>\n\n// JavaScript Code:\nconst stopPropOuterDiv = document.getElementById('stopPropOuter');\nconst stopPropButton = document.getElementById('stopPropButton');\n\nstopPropOuterDiv.addEventListener('click', function() {\n  console.log('Outer Div Clicked (Bubbling)');\n});\n\nstopPropButton.addEventListener('click', function(event) {\n  console.log('Button Clicked - Before stopPropagation');\n  event.stopPropagation(); // Stop event from bubbling up to outer div\n  console.log('Button Clicked - After stopPropagation');\n});\n\n// Click the button. Notice that 'Outer Div Clicked' is not logged because propagation is stopped."
            }
          ]
        },
        {
          "id": "interview-js-concept-3",
          "title": "`this` Keyword in JavaScript",
          "description": "Deep dive into the `this` keyword in JavaScript, its different contexts (global, function, object method, constructor, arrow functions), and binding methods.",
          "difficulty": "intermediate",
          "category": "fundamentals",
          "explanation": "The `this` keyword in JavaScript is a fundamental concept that can be initially confusing but is essential for understanding how JavaScript works, especially in object-oriented and event-driven contexts. The value of `this` is dynamic and depends on how a function is called.  In the global context (outside of any function or object), `this` refers to the global object (window in browsers, global in Node.js). Inside a regular function, the value of `this` depends on how the function is invoked. If the function is called as a method of an object, `this` is set to the object that the method is called on. If the function is called as a standalone function (not as a method), in non-strict mode, `this` is again set to the global object; in strict mode, `this` is `undefined`. When a function is used as a constructor (with the `new` keyword), `this` is bound to the newly created object instance. Arrow functions behave differently; they do not have their own `this` binding. Instead, they lexically capture the `this` value from their surrounding scope (the scope in which they are defined). JavaScript provides methods like `call()`, `apply()`, and `bind()` to explicitly set the value of `this` for a function, allowing you to control the context in which a function is executed. Mastering `this` is crucial for writing object-oriented JavaScript, handling events, and working with callbacks.",
          "example": "// 'this' in global context\nconsole.log('Global this (outside function):', this === window ? 'window' : 'global'); // Output: window (in browsers)\n\n// 'this' in a regular function (non-strict mode)\nfunction regularFunctionThis() {\n  console.log('Regular function this (non-strict):', this === window ? 'window' : 'global'); // Output: window (in browsers)\n}\nregularFunctionThis();\n\n// 'this' in a regular function (strict mode)\nfunction strictFunctionThis() {\n  'use strict';\n  console.log('Strict function this:', this === undefined ? 'undefined' : this); // Output: undefined\n}\nstrictFunctionThis();\n\n// 'this' in object methods\nconst myObject = {\n  name: 'My Object',\n  methodThis: function() {\n    console.log('Object method this:', this === myObject); // Output: true\n    console.log('Object name via this:', this.name); // Output: My Object\n  }\n};\nmyObject.methodThis();\n\n// 'this' in constructor functions\nfunction ConstructorFunction() {\n  this.propertyName = 'Property from constructor';\n  console.log('Constructor function this:', this instanceof ConstructorFunction); // Output: true\n}\nconst instance = new ConstructorFunction();\nconsole.log('Instance property:', instance.propertyName); // Output: Property from constructor\n\n// 'this' in arrow functions (lexical this)\nconst arrowObject = {\n  name: 'Arrow Object',\n  arrowMethodThis: () => {\n    console.log('Arrow function this (lexical):', this === window ? 'window' : 'global'); // Output: window (or global, depends on context)\n    // Arrow function does NOT bind its own 'this', it inherits from the surrounding scope (in this case, global)\n  },\n  regularMethodWithArrow: function() {\n    const innerArrow = () => {\n      console.log('Inner arrow function this (lexical from regular method):', this === arrowObject); // Output: true\n      console.log('Object name via inner arrow this:', this.name); // Output: Arrow Object\n    };\n    innerArrow();\n  }\n};\narrowObject.arrowMethodThis();\narrowObject.regularMethodWithArrow();\n\n// Using call(), apply(), bind() to explicitly set 'this'\nfunction exampleFunction() {\n  console.log('Explicitly bound this:', this.customName);\n}\nconst contextObject = { customName: 'Custom Context' };\nexampleFunction.call(contextObject);   // call() - invokes function with 'this' set to contextObject\nexampleFunction.apply(contextObject);  // apply() - same as call, but arguments as array\nconst boundFunction = exampleFunction.bind(contextObject); // bind() - returns new function with 'this' permanently bound\nboundFunction();",
          "keyPoints": [
            "The value of `this` in JavaScript is dynamic and context-dependent, determined by how a function is called, not where it's defined (except for arrow functions).",
            "In the global scope, `this` refers to the global object (window in browsers, global in Node.js).",
            "Inside a regular function, the value of `this` depends on the invocation: as an object method, `this` is the object; as a standalone function (non-strict), `this` is the global object; in strict mode, `this` is `undefined`.",
            "When a function is used as a constructor (with `new`), `this` is bound to the newly created object instance.",
            "Arrow functions do not have their own `this` context. They lexically inherit the `this` value from their surrounding (enclosing) scope. This is often referred to as lexical `this`.",
            "`call()` and `apply()` methods are used to invoke a function immediately, explicitly setting the value of `this` and passing arguments (individually for `call()`, as an array for `apply()`).",
            "`bind()` method creates a new function that, when called, has its `this` keyword set to the provided value permanently. It does not invoke the function immediately but returns a bound function.",
            "Understanding `this` is crucial for object-oriented programming in JavaScript, event handling, working with callbacks, and correctly managing function contexts.",
            "Be mindful of `this` behavior in different scenarios, especially when using callbacks, event listeners, and working with classes or prototypes."
          ],
          "quiz": [
            {
              "question": "What determines the value of `this` in JavaScript?",
              "options": ["Where the function is defined", "The name of the function", "How the function is called (invoked)", "The scope in which the function is declared"],
              "correctAnswer": 2
            },
            {
              "question": "In strict mode, what is the value of `this` inside a regular function called in the global context?",
              "options": ["The global object (window)", "`undefined`", "The function itself", "It's the same as in non-strict mode"],
              "correctAnswer": 1
            },
            {
              "question": "What is the value of `this` inside an object method?",
              "options": ["The global object", "`undefined`", "The object the method is called on", "The prototype of the object"],
              "correctAnswer": 2
            },
            {
              "question": "How do arrow functions handle the `this` keyword?",
              "options": ["Arrow functions have their own `this` context, similar to regular functions", "Arrow functions do not have their own `this`; they inherit `this` from the surrounding scope (lexical `this`)", "In arrow functions, `this` always refers to the global object", "Arrow functions cannot use the `this` keyword"],
              "correctAnswer": 1
            },
            {
              "question": "Which method is used to create a new function with a permanently bound `this` value?",
              "options": ["`call()`", "`apply()`", "`bind()`", "`new`"],
              "correctAnswer": 2
            }
          ],
          "interactiveExamples": [
            {
              "title": "'this' in Different Contexts - Explore and Observe",
              "code": "// Global 'this'\nconsole.log('Global this (window === this):', window === this); // In browser\n\n// Function 'this' (non-strict)\nfunction checkRegularThis() {\n  console.log('Regular function this (window === this):', window === this);\n}\ncheckRegularThis();\n\n// Function 'this' (strict)\nfunction checkStrictThis() {\n  'use strict';\n  console.log('Strict function this (undefined === this):', undefined === this);\n}\ncheckStrictThis();\n\n// Object method 'this'\nconst contextExampleObject = {\n  method: function() {\n    console.log('Method this (contextObject === this):', contextExampleObject === this);\n  }\n};\ncontextExampleObject.method();\n\n// Arrow function 'this'\nconst arrowThisExample = {\n  arrowMethod: () => {\n    console.log('Arrow function this (window === this):', window === this); // Lexical 'this'\n  }\n};\narrowThisExample.arrowMethod();\n\n// Run and observe 'this' value in each context - global, function, method, arrow function"
            },
            {
              "title": "Explicitly Binding 'this' with call, apply, bind",
              "code": "// Function to test 'this' binding\nfunction displayThisContext() {\n  console.log('Displaying this.name:', this.name);\n}\n\nconst context1 = { name: 'Context Object 1' };\nconst context2 = { name: 'Context Object 2' };\n\n// Using call()\ndisplayThisContext.call(context1); // 'this' is context1\n\n// Using apply()\ndisplayThisContext.apply(context2); // 'this' is context2\n\n// Using bind()\nconst boundToContext1 = displayThisContext.bind(context1); // 'this' permanently bound to context1\nboundToContext1(); // 'this' is context1\n\nconst boundToContext2 = displayThisContext.bind(context2);\nboundToContext2(); // 'this' is context2\n\n// Experiment with call, apply, bind to understand explicit 'this' setting"
            }
          ]
        },
        {
          "id": "interview-js-concept-4",
          "title": "Closures in Depth",
          "description": "Explore JavaScript closures in detail: how they work, their practical uses in data privacy, function factories, and common interview questions.",
          "difficulty": "advanced",
          "category": "functions",
          "explanation": "Closures are a powerful and distinctive feature of JavaScript. A closure is created when a function is defined inside another function (nested function), and the inner function retains access to the outer function's variables (lexical scope), even after the outer function has completed execution. This 'remembers' or 'closes over' the environment in which the inner function was created, hence the term 'closure'.  The key characteristic of closures is their ability to access variables from their outer scope even after the outer function has returned. This happens because when an inner function is created, it forms a closure over the variables of its lexical environment. These variables are not garbage collected as long as the inner function (the closure) is still reachable. Closures are used extensively in JavaScript for various purposes, including: Data privacy and encapsulation: By using variables in the outer function's scope, you can create 'private' variables that are only accessible through the inner function's methods, effectively encapsulating data. Function factories: Functions that return other functions (closures) can be used to create specialized functions with pre-configured parameters or settings. Maintaining state in asynchronous operations: Closures can be used to preserve state across asynchronous callbacks or promises. Module pattern: Closures are fundamental to implementing the module pattern in JavaScript, allowing for the creation of modules with private state and public methods. Understanding closures is essential for writing advanced JavaScript code, especially for functional programming paradigms and managing state in complex applications.",
          "example": "// Closure for data privacy - Counter example\nfunction createCounter() {\n  let count = 0; // Private variable - only accessible within createCounter scope\n\n  return {\n    increment: function() {\n      count++;\n    },\n    decrement: function() {\n      count--;\n    },\n    getCount: function() {\n      return count;\n    }\n  };\n}\n\nconst counter = createCounter();\ncounter.increment();\ncounter.increment();\nconsole.log('Counter value:', counter.getCount()); // Output: 2\n// console.log(counter.count); // Error: 'count' is not accessible directly, it's private due to closure\n\n// Closure as function factory - Multiplier factory\nfunction multiplier(factor) {\n  return function(number) { // Returns a closure\n    return number * factor;\n  };\n}\n\nconst multiplyByTwo = multiplier(2); // 'factor' is closed over in multiplyByTwo\nconst multiplyByTen = multiplier(10); // 'factor' is closed over in multiplyByTen\n\nconsole.log('5 times 2:', multiplyByTwo(5));  // Output: 10\nconsole.log('5 times 10:', multiplyByTen(5)); // Output: 50\n\n// Closure for maintaining state in asynchronous operations - setTimeout example\nfunction delayedLoggers() {\n  for (var i = 1; i <= 3; i++) { // Using var to demonstrate closure issue initially\n    setTimeout(function() {\n      console.log('Logged after delay:', i); // 'i' will be 4 in all iterations due to closure over 'var' and loop completion\n    }, i * 1000);\n  }\n}\ndelayedLoggers(); // Initially demonstrates issue with var in loops and closures\n\n// Fix using let - Block-scoped 'i' creates a new closure for each iteration\nfunction fixedDelayedLoggers() {\n  for (let i = 1; i <= 3; i++) { // Using let to fix closure issue\n    setTimeout(function() {\n      console.log('Fixed logged after delay:', i); // 'i' is correctly captured for each iteration due to block scope of let\n    }, i * 1000);\n  }\n}\nfixedDelayedLoggers(); // Demonstrates correct closure behavior with let in loops",
          "keyPoints": [
            "A closure is created when a function is defined inside another function, and the inner function accesses variables from the outer function's scope.",
            "Closures 'remember' variables from their lexical environment even after the outer function has finished executing. This is due to the inner function closing over these variables.",
            "Closures are used for data privacy and encapsulation by creating private variables within the outer function's scope, accessible only through the inner function's methods.",
            "Function factories utilize closures to create specialized functions. The outer function takes parameters and returns an inner function that 'remembers' these parameters through closure.",
            "Closures are essential for managing state in asynchronous operations. They can capture and retain variables' values at the time of function creation, even when asynchronous operations complete later.",
            "In loops, especially with asynchronous operations like `setTimeout`, using `var` can lead to closure issues where all iterations share the same variable due to function scope. Using `let` (block scope) resolves this by creating a new closure for each iteration.",
            "Closures are the foundation of the module pattern in JavaScript, enabling the creation of modules with private state and public API, enhancing code organization and maintainability.",
            "Understanding closures is crucial for mastering functional programming in JavaScript and for handling complex state management and asynchronous programming scenarios."
          ],
          "quiz": [
            {
              "question": "What is a JavaScript closure?",
              "options": ["A function that is immediately invoked", "A function that is defined globally", "A function that has access to its outer function's variables even after the outer function has returned", "A function without a name"],
              "correctAnswer": 2
            },
            {
              "question": "What is the primary reason closures can access outer function variables even after the outer function has finished?",
              "options": ["Garbage collection in JavaScript doesn't remove outer scope variables", "Inner functions are automatically hoisted to the outer scope", "Inner functions form a closure over the lexical environment of their creation", "Outer functions are never completely removed from memory"],
              "correctAnswer": 2
            },
            {
              "question": "Which of the following is a common use case for closures?",
              "options": ["Creating global variables", "Simplifying synchronous code", "Data encapsulation and creating private variables", "Making code run faster"],
              "correctAnswer": 2
            },
            {
              "question": "In the 'counter' closure example, where is the `count` variable actually stored?",
              "options": ["In the global scope", "Inside the `increment` and `decrement` functions", "In the closure created by `createCounter`", "It is not stored, it's recalculated each time the counter is accessed"],
              "correctAnswer": 2
            },
            {
              "question": "Why is using `let` instead of `var` often recommended when creating closures in loops?",
              "options": ["`let` is faster than `var`", "`let` is block-scoped, creating a new closure for each iteration, while `var` is function-scoped and can lead to closure issues", "`let` prevents memory leaks in closures", "`var` cannot be used in loops"],
              "correctAnswer": 1
            }
          ],
          "interactiveExamples": [
            {
              "title": "Closure for Private Variables - Experiment with Scope",
              "code": "// Closure to simulate private variable\nfunction createBankAccount(initialBalance) {\n  let balance = initialBalance; // Private balance variable\n\n  return {\n    deposit: function(amount) {\n      balance += amount;\n    },\n    withdraw: function(amount) {\n      if (amount <= balance) {\n        balance -= amount;\n        return amount;\n      } else {\n        return 'Insufficient funds';\n      }\n    },\n    getBalance: function() {\n      return balance;\n    }\n  };\n}\n\nconst account = createBankAccount(100);\naccount.deposit(50);\nconsole.log('Current balance:', account.getBalance()); // Access balance via method\nconsole.log('Withdraw 20:', account.withdraw(20));\nconsole.log('Current balance after withdrawal:', account.getBalance());\n// console.log(account.balance); // Try to access balance directly - should be undefined/inaccessible\n\n// Attempt to access 'balance' directly - observe that it's not accessible, demonstrating data privacy via closure."
            },
            {
              "title": "Function Factory - Creating Custom Functions with Closures",
              "code": "// Function factory to create power functions\nfunction powerFactory(exponent) {\n  return function(base) { // Returns a function that calculates base to the power of exponent\n    return Math.pow(base, exponent);\n  };\n}\n\nconst square = powerFactory(2); // Create a squaring function\nconst cube = powerFactory(3);   // Create a cubing function\n\nconsole.log('5 squared:', square(5)); // Use the squaring function\nconsole.log('4 cubed:', cube(4));    // Use the cubing function\n\n// Experiment with creating different power functions using powerFactory and different exponents."
            }
          ]
        },
        {
          "id": "interview-js-concept-5",
          "title": "Prototypal Inheritance vs Class Inheritance",
          "description": "Compare and contrast prototypal inheritance in JavaScript with class-based inheritance (like in Java or C++), and understand ES6 classes as syntactic sugar.",
          "difficulty": "advanced",
          "category": "objects",
          "explanation": "JavaScript uses prototypal inheritance, a distinct model from class-based inheritance found in languages like Java, C++, or Python. In prototypal inheritance, objects inherit properties and methods directly from other objects, known as prototypes. Inheritance is based on delegation; when you try to access a property of an object, and it's not found directly on that object, JavaScript delegates the lookup to the object's prototype, and so on, up the prototype chain.  In contrast, class-based inheritance relies on classes as blueprints for creating objects. Inheritance is defined through class hierarchies; a class can inherit from another class, inheriting its properties and methods. Instances of classes are created based on these class definitions.  ES6 introduced classes in JavaScript, but it's crucial to understand that JavaScript classes are syntactic sugar over prototypal inheritance. They provide a more familiar syntax for developers coming from class-based languages but do not fundamentally change JavaScript's inheritance model. Under the hood, ES6 classes still use prototypes to establish inheritance relationships. Key differences and points to consider: Inheritance mechanism: Prototypal inheritance is object-based, relying on delegation through prototype chains. Class-based inheritance is type-based, defined by class hierarchies and type relationships. Class vs. Prototype: Class-based languages use classes as blueprints. JavaScript uses prototypes, which are themselves objects, to inherit from. Instantiation: In class-based languages, objects are instances of classes. In JavaScript, objects inherit directly from prototype objects. Flexibility: Prototypal inheritance is often seen as more flexible and dynamic, allowing for runtime modification of object inheritance. Class-based inheritance is typically more rigid and structured, defined at compile time. ES6 classes in JavaScript offer a more structured syntax for creating objects and inheritance hierarchies, making it easier for developers familiar with class-based languages to work with JavaScript, while still being fundamentally prototypal.",
          "example": "// Prototypal Inheritance (using Object.create)\nconst animalPrototype = {\n  speak: function() {\n    return 'Generic animal sound';\n  }\n};\n\nconst dog = Object.create(animalPrototype);\ndog.breed = 'Labrador';\ndog.speak = function() {\n  return 'Woof!'; // Method overriding\n};\n\nconsole.log('Dog breed:', dog.breed); // Output: Labrador (own property)\nconsole.log('Dog sound:', dog.speak()); // Output: Woof! (overridden method)\nconsole.log('Animal prototype sound:', animalPrototype.speak()); // Output: Generic animal sound\nconsole.log('Is dog.__proto__ === animalPrototype:', Object.getPrototypeOf(dog) === animalPrototype); // Output: true\n\n// Class-based syntax (ES6 Classes) - Syntactic sugar over prototypes\nclass AnimalClass {\n  constructor(name) {\n    this.name = name;\n  }\n  speak() {\n    return 'Generic animal sound';\n  }\n}\n\nclass DogClass extends AnimalClass {\n  constructor(name, breed) {\n    super(name); // Call constructor of parent class\n    this.breed = breed;\n  }\n  speak() {\n    return 'Woof!'; // Method overriding in class syntax\n  }\n}\n\nconst cat = new AnimalClass('Cat');\nconst germanShepherd = new DogClass('German Shepherd', 'Shepherd');\n\nconsole.log('Cat name:', cat.name); // Output: Cat\nconsole.log('Cat sound:', cat.speak()); // Output: Generic animal sound\nconsole.log('German Shepherd name:', germanShepherd.name); // Output: German Shepherd\nconsole.log('German Shepherd breed:', germanShepherd.breed); // Output: Shepherd\nconsole.log('German Shepherd sound:', germanShepherd.speak()); // Output: Woof!\nconsole.log('Is GermanShepherd instanceof DogClass:', germanShepherd instanceof DogClass); // Output: true\nconsole.log('Is GermanShepherd instanceof AnimalClass:', germanShepherd instanceof AnimalClass); // Output: true",
          "keyPoints": [
            "JavaScript uses prototypal inheritance, where objects inherit from other objects (prototypes), unlike class-based inheritance which uses classes as blueprints.",
            "In prototypal inheritance, inheritance is based on delegation through the prototype chain. Objects inherit properties and methods directly from their prototype objects.",
            "Class-based inheritance, common in languages like Java and C++, uses classes to define object types and inheritance hierarchies. Objects are instances of classes.",
            "ES6 classes in JavaScript provide a class-based syntax but are fundamentally syntactic sugar over prototypal inheritance. They do not introduce a new inheritance model.",
            "Prototypal inheritance is object-centric and more dynamic, allowing for runtime modification of inheritance. Class-based inheritance is more type-centric and structured, often defined at compile time.",
            "In JavaScript, prototypes are objects themselves, which objects inherit from. In class-based languages, classes are blueprints, not objects themselves.",
            "`Object.create(proto)` is a fundamental way to establish prototypal inheritance, creating a new object with `proto` as its prototype.",
            "ES6 classes use keywords like `class`, `constructor`, `extends`, and `super` to mimic class-based syntax, making inheritance more familiar to developers from class-based backgrounds.",
            "Understanding both prototypal and class-based concepts is important for JavaScript developers, especially when working with modern JavaScript frameworks and libraries that often use class syntax while still operating on prototypes."
          ],
          "quiz": [
            {
              "question": "What is the fundamental inheritance mechanism in JavaScript?",
              "options": ["Class-based inheritance", "Interface-based inheritance", "Prototypal inheritance", "Multiple inheritance"],
              "correctAnswer": 2
            },
            {
              "question": "Are ES6 classes in JavaScript fundamentally class-based or prototypal?",
              "options": ["Class-based", "Prototypal", "A hybrid of both", "Neither, they are a new type of inheritance"],
              "correctAnswer": 1
            },
            {
              "question": "In prototypal inheritance, what do objects inherit from?",
              "options": ["Classes", "Interfaces", "Other objects (prototypes)", "Abstract data types"],
              "correctAnswer": 2
            },
            {
              "question": "What does `Object.create(proto)` do in JavaScript?",
              "options": ["Creates a new class", "Creates a new object that inherits from `proto`", "Modifies the prototype of an existing object", "Deletes the prototype of an object"],
              "correctAnswer": 1
            },
            {
              "question": "Which type of inheritance is generally considered more dynamic and flexible?",
              "options": ["Class-based inheritance", "Prototypal inheritance", "Both are equally flexible", "Neither is flexible"],
              "correctAnswer": 1
            }
          ],
          "interactiveExamples": [
            {
              "title": "Prototypal Inheritance - Creating Objects and Prototypes",
              "code": "// Define a prototype object\nconst vehiclePrototype = {\n  startEngine: function() {\n    return 'Engine started';\n  },\n  stopEngine: function() {\n    return 'Engine stopped';\n  }\n};\n\n// Create a car object inheriting from vehiclePrototype\nconst carObject = Object.create(vehiclePrototype);\ncarObject.wheels = 4;\ncarObject.drive = function() {\n  return 'Car is driving';\n};\n\n// Create a motorcycle object inheriting from vehiclePrototype\nconst motorcycleObject = Object.create(vehiclePrototype);\nmotorcycleObject.wheels = 2;\nmotorcycleObject.lean = function() {\n  return 'Motorcycle is leaning';\n};\n\nconsole.log('Car starts engine:', carObject.startEngine());\nconsole.log('Motorcycle stops engine:', motorcycleObject.stopEngine());\nconsole.log('Car drives:', carObject.drive());\nconsole.log('Motorcycle leans:', motorcycleObject.lean());\n\n// Inspect carObject and motorcycleObject prototypes in console to see inheritance"
            },
            {
              "title": "ES6 Class Syntax - Implementing Inheritance with Classes",
              "code": "// Define a base class\nclass Shape {\n  constructor(color) {\n    this.color = color;\n  }\n  getColor() {\n    return this.color;\n  }\n}\n\n// Define a subclass inheriting from Shape\nclass Circle extends Shape {\n  constructor(color, radius) {\n    super(color); // Call superclass constructor\n    this.radius = radius;\n  }\n  getArea() {\n    return Math.PI * this.radius * this.radius;\n  }\n}\n\nconst myCircle = new Circle('red', 5);\nconsole.log('Circle color:', myCircle.getColor());\nconsole.log('Circle area:', myCircle.getArea());\nconsole.log('Is myCircle instanceof Circle:', myCircle instanceof Circle); // Check instanceof\nconsole.log('Is myCircle instanceof Shape:', myCircle instanceof Shape);   // Check instanceof for parent class\n\n// Experiment by creating more shapes and subclasses to understand class inheritance syntax"
            }
          ]
        },
        {
          "id": "interview-js-concept-6",
          "title": "First-Class Functions",
          "description": "Explain the concept of first-class functions in JavaScript and their implications for functional programming and higher-order functions.",
          "difficulty": "intermediate",
          "category": "functions",
          "explanation": "In JavaScript, functions are considered first-class citizens, meaning they are treated like any other value. This is a core concept that underpins functional programming in JavaScript and enables powerful patterns. First-class functions can be: Assigned to variables, Passed as arguments to other functions, Returned as values from other functions, Stored in data structures like arrays and objects. This capability allows for higher-order functions (functions that operate on other functions, either by taking them as arguments or returning them), function composition, and more flexible and modular code design. Understanding first-class functions is essential for grasping functional programming paradigms in JavaScript, such as map, filter, reduce, and for working with callbacks and promises.",
          "example": "// Assigning a function to a variable\nconst greet = function(name) {\n  return `Hello, ${name}!`;\n};\nconsole.log(greet('Alice')); // Output: Hello, Alice!\n\n// Passing a function as an argument (callback)\nfunction operateOnGreeting(greetingFunction, name) {\n  return greetingFunction(name);\n}\nconsole.log(operateOnGreeting(greet, 'Bob')); // Output: Hello, Bob!\n\n// Returning a function from another function (function factory)\nfunction createMultiplier(factor) {\n  return function(number) {\n    return number * factor;\n  };\n}\nconst multiplyBy5 = createMultiplier(5);\nconsole.log(multiplyBy5(3)); // Output: 15\n\n// Storing functions in an array\nconst functionArray = [greet, createMultiplier(2)];\nconsole.log(functionArray[0]('Charlie')); // Output: Hello, Charlie!\nconsole.log(functionArray[1](4));       // Output: 8",
          "keyPoints": [
            "Functions in JavaScript are first-class citizens, treated as values.",
            "First-class functions can be assigned to variables, passed as arguments, and returned from other functions.",
            "This enables higher-order functions, which are central to functional programming.",
            "First-class functions support function composition and modular code.",
            "Understanding this concept is crucial for callbacks, promises, and functional programming techniques in JavaScript."
          ],
          "quiz": [
            {
              "question": "What does it mean for functions to be 'first-class citizens' in JavaScript?",
              "options": ["Functions are the most important part of the language", "Functions can be treated like any other data type", "Functions are always executed before other code", "Functions cannot be modified after creation"],
              "correctAnswer": 1
            },
            {
              "question": "Which of the following is NOT a characteristic of first-class functions?",
              "options": ["Can be assigned to variables", "Can be passed as arguments to other functions", "Can be returned from other functions", "Must be declared before they are used"],
              "correctAnswer": 3
            },
            {
              "question": "What is a higher-order function?",
              "options": ["A function that executes very quickly", "A function that is more complex than other functions", "A function that operates on other functions", "A function that is defined inside another function"],
              "correctAnswer": 2
            },
            {
              "question": "Why are first-class functions important in JavaScript?",
              "options": ["They make code harder to understand", "They enable object-oriented programming", "They enable functional programming and flexible code design", "They are only important for advanced JavaScript concepts"],
              "correctAnswer": 2
            },
            {
              "question": "Which of the following is an example of using first-class functions?",
              "options": ["Using a for loop", "Declaring a variable", "Passing a callback function to `addEventListener`", "Creating an object"],
              "correctAnswer": 2
            }
          ],
          "interactiveExamples": [
            {
              "title": "Function as Argument - Callback Example",
              "code": "// Function that takes another function as an argument (callback)\nfunction processArray(arr, callback) {\n  const result = [];\n  for (let i = 0; i < arr.length; i++) {\n    result.push(callback(arr[i]));\n  }\n  return result;\n}\n\n// Callback function to square a number\nfunction squareNumber(num) {\n  return num * num;\n}\n\nconst numbers = [1, 2, 3, 4, 5];\nconst squaredNumbers = processArray(numbers, squareNumber);\nconsole.log('Original numbers:', numbers);\nconsole.log('Squared numbers:', squaredNumbers);\n\n// Experiment with different callback functions (e.g., cube, double) in processArray"
            },
            {
              "title": "Function as Return Value - Function Factory",
              "code": "// Function factory to create greeting functions for different times of day\nfunction createGreeting(timeOfDay) {\n  if (timeOfDay === 'morning') {\n    return function(name) {\n      return `Good morning, ${name}!`;\n    };\n  } else if (timeOfDay === 'evening') {\n    return function(name) {\n      return `Good evening, ${name}!`;\n    };\n  } else {\n    return function(name) {\n      return `Hello, ${name}!`;\n    };\n  }\n}\n\nconst morningGreeting = createGreeting('morning');\nconst eveningGreeting = createGreeting('evening');\nconst genericGreeting = createGreeting('afternoon'); // No specific time\n\nconsole.log(morningGreeting('David'));\nconsole.log(eveningGreeting('Eve'));\nconsole.log(genericGreeting('Frank'));\n\n// Modify createGreeting to add more time-specific greetings or different greeting styles"
            }
          ]
        },
        {
          "id": "interview-js-concept-7",
          "title": "Pure Functions and Side Effects",
          "description": "Explain pure functions in JavaScript, their benefits, and contrast them with functions that produce side effects.",
          "difficulty": "intermediate",
          "category": "functions",
          "explanation": "Pure functions are a cornerstone of functional programming. A pure function in JavaScript (and programming in general) has two key properties: 1. Deterministic: Given the same input(s), it will always return the same output. 2. No Side Effects: It does not cause any observable side effects outside of its scope. Side effects are any changes to the state of the application that are observable outside of the function's scope, such as: Modifying global variables, Changing object properties passed as arguments, Performing I/O operations (like console logging, network requests, file system access), Triggering events or DOM manipulations. Pure functions are beneficial because they are predictable, easier to test, and promote modularity and code reusability. They simplify debugging and make it easier to reason about the program's behavior. In contrast, functions with side effects are often harder to test and can lead to more complex and less predictable code. While side effects are necessary in most applications (to interact with the outside world), minimizing them and clearly separating pure and impure functions leads to cleaner and more maintainable code.",
          "example": "// Pure function - No side effects, deterministic\nfunction addPure(a, b) {\n  return a + b; // Always returns the same output for the same inputs, no side effects\n}\nconsole.log('Pure function addPure(5, 2):', addPure(5, 2)); // Output: 7\n\n// Impure function - Side effect: Modifies external variable\nlet impureValue = 10;\nfunction addImpure(a) {\n  impureValue += a; // Side effect: Modifies 'impureValue' outside function scope\n  return impureValue;\n}\nconsole.log('Impure function addImpure(5):', addImpure(5)); // Output: 15, and 'impureValue' is now changed\nconsole.log('Impure function addImpure(3) again:', addImpure(3)); // Output: 18, output depends on previous calls due to side effect\n\n// Impure function - Side effect: console.log (I/O)\nfunction logAndReturn(value) {\n  console.log('Logging:', value); // Side effect: I/O operation (console log)\n  return value;\n}\nlogAndReturn('Hello'); // Output: Logs 'Logging: Hello' to console, returns 'Hello'\n\n// Pure function example - Operating on objects without mutation\nfunction incrementObjectPropertyPure(obj, propertyName) {\n  return { ...obj, [propertyName]: obj[propertyName] + 1 }; // Returns a new object with incremented property, no mutation\n}\nconst myObjectPure = { count: 0 };\nconst newObjectPure = incrementObjectPropertyPure(myObjectPure, 'count');\nconsole.log('Original object (pure):', myObjectPure); // Output: { count: 0 } (unchanged)\nconsole.log('New object (pure):', newObjectPure);    // Output: { count: 1 } (new object with incremented count)\n\n// Impure function example - Mutating object property\nfunction incrementObjectPropertyImpure(obj, propertyName) {\n  obj[propertyName]++; // Side effect: Mutates the original object\n  return obj;\n}\nconst myObjectImpure = { count: 0 };\nconst modifiedObjectImpure = incrementObjectPropertyImpure(myObjectImpure, 'count');\nconsole.log('Original object (impure) after function:', myObjectImpure); // Output: { count: 1 } (mutated)\nconsole.log('Returned object (impure):', modifiedObjectImpure);       // Output: { count: 1 } (same object as original, mutated)",
          "keyPoints": [
            "Pure functions are deterministic (same input always yields the same output) and have no side effects.",
            "Side effects are actions that change the program's state outside the function's scope (e.g., modifying globals, I/O, DOM manipulation).",
            "Pure functions are easier to test, debug, and reason about due to their predictability.",
            "They promote modularity and reusability, making code more maintainable.",
            "Functions with side effects (impure functions) are necessary for application functionality but should be managed carefully.",
            "Separating pure and impure functions improves code clarity and testability.",
            "Immutability and avoiding mutation are key principles in writing pure functions, especially when dealing with objects and arrays."
          ],
          "quiz": [
            {
              "question": "What are the two key characteristics of a pure function?",
              "options": ["Fast execution and no side effects", "Deterministic and no side effects", "Simple logic and deterministic", "No arguments and deterministic"],
              "correctAnswer": 1
            },
            {
              "question": "Which of the following is NOT considered a side effect?",
              "options": ["Modifying a global variable", "Logging to the console", "Returning a value based on input arguments", "Changing a property of an object passed as an argument"],
              "correctAnswer": 2
            },
            {
              "question": "Why are pure functions beneficial in programming?",
              "options": ["They are always faster than impure functions", "They are easier to test and debug", "They can directly modify the DOM", "They automatically handle asynchronous operations"],
              "correctAnswer": 1
            },
            {
              "question": "Which of the following functions is likely to be impure?",
              "options": ["`function add(a, b) { return a + b; }`", "`function doubleArray(arr) { return arr.map(x => x * 2); }`", "`function setGlobalCount(value) { globalCount = value; }`", "`function toUpperCase(str) { return str.toUpperCase(); }`"],
              "correctAnswer": 2
            },
            {
              "question": "How can you make a function that modifies an object property pure?",
              "options": ["By modifying the object directly but ensuring the function is fast", "By returning a new object with the modified property instead of changing the original object", "It's impossible to make a function that modifies an object property pure", "By using strict mode in JavaScript"],
              "correctAnswer": 1
            }
          ],
          "interactiveExamples": [
            {
              "title": "Identifying Pure vs Impure Functions - Code Snippet Analysis",
              "code": "// Function 1: Is it pure or impure?\nlet externalState = 0;\nfunction exampleFunction1(input) {\n  externalState += input;\n  return externalState;\n}\nconsole.log('Function 1 - First call:', exampleFunction1(5));\nconsole.log('Function 1 - Second call:', exampleFunction1(3));\n\n// Function 2: Is it pure or impure?\nfunction exampleFunction2(input) {\n  return input * 2;\n}\nconsole.log('Function 2 - First call:', exampleFunction2(5));\nconsole.log('Function 2 - Second call:', exampleFunction2(5));\n\n// Function 3: Is it pure or impure?\nfunction exampleFunction3(arr) {\n  arr.push(10); // Modifies the array directly\n  return arr;\n}\nconst myArray = [1, 2, 3];\nconsole.log('Function 3 - First call:', exampleFunction3(myArray));\nconsole.log('Function 3 - Second call:', exampleFunction3(myArray));\n\n// Analyze each function and determine if they are pure or impure based on their behavior and side effects"
            },
            {
              "title": "Refactoring Impure Function to Pure - Object Modification",
              "code": "// Impure function (mutates object)\nfunction impureUpdateName(person, newName) {\n  person.name = newName; // Mutates the person object\n  return person;\n}\nconst personObject = { name: 'Original Name' };\nconst updatedPersonImpure = impureUpdateName(personObject, 'New Name');\nconsole.log('Impure - Original object mutated:', personObject);\n\n// Pure function (returns new object)\nfunction pureUpdateName(person, newName) {\n  return { ...person, name: newName }; // Creates a new object with updated name\n}\nconst personObjectPure = { name: 'Original Name' };\nconst updatedPersonPure = pureUpdateName(personObjectPure, 'New Name');\nconsole.log('Pure - Original object unchanged:', personObjectPure);\nconsole.log('Pure - New object returned:', updatedPersonPure);\n\n// Compare the impure and pure versions and observe how purity is achieved by avoiding mutation and returning new values"
            }
          ]
        },
        {
          "id": "interview-js-concept-8",
          "title": "Memoization",
          "description": "Explain memoization in JavaScript, how it optimizes performance, and implement a memoized function.",
          "difficulty": "advanced",
          "category": "performance",
          "explanation": "Memoization is a powerful optimization technique used in programming to speed up execution by caching the results of expensive function calls and returning the cached result when the same inputs occur again. In JavaScript, memoization can be implemented by storing the inputs and their corresponding outputs of a function in a cache (typically a JavaScript object or Map). When the memoized function is called, it first checks if the inputs are already in the cache. If yes, it returns the cached output directly, avoiding redundant computations. If not, it computes the result, stores it in the cache for future use, and then returns the computed result. Memoization is most effective for functions that are: Pure: The function's output depends only on its inputs and has no side effects. Expensive to compute: The function performs time-consuming calculations. Called repeatedly with the same inputs: The function is invoked multiple times with the same argument values. Common use cases for memoization include recursive functions, computationally intensive operations, and functions that fetch data from external sources. Memoization can significantly improve performance by reducing redundant computations, especially in scenarios with overlapping subproblems or repeated calls with identical inputs.",
          "example": "// Non-memoized function - Calculating Fibonacci number (inefficient)\nfunction fibonacci(n) {\n  if (n <= 1) return n;\n  return fibonacci(n - 1) + fibonacci(n - 2); // Repeated computations for same values\n}\nconsole.time('fibonacciNonMemoized');\nconsole.log('Fibonacci(40) non-memoized:', fibonacci(40));\nconsole.timeEnd('fibonacciNonMemoized'); // Measures time taken for non-memoized version\n\n// Memoized function - Using caching to store results\nfunction memoizedFibonacci() {\n  const cache = {}; // Cache to store results\n  return function(n) {\n    if (n in cache) {\n      return cache[n]; // Return cached result if available\n    } else {\n      if (n <= 1) {\n        return n;\n      } else {\n        const result = fibonacciMemoized(n - 1) + fibonacciMemoized(n - 2); // Recursive call to memoized version\n        cache[n] = result; // Store result in cache before returning\n        return result;\n      }\n    }\n  };\n}\n\nconst fibonacciMemoized = memoizedFibonacci();\nconsole.time('fibonacciMemoized');\nconsole.log('Fibonacci(40) memoized:', fibonacciMemoized(40));\nconsole.timeEnd('fibonacciMemoized'); // Measures time taken for memoized version\n\n// Compare the execution times - memoized version will be significantly faster for larger inputs.",
          "keyPoints": [
            "Memoization is an optimization technique to cache and reuse results of expensive function calls based on inputs.",
            "It works by storing input-output pairs in a cache (e.g., object, Map).",
            "When a memoized function is called, it first checks the cache for the input; if found, it returns the cached result.",
            "If the input is not in the cache, the function computes the result, caches it, and then returns it.",
            "Memoization is most effective for pure, expensive functions that are repeatedly called with the same inputs.",
            "It significantly improves performance by reducing redundant computations, especially in recursive functions and computationally intensive tasks.",
            "Implementation typically involves using a closure to hold the cache and checking the cache before performing computations.",
            "Consider memory usage implications as the cache can grow with unique inputs. Cache eviction strategies may be needed for very large caches."
          ],
          "quiz": [
            {
              "question": "What is memoization primarily used for in programming?",
              "options": ["To reduce code complexity", "To optimize function performance by caching results", "To improve code readability", "To handle errors in function calls"],
              "correctAnswer": 1
            },
            {
              "question": "When is memoization most effective?",
              "options": ["For functions that are called only once", "For functions with side effects", "For pure functions that are expensive to compute and called repeatedly with the same inputs", "For functions that perform simple calculations"],
              "correctAnswer": 2
            },
            {
              "question": "How does memoization typically store cached results?",
              "options": ["In global variables", "In local variables within the function", "In a cache, often a JavaScript object or Map, associated with the memoized function", "In the browser's local storage"],
              "correctAnswer": 2
            },
            {
              "question": "What happens when a memoized function is called with inputs that are already in the cache?",
              "options": ["The function re-computes the result and updates the cache", "The function returns an error because the input is duplicated", "The function returns the cached result directly, without re-computation", "The function ignores the cache and always re-computes the result"],
              "correctAnswer": 2
            },
            {
              "question": "Which of the following is a key characteristic of functions that are good candidates for memoization?",
              "options": ["They are impure and have side effects", "They are called very infrequently", "They are computationally inexpensive", "They are pure and computationally expensive"],
              "correctAnswer": 3
            }
          ],
          "interactiveExamples": [
            {
              "title": "Implement Memoization - Generic Memoize Function",
              "code": "// Generic memoization function (higher-order function)\nfunction memoize(func) {\n  const cache = {};\n  return function(...args) {\n    const key = JSON.stringify(args); // Create a unique key from arguments\n    if (cache[key]) {\n      console.log('Cache hit for:', key);\n      return cache[key]; // Return cached result\n    } else {\n      console.log('Cache miss, computing for:', key);\n      const result = func.apply(this, args); // Compute result\n      cache[key] = result; // Store result in cache\n      return result;\n    }\n  };\n}\n\n// Example function to memoize (simulating expensive operation)\nfunction expensiveFunction(a, b) {\n  console.log('Executing expensiveFunction with:', a, b);\n  return a + b;\n}\n\nconst memoizedExpensiveFunction = memoize(expensiveFunction);\nconsole.log('First call:', memoizedExpensiveFunction(5, 3));\nconsole.log('Second call (same args):', memoizedExpensiveFunction(5, 3)); // Should be faster due to cache\nconsole.log('Third call (different args):', memoizedExpensiveFunction(2, 7));\n\n// Experiment with different functions and arguments to test the generic memoize function"
            },
            {
              "title": "Memoization with Different Data Types as Arguments",
              "code": "// Memoized function that handles different data types in arguments\nfunction memoizedFunctionWithTypes() {\n  const cache = new Map(); // Using Map for more flexible key types\n  return function(...args) {\n    const key = args.join('-'); // Simple key for demonstration (consider more robust key generation for complex objects)\n    if (cache.has(key)) {\n      console.log('Cache hit for:', key);\n      return cache.get(key); // Get from Map\n    } else {\n      console.log('Cache miss, computing for:', key);\n      // Simulate operation with different types\n      const result = args.reduce((acc, val) => acc + String(val), ''); // Concatenate arguments as strings\n      cache.set(key, result); // Set in Map\n      return result;\n    }\n  };\n}\n\nconst typeMemoizedFunc = memoizedFunctionWithTypes();\nconsole.log('Call with numbers:', typeMemoizedFunc(1, 2, 3));\nconsole.log('Call with strings:', typeMemoizedFunc('a', 'b'));\nconsole.log('Call with mixed types:', typeMemoizedFunc(1, 'x', 2));\nconsole.log('Repeat call with numbers:', typeMemoizedFunc(1, 2, 3)); // Cache hit\n\n// Test with various argument types (numbers, strings, booleans) to see memoization in action"
            }
          ]
        },
        {
          "id": "interview-js-concept-9",
          "title": "Promises and Async/Await Internals",
          "description": "Explain the internal workings of Promises and Async/Await in JavaScript, including the event loop interaction and microtask queue.",
          "difficulty": "advanced",
          "category": "async",
          "explanation": "Promises and Async/Await are essential for handling asynchronous operations in JavaScript. Understanding their internals is key to mastering asynchronous programming. Promises are objects representing the eventual result of an asynchronous operation. They can be in one of three states: pending, fulfilled (resolved with a value), or rejected (with a reason). When a Promise is created, it's in a pending state. Upon completion of the async operation, it transitions to either fulfilled or rejected. Promises use a `.then()` method for handling fulfillment and `.catch()` for handling rejection. These handlers are added to a microtask queue. Async/Await is syntactic sugar built on top of Promises, making asynchronous code look and behave more like synchronous code. An `async` function implicitly returns a Promise. The `await` keyword inside an `async` function pauses the execution of that function until the Promise it's awaiting resolves (or rejects).  The Event Loop and Microtask Queue: JavaScript's event loop is responsible for handling asynchronous operations without blocking the main thread. When an asynchronous operation (like a Promise resolution) completes, its associated callback (e.g., `.then()` handler) is placed in the microtask queue (also known as the Promise job queue). The microtask queue has higher priority than the macrotask queue (used for tasks like `setTimeout`, `setInterval`, and I/O events). After the call stack is empty, the event loop first processes all tasks in the microtask queue before moving to macrotasks or rendering updates. This ensures that Promise callbacks and `async/await` operations are processed promptly and in order. Understanding this interaction is crucial for predicting the execution order of asynchronous JavaScript code and optimizing performance.",
          "example": "// Promise example - demonstrating microtask queue\nconsole.log('Start of script');\n\nconst promise = new Promise((resolve) => {\n  console.log('Promise constructor executed');\n  resolve('Promise resolved');\n});\n\npromise.then((value) => {\n  console.log('Promise then handler:', value); // Microtask\n});\n\nsetTimeout(() => {\n  console.log('SetTimeout callback'); // Macrotask\n}, 0);\n\nconsole.log('End of script');\n\n// Async/Await example - syntactic sugar over Promises\nasync function asyncFunction() {\n  console.log('Async function started');\n  await Promise.resolve(); // Awaiting a resolved promise\n  console.log('Async function after await'); // Resumes after microtask\n  return 'Async function resolved';\n}\n\nasyncFunction().then((result) => {\n  console.log('Async function .then:', result); // Microtask\n});\n\nconsole.log('Script after async function call');\n\n// Observe the output order to understand microtask queue priority over macrotask and synchronous code flow.",
          "keyPoints": [
            "Promises represent the eventual result of asynchronous operations and can be in pending, fulfilled, or rejected states.",
            "`.then()` and `.catch()` methods of Promises add handlers to the microtask queue to be executed upon resolution or rejection.",
            "Async/Await is syntactic sugar over Promises, simplifying asynchronous code and making it look synchronous.",
            "`async` functions implicitly return Promises, and `await` pauses execution until a Promise resolves.",
            "JavaScript's event loop manages asynchronous operations and uses microtask and macrotask queues.",
            "The microtask queue (Promise job queue) has higher priority than the macrotask queue (e.g., `setTimeout`, I/O).",
            "Promise handlers and `async/await` continuations are added to the microtask queue and processed after the call stack is empty, before macrotasks.",
            "Understanding the microtask queue and event loop interaction is crucial for predicting asynchronous code execution order and performance optimization."
          ],
          "quiz": [
            {
              "question": "What is the microtask queue in JavaScript's event loop primarily used for?",
              "options": ["Handling `setTimeout` and `setInterval` callbacks", "Processing Promise resolution and rejection handlers", "Managing user input events", "Executing synchronous code"],
              "correctAnswer": 1
            },
            {
              "question": "Which of the following is true about the priority of microtasks and macrotasks in the event loop?",
              "options": ["Macrotasks have higher priority than microtasks", "Microtasks and macrotasks have equal priority", "Microtasks have higher priority than macrotasks", "The priority depends on the browser implementation"],
              "correctAnswer": 2
            },
            {
              "question": "What state is a Promise in when it is first created?",
              "options": ["Fulfilled", "Rejected", "Resolved", "Pending"],
              "correctAnswer": 3
            },
            {
              "question": "What does the `await` keyword do in an `async` function?",
              "options": ["It makes the function run synchronously", "It pauses the execution of the `async` function until a Promise resolves", "It immediately resolves a Promise", "It throws an error if a Promise is rejected"],
              "correctAnswer": 1
            },
            {
              "question": "Which of the following is an example of a task that is typically placed in the macrotask queue?",
              "options": ["Promise `.then()` handler", "Promise `.catch()` handler", "`setTimeout` callback", "Callback from a microtask"],
              "correctAnswer": 2
            }
          ],
          "interactiveExamples": [
            {
              "title": "Event Loop and Queue Order - Microtasks vs Macrotasks",
              "code": "console.log('Synchronous task 1');\n\nsetTimeout(() => {\n  console.log('Macrotask (setTimeout)');\n}, 0);\n\nPromise.resolve().then(() => {\n  console.log('Microtask (Promise)');\n});\n\nconsole.log('Synchronous task 2');\n\n// Analyze the output order. Notice that microtask from Promise resolves before macrotask from setTimeout, even though both are set with 0 delay."
            },
            {
              "title": "Chaining Promises and Microtask Queue",
              "code": "Promise.resolve('Initial Promise')\n  .then((value) => {\n    console.log('Promise then 1:', value);\n    return Promise.resolve('Promise from then 1'); // Chaining another promise\n  })\n  .then((value) => {\n    console.log('Promise then 2:', value);\n  });\n\nsetTimeout(() => {\n  console.log('Macrotask (setTimeout) - after promises');\n}, 0);\n\nconsole.log('Synchronous task after promise chain');\n\n// Observe the order of execution. All promise .then handlers (microtasks) resolve before the setTimeout macrotask, demonstrating microtask queue processing."
            }
          ]
        },
        {
          "id": "interview-js-concept-10",
          "title": "JavaScript Memory Management and Garbage Collection",
          "description": "Explain JavaScript's memory management model, garbage collection process, and how to avoid memory leaks.",
          "difficulty": "advanced",
          "category": "performance",
          "explanation": "JavaScript is a language with automatic memory management, primarily through garbage collection. Memory management in JavaScript involves allocating memory when objects are created and freeing up memory when objects are no longer needed. This is largely handled automatically by the JavaScript engine's garbage collector, relieving developers from manual memory allocation and deallocation, unlike languages like C or C++.  Garbage Collection Process: JavaScript uses a mark-and-sweep garbage collection algorithm. The process roughly involves: Mark Phase: The garbage collector starts from the root objects (global objects like `window` in browsers) and 'marks' them as reachable. It then recursively traverses through all objects reachable from these root objects and marks them as well. Any object that is reachable (directly or indirectly) from a root object is considered 'live'. Sweep Phase: After marking, the garbage collector sweeps through the memory, collecting (freeing) the memory occupied by objects that were not marked as reachable. These unmarked objects are considered 'garbage' as they are no longer accessible by the program. Reference Counting: Historically, JavaScript also used reference counting, where each object had a count of references pointing to it. When the reference count became zero, the object was considered garbage. However, reference counting alone couldn't handle circular references (where objects reference each other, preventing their counts from ever reaching zero), which is why mark-and-sweep is now the primary method. Avoiding Memory Leaks: Despite automatic garbage collection, memory leaks can still occur in JavaScript, primarily due to: Accidental Global Variables: Creating variables without `var`, `let`, or `const` in non-strict mode makes them global, and they persist until the page/application is closed. Forgotten Timers and Callbacks: If `setTimeout` or `setInterval` callbacks or event listeners are not properly cleared or removed when they are no longer needed, they can keep referencing objects, preventing garbage collection. Closures: While powerful, closures can unintentionally keep variables from their outer scope in memory longer than necessary if not managed properly. Out-of-DOM References: Keeping references to DOM elements that have been removed from the DOM tree in JavaScript objects can prevent them from being garbage collected. Understanding JavaScript's memory management and being aware of potential memory leak sources helps in writing efficient and performant applications.",
          "example": "// Example demonstrating variable scope and garbage collection\nfunction createObject() {\n  let largeData = new Array(1000000).fill('large string'); // Simulate a large object\n  return function innerFunction() {\n    // Closure over largeData - prevents garbage collection as long as innerFunction is reachable\n    return largeData[0];\n  };\n}\n\nlet getFirstElement = createObject(); // 'getFirstElement' holds the innerFunction closure\n// 'largeData' is still in memory because 'getFirstElement' (closure) references it.\nconsole.log('First element of largeData:', getFirstElement());\n\ngetFirstElement = null; // Unreferencing the closure - now 'largeData' can be garbage collected in next cycle.\n// After setting getFirstElement to null, the closure and 'largeData' become eligible for garbage collection.\n\n// Example of potential memory leak - forgotten setTimeout (in browser environment)\n// function startTimerLeak() {\n//   let count = 0;\n//   setInterval(function() {\n//     count++;\n//     console.log('Timer count:', count);\n//     // If this interval is not cleared, 'count' and the interval callback will persist, potentially leaking memory.\n//   }, 1000);\n// }",
          "keyPoints": [
            "JavaScript uses automatic memory management via garbage collection, primarily using mark-and-sweep algorithm.",
            "Mark-and-sweep garbage collection identifies reachable objects starting from root objects and marks them as 'live'. Unmarked objects are considered garbage and their memory is freed.",
            "JavaScript also historically used reference counting, but mark-and-sweep is more effective at handling circular references.",
            "Memory leaks in JavaScript can occur due to accidental global variables, forgotten timers/callbacks, closures unintentionally holding onto variables, and out-of-DOM references.",
            "To avoid memory leaks: use strict mode to prevent accidental globals, clear timers/intervals using `clearInterval`/`clearTimeout`, manage closure scope carefully, and avoid holding unnecessary references to DOM elements after they are removed.",
            "Understanding variable scope, object lifecycle, and common leak patterns is crucial for writing memory-efficient JavaScript applications.",
            "Modern JavaScript engines are highly optimized for garbage collection, but being mindful of memory management best practices is still important, especially in long-running applications or those dealing with large amounts of data."
          ],
          "quiz": [
            {
              "question": "What type of memory management does JavaScript primarily use?",
              "options": ["Manual memory management", "Reference counting", "Garbage collection", "Operating system managed memory"],
              "correctAnswer": 2
            },
            {
              "question": "What is the main algorithm used by JavaScript garbage collectors?",
              "options": ["Reference counting", "Mark-and-sweep", "First-fit allocation", "Best-fit allocation"],
              "correctAnswer": 1
            },
            {
              "question": "What is the 'mark' phase in mark-and-sweep garbage collection?",
              "options": ["Deleting all unused variables", "Identifying and marking reachable objects", "Compressing memory to reduce fragmentation", "Releasing memory back to the operating system"],
              "correctAnswer": 1
            },
            {
              "question": "Which of the following is a common cause of memory leaks in JavaScript?",
              "options": ["Using `let` and `const` instead of `var`", "Using strict mode", "Accidental global variables", "Efficient use of closures"],
              "correctAnswer": 2
            },
            {
              "question": "How can you prevent memory leaks caused by timers in JavaScript?",
              "options": ["By using `clearTimeout` and `clearInterval` to stop timers when they are no longer needed", "By using `setTimeout` instead of `setInterval`", "Memory leaks from timers are automatically handled by garbage collection", "There is no way to prevent memory leaks from timers"],
              "correctAnswer": 0
            }
          ],
          "interactiveExamples": [
            {
              "title": "Simulating Memory Leak with Global Variable",
              "code": "// Example of accidental global variable leading to potential leak\nfunction createGlobalLeak() {\n  leakVariable = 'I am a global variable'; // Accidental global (no var, let, const in non-strict mode)\n  console.log('Global variable created:', leakVariable);\n}\n\ncreateGlobalLeak();\nconsole.log('Accessing global variable outside function:', leakVariable); // Global variable persists\n\n// In a browser, open developer tools and check memory usage over time after repeatedly calling createGlobalLeak(). Global variables persist and consume memory.\n\n// To fix, use 'use strict' mode or declare variables properly with let/const/var."
            },
            {
              "title": "Clearing Timers to Prevent Memory Leaks",
              "code": "// Example with setInterval and clearTimeout\nlet timerId;\nlet count = 0;\n\nfunction startTimer() {\n  timerId = setInterval(() => {\n    count++;\n    console.log('Timer count:', count);\n    if (count >= 5) {\n      stopTimer(); // Stop timer after 5 counts to prevent leak\n    }\n  }, 1000);\n}\n\nfunction stopTimer() {\n  clearInterval(timerId); // Clear the interval to free resources and prevent leak\n  console.log('Timer stopped and cleared.');\n}\n\nstartTimer();\n\n// Run and observe timer counting up to 5, then stopping and clearing. Without `clearInterval`, the interval would continue indefinitely, potentially leading to memory leaks in long-running applications."
            }
          ]
        },
        {
          "id": "interview-js-concept-11",
          "title": "Event Delegation",
          "description": "Explain event delegation in JavaScript, its advantages for performance and dynamic content, and how to implement it.",
          "difficulty": "intermediate",
          "category": "dom-events",
          "explanation": "Event delegation is a powerful technique in JavaScript DOM event handling that allows you to attach a single event listener to a parent element, rather than attaching event listeners to each of its children. The listener on the parent will then handle events for all descendants that match a selector, even those added dynamically in the future.  How it works: Event bubbling is the key mechanism behind event delegation. When an event occurs on a child element, it bubbles up the DOM tree to its parent elements. With event delegation, you listen for the event at a higher level (the parent). Inside the event handler, you can use `event.target` to identify the actual element that originated the event (the child element). Advantages of Event Delegation: Performance Improvement: Attaching fewer event listeners (just one on the parent instead of many on children) reduces memory consumption and improves page performance, especially when dealing with a large number of elements or dynamically added elements. Simplified Event Handling for Dynamic Content: When new child elements are added dynamically to the DOM, you don't need to attach new event listeners to them. The delegated listener on the parent automatically handles events for these new elements as well, as long as they are descendants of the parent and match the criteria in your handler. Cleaner and More Maintainable Code: Reduces code complexity by centralizing event handling logic in one place (the parent listener) instead of scattering listeners across multiple child elements. Common use cases for event delegation include handling events on lists, tables, menus, and any scenario where you have many similar interactive elements.",
          "example": "// HTML Structure (example list):\n// <ul id='itemList'>\n//   <li class='item'>Item 1</li>\n//   <li class='item'>Item 2</li>\n//   <li class='item'>Item 3</li>\n//   <!-- More list items can be added dynamically -->\n// </ul>\n\n// JavaScript - Event Delegation on the list\nconst itemList = document.getElementById('itemList');\n\nitemList.addEventListener('click', function(event) {\n  if (event.target && event.target.classList.contains('item')) { // Check if clicked element is a list item\n    console.log('List item clicked:', event.target.textContent);\n    // Perform action for clicked list item, e.g., highlight, remove, etc.\n    event.target.style.backgroundColor = 'lightyellow'; // Example action: Highlight clicked item\n    // Reset background after a short delay (for visual feedback)\n    setTimeout(() => {\n      event.target.style.backgroundColor = '';\n    }, 500);\n  }\n});\n\n// You can dynamically add more list items, and the event listener on 'itemList' will still handle clicks on them.\n// Example of dynamically adding a new item:\n// const newItem = document.createElement('li');\n// newItem.className = 'item';\n// newItem.textContent = 'Dynamically Added Item';\n// itemList.appendChild(newItem);",
          "keyPoints": [
            "Event delegation is a technique to handle events on many child elements by attaching a single listener to their parent.",
            "It leverages event bubbling: events on child elements bubble up to the parent.",
            "Use `event.target` inside the parent's event handler to identify the originating child element.",
            "Advantages: improved performance (fewer listeners), simplified handling of dynamic content, cleaner code.",
            "Delegated listeners on the parent automatically handle events for dynamically added child elements.",
            "Effective for lists, tables, menus, and any group of similar interactive elements.",
            "Improves memory efficiency and reduces DOM operations compared to attaching listeners to each child."
          ],
          "quiz": [
            {
              "question": "What is the core principle behind event delegation?",
              "options": ["Event capturing", "Event preventing", "Event bubbling", "Event propagation"],
              "correctAnswer": 2
            },
            {
              "question": "In event delegation, where do you attach the event listener?",
              "options": ["To each individual child element", "To the target element itself", "To a parent element of the target elements", "To the document root"],
              "correctAnswer": 2
            },
            {
              "question": "How do you identify the specific element that triggered the event in a delegated event handler?",
              "options": ["Using `this` keyword", "Using `event.currentTarget`", "Using `event.target`", "Using `event.relatedTarget`"],
              "correctAnswer": 2
            },
            {
              "question": "Which of the following is NOT an advantage of event delegation?",
              "options": ["Improved performance", "Simplified handling of dynamic content", "More complex code structure", "Cleaner code"],
              "correctAnswer": 2
            },
            {
              "question": "Event delegation is particularly useful when dealing with:",
              "options": ["Single, static elements", "Elements with very complex event handling logic", "Large numbers of similar, interactive elements, especially dynamic ones", "Elements that do not trigger events"],
              "correctAnswer": 2
            }
          ],
          "interactiveExamples": [
            {
              "title": "Event Delegation - Interactive List",
              "code": "// HTML structure (UL list - see example HTML in explanation)\nconst delegationItemList = document.getElementById('delegationItemList');\n\ndelegationItemList.addEventListener('click', function(event) {\n  if (event.target.tagName === 'LI') {\n    event.target.classList.toggle('active'); // Toggle 'active' class on clicked LI\n  }\n});\n\n// Dynamically add list items (for demonstration)\nconst addButton = document.getElementById('addItemButton');\nlet itemCount = 4;\naddButton.addEventListener('click', function() {\n  const newItem = document.createElement('li');\n  newItem.textContent = `Item ${itemCount++}`;\n  delegationItemList.appendChild(newItem);\n});\n\n// Click on list items to toggle 'active' class, and add new items using the button. Event delegation handles events for both initial and dynamically added items."
            },
            {
              "title": "Event Delegation vs. Direct Event Handlers - Performance Comparison (Conceptual)",
              "code": "// Conceptual example - not directly runnable as is, for performance understanding\n\n// Scenario 1: Direct event handlers on many items (less efficient)\n// Imagine creating 1000 list items and attaching click listeners to each\n// for (let i = 0; i < 1000; i++) {\n//   const listItem = document.createElement('li');\n//   listItem.textContent = `Item ${i + 1}`;\n//   listItem.addEventListener('click', function() { /* handler code */ }); // 1000 listeners\n//   document.getElementById('itemsContainer').appendChild(listItem);\n// }\n\n// Scenario 2: Event delegation (more efficient)\n// Attach just one listener to the parent container\n// document.getElementById('itemsContainer').addEventListener('click', function(event) {\n//   if (event.target.tagName === 'LI') { /* handler code based on event.target */ }\n// }); // Just 1 listener for 1000+ items\n\n// In a real-world scenario, performance difference would be noticeable, especially with very large lists and frequent event triggering. Event delegation is significantly more memory and CPU efficient in such cases.\n\n// Note: To actually measure performance, use browser performance profiling tools to compare memory usage and event handling times in both scenarios with a large number of elements."
            }
          ]
        },
        {
          "id": "interview-js-concept-12",
          "title": "Scope and Scope Chain",
          "description": "Explain scope in JavaScript, different types of scope (global, function, block), and how the scope chain works for variable lookup.",
          "difficulty": "intermediate",
          "category": "fundamentals",
          "explanation": "Scope in JavaScript determines the accessibility or visibility of variables. It's a fundamental concept for understanding how JavaScript code is organized and how variable names are resolved. JavaScript has several types of scope: Global Scope: Variables declared outside of any function or block have global scope. They are accessible from anywhere in the code, including within functions and blocks. In browsers, global scope is often the `window` object. Function Scope: Variables declared inside a function have function scope. They are only accessible within that function and any functions nested inside it. `var` declarations have function scope. Block Scope: Variables declared with `let` and `const` inside a block (e.g., inside `if` statements, loops, or curly braces `{}`) have block scope. They are only accessible within that block. Scope Chain: When JavaScript tries to access a variable, it first looks in the current scope. If the variable is not found in the current scope, it moves up to the outer (enclosing) scope, then to its outer scope, and so on, all the way up to the global scope. This sequence of scopes that JavaScript searches through to resolve variable names is called the scope chain. If the variable is not found in any scope in the chain, a `ReferenceError` is thrown (in strict mode) or it might be implicitly created as a global variable (in non-strict mode with `var` if assignment is attempted). Understanding scope and the scope chain is crucial for writing modular, maintainable, and bug-free JavaScript code. It helps prevent variable name collisions and manage variable accessibility, especially in larger applications.",
          "example": "// Global scope variable\nvar globalVar = 'I am global';\n\nfunction functionScopeExample() {\n  var functionVar = 'I am function-scoped (var)';\n  let blockVar = 'I am block-scoped (let)';\n  console.log('Inside function - globalVar:', globalVar);    // Accessible - global scope\n  console.log('Inside function - functionVar:', functionVar); // Accessible - function scope\n  console.log('Inside function - blockVar:', blockVar);    // Accessible - block scope\n\n  if (true) {\n    var blockVarIf = 'Function-scoped var in block'; // var is function-scoped, not block-scoped\n    let blockLetIf = 'Block-scoped let in block';\n    console.log('Inside block - blockVarIf (var):', blockVarIf); // Accessible\n    console.log('Inside block - blockLetIf (let):', blockLetIf); // Accessible\n  }\n  console.log('Outside block - blockVarIf (var):', blockVarIf); // Accessible - function scope\n  // console.log('Outside block - blockLetIf (let):', blockLetIf); // Error - block scope, not accessible outside if block\n}\n\nfunctionScopeExample();\nconsole.log('Outside function - globalVar:', globalVar);       // Accessible - global scope\n// console.log('Outside function - functionVar:', functionVar); // Error - function scope, not accessible outside function\n// console.log('Outside function - blockVar:', blockVar);     // Error - block scope, not accessible outside function\n// console.log('Outside function - blockVarIf:', blockVarIf);   // Accessible - function scope due to var\n\n// Scope chain in action\nvar outerVar = 'Outer scope variable';\nfunction outerFunction() {\n  var middleVar = 'Middle scope variable';\n  function innerFunction() {\n    var innerVar = 'Inner scope variable';\n    console.log('Inner function - innerVar:', innerVar);   // Accessible - inner scope\n    console.log('Inner function - middleVar:', middleVar);  // Accessible - scope chain lookup to outerFunction scope\n    console.log('Inner function - outerVar:', outerVar);   // Accessible - scope chain lookup to global scope\n  }\n  innerFunction();\n}\nouterFunction();",
          "keyPoints": [
            "Scope defines the visibility and accessibility of variables in JavaScript.",
            "JavaScript has global scope, function scope (for `var`), and block scope (for `let`, `const`).",
            "Global scope variables are accessible everywhere.",
            "Function scope variables (`var`) are accessible within the function and nested functions.",
            "Block scope variables (`let`, `const`) are accessible only within the block they are defined (e.g., `if`, loops, `{}`).",
            "The scope chain is the hierarchy of scopes JavaScript searches when resolving variable names: current scope, outer scope, and so on, up to global scope.",
            "Scope chain ensures that inner scopes can access variables from outer scopes, but not vice versa.",
            "Understanding scope and scope chain is crucial for preventing variable conflicts, managing accessibility, and writing well-structured JavaScript code."
          ],
          "quiz": [
            {
              "question": "What is scope in JavaScript?",
              "options": ["The data type of a variable", "The lifetime of a variable", "The accessibility or visibility of variables", "The speed of variable access"],
              "correctAnswer": 2
            },
            {
              "question": "Which type of scope do variables declared with `var` have?",
              "options": ["Block scope", "Global scope", "Function scope", "Lexical scope"],
              "correctAnswer": 2
            },
            {
              "question": "Which type of scope do variables declared with `let` and `const` have?",
              "options": ["Function scope", "Global scope", "Block scope", "Dynamic scope"],
              "correctAnswer": 2
            },
            {
              "question": "What is the scope chain in JavaScript?",
              "options": ["A chain of functions", "A list of global variables", "The sequence of scopes JavaScript searches to resolve variable names", "A way to define variable data types"],
              "correctAnswer": 2
            },
            {
              "question": "If a variable is not found in the current scope, where does JavaScript look next?",
              "options": ["In a random scope", "In the global scope only", "In the outer (enclosing) scope", "Nowhere, it throws an error immediately"],
              "correctAnswer": 2
            }
          ],
          "interactiveExamples": [
            {
              "title": "Scope Exploration - Global, Function, Block",
              "code": "// Global variable\nlet globalExampleVar = 'Global Variable';\n\nfunction scopeExampleFunc() {\n  let functionExampleVar = 'Function Variable';\n  console.log('Inside function - Global var:', globalExampleVar); // Accessible\n  console.log('Inside function - Function var:', functionExampleVar); // Accessible\n\n  if (true) {\n    let blockExampleVar = 'Block Variable';\n    console.log('Inside block - Global var:', globalExampleVar); // Accessible\n    console.log('Inside block - Function var:', functionExampleVar); // Accessible\n    console.log('Inside block - Block var:', blockExampleVar); // Accessible\n  }\n  console.log('Outside block - Global var:', globalExampleVar); // Accessible\n  console.log('Outside block - Function var:', functionExampleVar); // Accessible\n  // console.log('Outside block - Block var:', blockExampleVar); // Error - block scope\n}\n\nscopeExampleFunc();\nconsole.log('Outside function - Global var:', globalExampleVar); // Accessible\n// console.log('Outside function - Function var:', functionExampleVar); // Error - function scope\n// console.log('Outside function - Block var:', blockExampleVar); // Error - block scope\n\n// Uncomment lines marked with 'Error' to observe scope restrictions."
            },
            {
              "title": "Scope Chain - Nested Functions and Variable Lookup",
              "code": "let scopeChainGlobalVar = 'Global Variable';\n\nfunction outerScopeFunc() {\n  let outerScopeVar = 'Outer Function Variable';\n\n  function innerScopeFunc() {\n    let innerScopeVar = 'Inner Function Variable';\n    console.log('Inside inner function - Inner var:', innerScopeVar); // Accessible - inner scope\n    console.log('Inside inner function - Outer var:', outerScopeVar); // Scope chain lookup - outerScopeFunc\n    console.log('Inside inner function - Global var:', scopeChainGlobalVar); // Scope chain lookup - global\n  }\n  innerScopeFunc();\n  console.log('Inside outer function - Outer var:', outerScopeVar); // Accessible - outer scope\n  console.log('Inside outer function - Global var:', scopeChainGlobalVar); // Accessible - global\n  // console.log('Inside outer function - Inner var:', innerScopeVar); // Error - innerScopeVar is not defined in outerScopeFunc scope\n}\n\nouterScopeFunc();\nconsole.log('Global scope - Global var:', scopeChainGlobalVar); // Accessible - global scope\n// console.log('Global scope - Outer var:', outerScopeVar); // Error - outerScopeVar is not defined in global scope\n// console.log('Global scope - Inner var:', innerScopeVar); // Error - innerScopeVar is not defined in global scope\n\n// Uncomment lines marked with 'Error' to observe scope chain boundaries."
            }
          ]
        },
        {
          "id": "interview-js-concept-13",
          "title": "Event Loop and Concurrency Model",
          "description": "Explain the JavaScript event loop, its role in handling asynchronous operations, and JavaScript's concurrency model.",
          "difficulty": "advanced",
          "category": "async",
          "explanation": "JavaScript is a single-threaded language, meaning it has one call stack and one memory heap. To handle asynchronous operations without blocking the main thread, JavaScript uses an event loop. The Event Loop is a crucial mechanism that allows JavaScript to perform non-blocking operations, making it highly responsive, especially in browser environments. Concurrency Model: JavaScript achieves concurrency, not parallelism, through its event loop model. It does not use multiple threads for executing code concurrently. Instead, it manages asynchronous tasks by efficiently switching between tasks when one is waiting for an operation to complete (like network request, timer, user input). Key Components of the Event Loop: Call Stack: JavaScript executes synchronous code on the call stack. Functions are pushed onto the stack when called and popped off when they return. When the stack is empty, JavaScript checks the microtask and macrotask queues. Callback Queue (Macrotask Queue): Asynchronous operations like `setTimeout`, `setInterval`, AJAX requests, and user events (like clicks) place their callbacks into the macrotask queue once they are ready to be executed. Microtask Queue (Promise Job Queue): Promise resolutions (`.then()`, `.catch()`, `.finally()`) and `MutationObserver` callbacks are added to the microtask queue. Microtasks have higher priority than macrotasks. Event Loop's Operation: The event loop continuously monitors the call stack and the microtask/macrotask queues. If the call stack is empty, the event loop checks the microtask queue. If there are microtasks, it processes them all, one by one, until the microtask queue is empty. Only then does it look at the macrotask queue. If there are macrotasks, it takes the first macrotask from the queue, pushes its associated callback onto the call stack for execution, and repeats the process. This cycle continues, allowing JavaScript to handle asynchronous operations efficiently without blocking the main thread. This model ensures that UI remains responsive and JavaScript code can handle long-running operations without freezing the browser.",
          "example": "// Event loop demonstration - order of execution\nconsole.log('Synchronous task 1');\n\nsetTimeout(() => {\n  console.log('Macrotask (setTimeout)');\n}, 0);\n\nPromise.resolve().then(() => {\n  console.log('Microtask (Promise)');\n});\n\nconsole.log('Synchronous task 2');\n\n// Output order will be: Synchronous task 1, Synchronous task 2, Microtask (Promise), Macrotask (setTimeout).\n// This shows that synchronous code executes first, then microtasks, then macrotasks, due to event loop priorities.\n\n// Example of blocking vs non-blocking behavior\n// Blocking (synchronous) - simulates long operation\n// console.time('blocking');\n// for (let i = 0; i < 1000000000; i++) { /* Block main thread */ }\n// console.timeEnd('blocking');\n// console.log('Blocking task finished - UI would be frozen during this time.');\n\n// Non-blocking (asynchronous) - using setTimeout\nconsole.time('nonBlocking');\nsetTimeout(() => {\n  console.timeEnd('nonBlocking');\n  console.log('Non-blocking task finished - UI remains responsive.');\n}, 0);\nconsole.log('Non-blocking task initiated - script continues to run.');\n\n// Compare the behavior of blocking (synchronous loop) and non-blocking (setTimeout) code to understand event loop's role in responsiveness.",
          "keyPoints": [
            "JavaScript is single-threaded but achieves concurrency through the event loop.",
            "The event loop allows JavaScript to handle asynchronous operations non-blockingly, maintaining UI responsiveness.",
            "Key components: call stack (for synchronous code), macrotask queue (for `setTimeout`, I/O, etc.), microtask queue (for Promises).",
            "Event loop continuously monitors the call stack and queues. When call stack is empty, it prioritizes microtasks, then macrotasks.",
            "Microtasks (Promise handlers) are processed before macrotasks (e.g., `setTimeout` callbacks).",
            "JavaScript concurrency is not parallelism; it's efficient task switching managed by the event loop.",
            "Understanding the event loop is essential for mastering asynchronous JavaScript programming and predicting code execution order."
          ],
          "quiz": [
            {
              "question": "Is JavaScript a single-threaded or multi-threaded language?",
              "options": ["Multi-threaded", "Single-threaded", "It can be both", "Depends on the browser"],
              "correctAnswer": 1
            },
            {
              "question": "What is the role of the event loop in JavaScript?",
              "options": ["To execute synchronous code", "To manage memory allocation", "To handle asynchronous operations without blocking the main thread", "To optimize code performance"],
              "correctAnswer": 2
            },
            {
              "question": "Which queue has higher priority in the JavaScript event loop?",
              "options": ["Macrotask queue", "Callback queue", "Microtask queue", "Both queues have equal priority"],
              "correctAnswer": 2
            },
            {
              "question": "Which of the following tasks is typically placed in the macrotask queue?",
              "options": ["Promise resolution handlers", "`MutationObserver` callbacks", "`setTimeout` callbacks", "Microtask callbacks"],
              "correctAnswer": 2
            },
            {
              "question": "Does JavaScript achieve parallelism or concurrency through its event loop model?",
              "options": ["Parallelism", "Concurrency", "Both parallelism and concurrency", "Neither parallelism nor concurrency"],
              "correctAnswer": 1
            }
          ],
          "interactiveExamples": [
            {
              "title": "Visualizing Event Loop - Call Stack, Microtask, Macrotask",
              "code": "// Example to visualize event loop flow\nconsole.log('Task 1 (Synchronous)'); // 1. Call Stack\n\nsetTimeout(() => {\n  console.log('Task 4 (Macrotask - setTimeout)'); // 4. Macrotask Queue -> Call Stack\n}, 0);\n\nPromise.resolve().then(() => {\n  console.log('Task 3 (Microtask - Promise)'); // 3. Microtask Queue -> Call Stack\n});\n\nconsole.log('Task 2 (Synchronous)'); // 2. Call Stack\n\n// Run and observe the output order: 1, 2, 3, 4. Visualize how synchronous tasks are executed first from the call stack, then microtasks, then macrotasks as managed by the event loop."
            },
            {
              "title": "Blocking vs Non-Blocking Operations - UI Responsiveness",
              "code": "// Non-blocking operation using setTimeout\nconsole.log('Non-blocking operation started...');\nsetTimeout(() => {\n  console.log('Non-blocking operation finished.');\n  alert('Non-blocking task complete! UI remained responsive.'); // UI is responsive during timeout\n}, 3000);\n\nconsole.log('Script continues to execute while waiting for timeout.');\n\n// Blocking operation (uncomment to test - will freeze UI for duration)\n// console.log('Blocking operation started...');\n// console.time('blockingOp');\n// let startTime = Date.now();\n// while (Date.now() - startTime < 3000) { /* Block main thread for 3 seconds */ }\n// console.timeEnd('blockingOp');\n// console.log('Blocking operation finished.');\n// alert('Blocking task complete! UI was frozen during this time.'); // UI is unresponsive during blocking loop\n\n// Compare the user experience with non-blocking (setTimeout - UI responsive) vs. blocking (synchronous loop - UI frozen) operations to appreciate the importance of the event loop."
            }
          ]
        },
        {
          "id": "interview-js-concept-14",
          "title": "JavaScript Module Systems (CommonJS, AMD, ES Modules)",
          "description": "Compare and contrast different JavaScript module systems: CommonJS, AMD, and ES Modules, including their history, syntax, and use cases.",
          "difficulty": "intermediate",
          "category": "es6",
          "explanation": "JavaScript has evolved through different module systems to organize and structure code, especially for large applications. Understanding these systems is important for historical context and modern JavaScript development. CommonJS (CJS): Primarily used in Node.js environments. Synchronous module loading: `require()` function loads modules synchronously, blocking execution until the module is loaded. Simple syntax for export (`module.exports`) and import (`require()`). Designed for server-side JavaScript where file system access is available and synchronous loading is less of a performance bottleneck. Asynchronous Module Definition (AMD): Designed for browser environments, particularly for early web applications. Asynchronous module loading: Modules are loaded asynchronously using `define()` function, non-blocking for browser environments. More complex syntax compared to CJS, involving callbacks and dependency arrays in `define()`. RequireJS is a popular implementation of AMD. ES Modules (ESM): Standardized module system introduced in ECMAScript 6 (ES2015) and supported in modern browsers and Node.js (natively in recent versions). Asynchronous loading in browsers, but can be synchronous in Node.js under certain conditions. Static analysis possible: `import` and `export` statements are statically analyzable, enabling build tools and optimizations. Simpler and more declarative syntax compared to AMD: `export` and `import` keywords. Preferred module system for modern JavaScript development due to standardization, static analysis benefits, and browser and Node.js support. Comparison Table: Feature | CommonJS | AMD | ES Modules --------|----------|-----|------------ Environment | Node.js | Browsers | Browsers & Node.js Loading | Synchronous | Asynchronous | Asynchronous (Browser), Can be Synchronous (Node.js) Syntax | `require()`, `module.exports` | `define()`, `require()` | `import`, `export` Static Analysis | No | No | Yes Use Cases | Server-side | Browser (early web) | Modern web and server-side Migration: Modern JavaScript projects are increasingly adopting ES Modules for their benefits. Build tools like Webpack and Babel can help transpile and bundle code using different module systems, facilitating migration and interoperability.",
          "example": "// CommonJS (Node.js environment)\n// moduleA.js\n// exports.hello = (name) => {\n//   return `Hello, ${name} from module A`;\n// };\n\n// main.js\n// const moduleA = require('./moduleA');\n// console.log(moduleA.hello('CommonJS User'));\n\n// AMD (Browser environment - using RequireJS example)\n// moduleB.js\n// define(function() {\n//   return {\n//     greet: function(name) {\n//       return 'Greetings, ' + name + ' from module B (AMD)';\n//     };\n//   };\n// });\n\n// main.js\n// require(['./moduleB'], function(moduleB) {\n//   console.log(moduleB.greet('AMD User'));\n// });\n\n// ES Modules (Modern Browsers and Node.js)\n// moduleC.js\n// export function sayGoodbye(name) {\n//   return `Goodbye, ${name} from module C (ESM)`;\n// }\n\n// main.js\n// import { sayGoodbye } from './moduleC.js';\n// console.log(sayGoodbye('ESM User'));\n\n// Note: ES Modules example requires a module-aware environment (e.g., <script type=\"module\"> in HTML, or Node.js with --experimental-modules flag or in package.json type: \"module\")",
          "keyPoints": [
            "JavaScript has evolved through different module systems: CommonJS (CJS), AMD, and ES Modules (ESM).",
            "CommonJS (CJS) is synchronous, primarily used in Node.js, with `require()` and `module.exports` syntax.",
            "AMD (Asynchronous Module Definition) is asynchronous, designed for browsers, with `define()` and `require()` syntax, e.g., RequireJS.",
            "ES Modules (ESM) are standardized, supported in browsers and Node.js, with `import` and `export` syntax, offering asynchronous loading in browsers and static analysis.",
            "CJS is synchronous, suitable for server-side; AMD and ESM are asynchronous, better for browsers.",
            "ESM is the modern standard, preferred for new JavaScript projects due to standardization, static analysis, and broad support.",
            "Build tools can transpile and bundle code across module systems, aiding in migration and interoperability."
          ],
          "quiz": [
            {
              "question": "Which JavaScript module system is primarily used in Node.js?",
              "options": ["AMD", "ES Modules", "CommonJS", "UMD"],
              "correctAnswer": 2
            },
            {
              "question": "Which module system is designed for asynchronous module loading in browser environments?",
              "options": ["CommonJS", "ES Modules", "AMD", "System.js"],
              "correctAnswer": 2
            },
            {
              "question": "Which module system is standardized in ECMAScript 6 (ES2015)?",
              "options": ["CommonJS", "AMD", "ES Modules", "UMD"],
              "correctAnswer": 2
            },
            {
              "question": "Which module system uses `require()` and `module.exports` syntax?",
              "options": ["ES Modules", "AMD", "CommonJS", "UMD"],
              "correctAnswer": 2
            },
            {
              "question": "Which module system supports static analysis, enabling build tools and optimizations?",
              "options": ["CommonJS", "AMD", "ES Modules", "All of the above"],
              "correctAnswer": 2
            }
          ],
          "interactiveExamples": [
            {
              "title": "ES Modules - Basic Import and Export (Browser)",
              "code": "// Create two files: moduleA.js and index.html in the same directory.\n\n// moduleA.js:\n// export function greetModuleA(name) {\n//   return `Hello, ${name} from Module A (ESM)`;\n// }\n\n// index.html:\n// <html>\n// <head><title>ES Modules Example</title></head>\n// <body>\n//   <script type=\"module\">\n//     import { greetModuleA } from './moduleA.js';\n//     console.log(greetModuleA('Browser User'));\n//   </script>\n// </body>\n// </html>\n\n// Open index.html in a browser. Check console for output. This demonstrates basic ES Module import/export in a browser environment."
            },
            {
              "title": "CommonJS - Example in Node.js (Conceptual)",
              "code": "// Create two files: moduleB.js and app.js in a Node.js environment.\n\n// moduleB.js:\n// exports.multiply = function(a, b) {\n//   return a * b;\n// };\n\n// app.js:\n// const moduleB = require('./moduleB');\n// console.log('5 * 3 =', moduleB.multiply(5, 3));\n\n// Run in Node.js terminal: node app.js\n// This demonstrates a simple CommonJS module example in Node.js. Note: This example is conceptual; you need to run it in a Node.js environment."
            }
          ]
        },
        {
          "id": "interview-js-concept-15",
          "title": "Service Workers",
          "description": "Explain JavaScript Service Workers, their lifecycle, use cases (caching, push notifications, background sync), and limitations.",
          "difficulty": "advanced",
          "category": "browser-api",
          "explanation": "Service Workers are a powerful web technology that enables client-side scripting to run in the background, separate from the main browser thread, even when the user is not actively using the web page. They act as a proxy between the browser and the network, providing enhanced control over network requests, caching, and background synchronization. Service Worker Lifecycle: Registration: A service worker script is registered from within a web page. Installation: After registration, the browser attempts to install the service worker. This phase is typically used to cache static assets for offline access. Activation: Once installed, the service worker enters the activation phase. An old service worker (if any) is replaced by the new one. The activated service worker is now ready to handle events like `fetch` and `push`. Idle/Terminated: When not handling events, the service worker is in an idle state and can be terminated by the browser to save resources. It wakes up when relevant events occur. Key Use Cases: Caching: Service workers can intercept network requests and serve responses from cache, enabling offline access and improving performance. Push Notifications: They can receive push messages from a server and display notifications to the user, even when the web page is not open. Background Sync: Service workers can defer actions until network connectivity is available, allowing for background data synchronization. Limitations: Scope: Service workers are scoped to the directory they are registered from and its subdirectories. Limited DOM Access: Service workers do not have direct access to the DOM because they run in a separate thread. Communication with the main thread is done via message passing. HTTPS Requirement: For security reasons, service workers require HTTPS for production environments (localhost is an exception for development). CPU Intensive Tasks: While they run in the background, CPU-intensive tasks in service workers can still impact battery life and performance if not handled carefully. Service workers are a key technology for building Progressive Web Apps (PWAs), enhancing web application capabilities to be more app-like, reliable, and engaging.",
          "example": "// Service Worker Registration (in main JavaScript file of web page)\n// if ('serviceWorker' in navigator) {\n//   navigator.serviceWorker.register('/service-worker.js')\n//     .then(registration => {\n//       console.log('Service Worker registered with scope:', registration.scope);\n//     })\n//     .catch(error => {\n//       console.error('Service Worker registration failed:', error);\n//     });\n// }\n\n// service-worker.js (Service Worker script - in root directory or specified scope)\n// self.addEventListener('install', event => {\n//   console.log('Service Worker installing.');\n//   // Perform installation steps like caching static assets\n// });\n\n// self.addEventListener('activate', event => {\n//   console.log('Service Worker activated.');\n//   // Perform activation steps like cleaning up old caches\n// });\n\n// self.addEventListener('fetch', event => {\n//   // Intercept fetch requests and handle caching\n//   event.respondWith(\n//     caches.match(event.request).then(cachedResponse => {\n//       return cachedResponse || fetch(event.request);\n//     })\n//   );\n// });\n\n// Note: Service Worker example requires a web server (even for local testing in some browsers) and HTTPS (for production). The above code snippets are conceptual and need to be part of a proper web application setup to function fully.",
          "keyPoints": [
            "Service Workers are JavaScript scripts that run in the background, separate from the main browser thread, acting as proxies.",
            "Lifecycle: Registration -> Installation -> Activation -> Idle/Terminated.",
            "Use cases: Caching for offline access, push notifications, background sync.",
            "Caching is achieved by intercepting 'fetch' events and serving from cache or network.",
            "Push notifications allow server-initiated messages to be displayed to users.",
            "Background sync defers actions until network connectivity is restored.",
            "Limitations: Scoped to registration directory, no direct DOM access, HTTPS required, CPU intensive tasks need careful management.",
            "Key technology for Progressive Web Apps (PWAs) to enhance web app capabilities."
          ],
          "quiz": [
            {
              "question": "What is the primary purpose of JavaScript Service Workers?",
              "options": ["To enhance JavaScript performance", "To enable server-side rendering", "To run client-side scripts in the background and enhance web app capabilities", "To manage browser history"],
              "correctAnswer": 2
            },
            {
              "question": "In which phase of the Service Worker lifecycle are static assets typically cached for offline access?",
              "options": ["Registration", "Activation", "Installation", "Fetching"],
              "correctAnswer": 2
            },
            {
              "question": "Can Service Workers directly access the DOM?",
              "options": ["Yes, they have full DOM access", "Yes, but only for read operations", "No, they run in a separate thread and do not have direct DOM access", "Only during the activation phase"],
              "correctAnswer": 2
            },
            {
              "question": "Which security protocol is generally required for Service Workers in production environments?",
              "options": ["HTTP", "FTP", "HTTPS", "SFTP"],
              "correctAnswer": 2
            },
            {
              "question": "Which of the following is NOT a common use case for Service Workers?",
              "options": ["Caching web pages for offline access", "Handling push notifications", "Performing server-side computations", "Background data synchronization"],
              "correctAnswer": 2
            }
          ],
          "interactiveExamples": [
            {
              "title": "Service Worker Registration Simulation (Conceptual)",
              "code": "// Conceptual code - Service Worker registration is browser-specific and requires a server.\n// This is a simulation to understand registration steps.\n\nconsole.log('Attempting to register Service Worker...');\n\nconst isServiceWorkerSupported = ('serviceWorker' in navigator);\n\nif (isServiceWorkerSupported) {\n  console.log('Service Workers are supported in this browser.');\n  // In a real scenario, navigator.serviceWorker.register('/service-worker.js') would be used.\n  const registrationPromise = new Promise((resolve, reject) => {\n    // Simulate registration success after a delay\n    setTimeout(() => {\n      const registration = { scope: 'simulatedScope' }; // Simulated registration object\n      console.log('Service Worker registration simulated successfully.');\n      resolve(registration);\n    }, 1500);\n  });\n\n  registrationPromise.then(registration => {\n    console.log('Simulated Service Worker scope:', registration.scope);\n  }).catch(error => {\n    console.error('Simulated Service Worker registration error:', error);\n  });\n} else {\n  console.log('Service Workers are NOT supported in this browser.');\n}\n\n// Note: This is a conceptual simulation. Real Service Worker registration requires a valid service-worker.js file and a web server environment."
            },
            {
              "title": "Service Worker Caching Strategy - Conceptual Example",
              "code": "// Conceptual code - Service Worker caching logic is within service-worker.js\n// This is a simplified demonstration of caching strategy concept.\n\nconst cacheName = 'my-site-cache-v1';\nconst filesToCache = [\n  '/',\n  '/index.html',\n  '/styles.css',\n  '/script.js',\n  '/images/logo.png'\n];\n\n// Simulated cache object (in real service-worker.js, Cache API is used)\nconst simulatedCache = {};\n\nfunction simulateInstallPhase() {\n  console.log('Simulating Service Worker install phase - caching assets.');\n  filesToCache.forEach(file => {\n    // Simulate fetching and caching each file\n    simulatedCache[file] = `Content of ${file}`; // In real SW, actual fetching and caching\n    console.log(`Simulated caching: ${file}`);\n  });\n  console.log('Simulated caching complete.');\n}\n\nfunction simulateFetchEvent(requestUrl) {\n  console.log(`Simulating fetch event for: ${requestUrl}`);\n  if (simulatedCache[requestUrl]) {\n    console.log(`Cache hit for: ${requestUrl} - serving from cache.`);\n    return `Cached content for ${requestUrl}`; // Simulate serving from cache\n  } else {\n    console.log(`Cache miss for: ${requestUrl} - fetching from network (simulated).`);\n    return `Network response for ${requestUrl}`; // Simulate network fetch\n  }\n}\n\nsimulateInstallPhase();\nconsole.log('\\nSimulating fetch for /index.html:', simulateFetchEvent('/index.html')); // Cache hit\nconsole.log('Simulating fetch for /api/data:', simulateFetchEvent('/api/data')); // Cache miss\n\n// Note: This is a conceptual simulation. Real Service Worker caching uses Cache API within service-worker.js and browser fetch events."
            }
          ]
        },
        {
          "id": "interview-js-concept-16",
          "title": "Web Workers",
          "description": "Explain JavaScript Web Workers, their benefits for performance, use cases (CPU-intensive tasks), limitations, and communication with the main thread.",
          "difficulty": "advanced",
          "category": "browser-api",
          "explanation": "Web Workers are a powerful browser API that enables true parallelism in JavaScript by allowing you to run scripts in background threads, separate from the main browser thread. This is crucial because JavaScript's main thread is responsible for UI rendering, handling user events, and executing JavaScript code. Long-running or CPU-intensive tasks on the main thread can block it, leading to UI freezes and poor user experience. Benefits of Web Workers: True Parallelism: Web Workers allow you to offload CPU-intensive tasks to background threads, preventing them from blocking the main thread and maintaining UI responsiveness. Improved Performance: By running tasks in parallel, Web Workers can significantly speed up applications, especially those involving heavy computations, data processing, or complex algorithms. Enhanced User Experience: Keeps the UI responsive and smooth, even during heavy processing, leading to a better user experience. Use Cases: CPU-intensive computations: Image/video processing, complex calculations, simulations, cryptography. Background data processing: Large dataset analysis, data transformation, pre-processing data for visualization. Limitations: No Direct DOM Access: Web Workers run in a separate thread and do not have direct access to the DOM or `window` object. Communication with the main thread is necessary to update the UI. Limited API Access: Some browser APIs are not available in Web Workers (e.g., `window`, `document`, `alert`). Communication with Main Thread: Communication between Web Workers and the main thread is asynchronous and done through message passing using `postMessage()` and `onmessage` event handlers. Data passed between threads is copied, not shared (structured cloning). Script Loading: Web Worker scripts are loaded from separate files (not inline scripts) due to security and threading model. Web Workers are ideal for scenarios where JavaScript applications need to perform heavy computations without blocking the main thread, enhancing both performance and user experience in web applications.",
          "example": "// Main thread script (e.g., in script.js)\n// const worker = new Worker('worker.js'); // Create a new Web Worker, worker.js is the worker script file\n\n// worker.postMessage({ task: 'calculateSum', numbers: [1, 2, 3, 4, 5] }); // Send message to worker\n\n// worker.onmessage = function(event) {\n//   console.log('Message received from worker:', event.data);\n//   // Handle result from worker, update UI, etc.\n// };\n\n// worker.onerror = function(error) {\n//   console.error('Worker error:', error);\n// };\n\n// worker.terminate(); // Terminate the worker when done (optional)\n\n// worker.js (Web Worker script - separate file 'worker.js')\n// self.onmessage = function(event) {\n//   const data = event.data;\n//   if (data.task === 'calculateSum') {\n//     const sum = data.numbers.reduce((a, b) => a + b, 0);\n//     self.postMessage({ result: sum }); // Send result back to main thread\n//   }\n// };\n\n// self.onerror = function(error) {\n//   console.error('Worker script error:', error);\n// };\n\n// Note: Web Worker example requires two separate JavaScript files (main script and worker script) and running in a browser environment that supports Web Workers. The above code snippets are conceptual and need to be part of a proper web application setup to function fully.",
          "keyPoints": [
            "Web Workers enable true parallelism in JavaScript by running scripts in background threads, separate from the main UI thread.",
            "Benefits: Prevents UI blocking, improves performance for CPU-intensive tasks, enhances user experience.",
            "Use cases: CPU-intensive computations, background data processing, complex algorithms.",
            "Limitations: No direct DOM access, limited API access, communication via message passing.",
            "Communication between main thread and worker thread is asynchronous using `postMessage()` and `onmessage`.",
            "Data passed between threads is copied (structured cloning), not shared.",
            "Web Worker scripts are loaded from separate files.",
            "Ideal for offloading heavy computations to background threads, keeping the main thread responsive."
          ],
          "quiz": [
            {
              "question": "What do JavaScript Web Workers enable in web applications?",
              "options": ["Direct DOM manipulation from background scripts", "True parallelism by running scripts in background threads", "Improved CSS rendering performance", "Synchronous execution of JavaScript code"],
              "correctAnswer": 1
            },
            {
              "question": "Can Web Workers directly manipulate the DOM?",
              "options": ["Yes, they have full DOM access", "Yes, but only for read operations", "No, they run in a separate thread and do not have direct DOM access", "Only during specific lifecycle phases"],
              "correctAnswer": 2
            },
            {
              "question": "How do Web Workers communicate with the main JavaScript thread?",
              "options": ["Through shared memory", "Through direct function calls", "Through message passing using `postMessage()` and `onmessage`", "They cannot communicate with the main thread"],
              "correctAnswer": 2
            },
            {
              "question": "Which of the following is a primary use case for Web Workers?",
              "options": ["Handling UI events", "DOM manipulation", "CPU-intensive computations and background tasks", "Styling web pages with CSS"],
              "correctAnswer": 2
            },
            {
              "question": "Are Web Worker scripts typically loaded as inline scripts or from separate files?",
              "options": ["Inline scripts within HTML", "Separate JavaScript files", "Both inline and separate files are equally supported", "Only from CDN URLs"],
              "correctAnswer": 1
            }
          ],
          "interactiveExamples": [
            {
              "title": "Basic Web Worker Example - Simple Calculation",
              "code": "// Create two files: index.html and worker-example.js in the same directory.\n\n// index.html:\n// <html><head><title>Web Worker Example</title></head><body>\n//   <h1>Web Worker Demo</h1><button id='startWorker'>Start Worker Calculation</button>\n//   <div id='result'></div><script>/* JavaScript code below in script tags */</script></body></html>\n\n// worker-example.js (Web Worker script):\n// self.onmessage = function(event) {\n//   const number = event.data;\n//   const result = number * number; // Simple calculation\n//   self.postMessage(result); // Send result back to main thread\n// };\n\n// JavaScript code in index.html <script> tags:\n// const workerButton = document.getElementById('startWorker');\n// const resultDiv = document.getElementById('result');\n// const myWorker = new Worker('worker-example.js');\n\n// workerButton.addEventListener('click', function() {\n//   const inputNumber = 10; // Example input\n//   worker.postMessage(inputNumber); // Send number to worker\n// });\n\n// myWorker.onmessage = function(event) {\n//   resultDiv.textContent = 'Result from Worker: ' + event.data;\n// };\n\n// Open index.html in a browser. Click the button to start worker calculation and see result displayed. This demonstrates basic Web Worker setup and message passing."
            },
            {
              "title": "Web Worker - Long Running Task Simulation",
              "code": "// Create two files: index.html and long-task-worker.js\n\n// index.html (similar structure to previous example, button and result div)\n\n// long-task-worker.js:\n// self.onmessage = function(event) {\n//   const duration = event.data.duration || 5000; // Default 5 seconds\n//   console.log('Worker started long task for ' + duration + 'ms');\n//   const startTime = Date.now();\n//   while (Date.now() - startTime < duration) { /* Simulate long running task */ }\n//   self.postMessage('Long task completed in worker.'); // Send completion message\n// };\n\n// JavaScript in index.html <script> tags:\n// const longTaskButton = document.getElementById('startWorker');\n// const resultDivLongTask = document.getElementById('result');\n// const longTaskWorker = new Worker('long-task-worker.js');\n\n// longTaskButton.addEventListener('click', function() {\n//   resultDivLongTask.textContent = 'Worker task started... (UI remains responsive)';\n//   longTaskWorker.postMessage({ duration: 3000 }); // Start long task in worker for 3 seconds\n// });\n\n// longTaskWorker.onmessage = function(event) {\n//   resultDivLongTask.textContent = event.data; // Display worker completion message\n// };\n\n// Open index.html. Click the button. Notice UI remains responsive while worker simulates a long task in the background. This highlights Web Worker's benefit for non-blocking operations."
            }
          ]
        },
        {
          "id": "interview-js-concept-17",
          "title": "Shadow DOM",
          "description": "Explain Shadow DOM, its purpose for encapsulation, benefits for component-based development, and how to use it.",
          "difficulty": "intermediate",
          "category": "dom",
          "explanation": "Shadow DOM is a web standard that provides encapsulation for HTML, CSS, and JavaScript in web components. It allows you to create isolated DOM trees attached to elements in the main DOM tree, but rendered separately. This encapsulation is crucial for building reusable and independent web components, preventing style and script conflicts between components and the main document, or between different components. Key Concepts of Shadow DOM: Shadow Host: The regular DOM node to which a shadow DOM tree is attached. You can attach shadow DOM to almost any element. Shadow Tree: The DOM tree attached to the shadow host, which is rendered separately. Shadow Root: The root node of the shadow tree. It's created using `element.attachShadow({mode: 'open' or 'closed'})`. Mode: 'open' mode means the shadow DOM tree is accessible from JavaScript outside the component using `shadowHost.shadowRoot`. 'closed' mode hides the shadow DOM tree from external access (for more encapsulation). Shadow Boundary: The point where the shadow DOM meets the regular DOM. Styles and scripts within the shadow DOM are scoped to the shadow tree and do not leak out to the main document, and vice versa (to a large extent). Benefits of Shadow DOM: Encapsulation: Styles and scripts are scoped to the shadow DOM, preventing CSS specificity issues and JavaScript conflicts between components and the main page. Component Reusability: Enables creation of truly reusable web components that are isolated and independent, simplifying component-based development. Style and Script Isolation: Prevents styles and scripts from one part of the application from accidentally affecting others, improving maintainability and reducing bugs. Simplified CSS: Allows using simpler CSS selectors within components without worrying about global CSS conflicts. Web Components: Shadow DOM is a core part of the Web Components standard, along with Custom Elements and HTML Templates, for creating reusable UI components in web applications. Understanding Shadow DOM is essential for modern web development, especially when building component-based UIs and reusable web components.",
          "example": "// HTML structure (example element to attach shadow DOM):\n// <div id='shadowHost'></div>\n\n// JavaScript code to create and attach Shadow DOM\n// const shadowHostElement = document.getElementById('shadowHost');\n// const shadowRoot = shadowHostElement.attachShadow({ mode: 'open' }); // 'open' or 'closed' mode\n\n// Create elements for shadow DOM\n// const shadowParagraph = document.createElement('p');\n// shadowParagraph.textContent = 'This is inside Shadow DOM.';\n// const shadowStyle = document.createElement('style');\n// shadowStyle.textContent = `\n//   p { color: white; background-color: navy; padding: 10px; }\n// `; // Styles scoped to shadow DOM\n\n// Append elements to shadow root\n// shadowRoot.appendChild(shadowStyle);\n// shadowRoot.appendChild(shadowParagraph);\n\n// Main document style (will NOT affect shadow DOM paragraph directly due to encapsulation)\n// const mainStyle = document.createElement('style');\n// mainStyle.textContent = `\n//   p { font-weight: bold; }\n// `; // Targets <p> in main document, not shadow DOM\n// document.head.appendChild(mainStyle);\n\n// Accessing shadow root (only in 'open' mode)\n// const shadowRootAccess = shadowHostElement.shadowRoot; // Accessible in 'open' mode\n// if (shadowRootAccess) {\n//   console.log('Shadow Root accessed:', shadowRootAccess);\n// }\n\n// Note: Run this code in a browser environment. Inspect the element in developer tools to see the Shadow DOM structure and style encapsulation.",
          "keyPoints": [
            "Shadow DOM provides encapsulation for HTML, CSS, and JavaScript within web components.",
            "It creates isolated DOM trees (shadow trees) attached to regular DOM elements (shadow hosts).",
            "Shadow Root is the root node of the shadow tree, created using `element.attachShadow({mode: 'open' or 'closed'})`.",
            "Encapsulation prevents style and script conflicts between components and the main document or between components.",
            "Benefits: Style and script isolation, component reusability, simplified CSS, cleaner code.",
            "Shadow boundary isolates styles and scripts within the shadow DOM.",
            "Shadow DOM is a core part of Web Components standard for creating reusable UI components."
          ],
          "quiz": [
            {
              "question": "What is the primary purpose of Shadow DOM in web development?",
              "options": ["To improve JavaScript performance", "To enable server-side rendering", "To provide encapsulation for HTML, CSS, and JavaScript in web components", "To simplify DOM manipulation"],
              "correctAnswer": 2
            },
            {
              "question": "What is a 'shadow host' in Shadow DOM?",
              "options": ["The root node of the shadow DOM tree", "A regular DOM node to which a shadow DOM tree is attached", "The CSS style sheet applied to shadow DOM", "The JavaScript code that controls shadow DOM"],
              "correctAnswer": 1
            },
            {
              "question": "What are the two modes for attaching Shadow DOM using `attachShadow({mode: ...})`?",
              "options": ["'open' and 'closed'", "'visible' and 'hidden'", "'public' and 'private'", "'strict' and 'loose'"],
              "correctAnswer": 0
            },
            {
              "question": "What does 'encapsulation' mean in the context of Shadow DOM?",
              "options": ["Making code run faster", "Hiding code from developers", "Isolating styles and scripts within the shadow DOM to prevent conflicts", "Compressing HTML and CSS code"],
              "correctAnswer": 2
            },
            {
              "question": "Is CSS defined within Shadow DOM affected by CSS rules in the main document?",
              "options": ["Yes, CSS from the main document always overrides Shadow DOM styles", "Yes, but only for specific CSS properties", "No, styles within Shadow DOM are generally isolated from the main document's styles", "Only if 'mode' is set to 'open'"],
              "correctAnswer": 2
            }
          ],
          "interactiveExamples": [
            {
              "title": "Creating Shadow DOM - Style Encapsulation Demo",
              "code": "// HTML (add to body):\n// <div id='shadowDomExample'></div>\n\nconst shadowDomExampleElement = document.getElementById('shadowDomExample');\nconst shadowRootExample = shadowDomExampleElement.attachShadow({ mode: 'open' });\n\nconst shadowParagraphExample = document.createElement('p');\nshadowParagraphExample.textContent = 'Paragraph inside Shadow DOM - styled navy.';\nconst shadowStyleExample = document.createElement('style');\nshadowStyleExample.textContent = `p { color: white; background-color: navy; padding: 10px; }`;\n\nshadowRootExample.appendChild(shadowStyleExample);\nshadowRootExample.appendChild(shadowParagraphExample);\n\nconst mainDocStyleExample = document.createElement('style');\nmainDocStyleExample.textContent = `p { color: red; }`; // Style for main document <p> tags\ndocument.head.appendChild(mainDocStyleExample);\n\nconst mainDocParagraphExample = document.createElement('p');\nmainDocParagraphExample.textContent = 'Paragraph in main document - styled red.';\ndocument.body.appendChild(mainDocParagraphExample);\n\n// Observe that the paragraph in Shadow DOM is styled navy (shadow style), and the paragraph in the main document is styled red (main document style), demonstrating style encapsulation."
            },
            {
              "title": "Shadow DOM - 'open' vs 'closed' Mode",
              "code": "// HTML (add to body):\n// <div id='shadowDomOpen'>Shadow DOM (Open Mode)</div>\n// <div id='shadowDomClosed'>Shadow DOM (Closed Mode)</div>\n\nconst shadowDomOpenElement = document.getElementById('shadowDomOpen');\nconst shadowRootOpen = shadowDomOpenElement.attachShadow({ mode: 'open' });\nshadowRootOpen.innerHTML = '<p>Shadow DOM - Open Mode - Accessible via JS</p>';\n\nconst shadowDomClosedElement = document.getElementById('shadowDomClosed');\nconst shadowRootClosed = shadowDomClosedElement.attachShadow({ mode: 'closed' });\nshadowRootClosed.innerHTML = '<p>Shadow DOM - Closed Mode - Inaccessible via JS</p>';\n\nconsole.log('Shadow Root (Open Mode):', shadowDomOpenElement.shadowRoot); // Accessible\nconsole.log('Shadow Root (Closed Mode):', shadowDomClosedElement.shadowRoot); // null - Inaccessible\n\n// Run and check console output. 'shadowDomOpenElement.shadowRoot' will return the shadow root, while 'shadowDomClosedElement.shadowRoot' will be null, demonstrating the difference in accessibility between 'open' and 'closed' modes."
            }
          ]
        },
        {
          "id": "interview-js-concept-18",
          "title": "Web Storage API (localStorage and sessionStorage)",
          "description": "Explain the Web Storage API, focusing on localStorage and sessionStorage, their differences, use cases, and security considerations.",
          "difficulty": "beginner",
          "category": "browser-api",
          "explanation": "The Web Storage API provides mechanisms for web pages to store key-value pairs locally within the user's browser, offering a more powerful and flexible alternative to cookies for client-side storage. There are two main types of web storage: localStorage and sessionStorage. localStorage: Persistent storage: Data stored in localStorage persists even after the browser is closed and reopened. It remains available until explicitly cleared by JavaScript code or browser settings. Scope: Data stored in localStorage is scoped to the origin (domain, protocol, and port) and is shared across all windows and tabs from the same origin. Use cases: Storing user preferences, offline data, application state that needs to persist across sessions. sessionStorage: Session-based storage: Data stored in sessionStorage is available only for the duration of the browser session (i.e., as long as the browser window or tab is open). Data is cleared when the window or tab is closed. Scope: Data in sessionStorage is also scoped to the origin but is additionally scoped to the window/tab. Each window/tab from the same origin has its own sessionStorage. Use cases: Storing temporary data related to a user's session, like form data, shopping cart contents, data for single-page applications that shouldn't persist after the session ends. Common Methods for both localStorage and sessionStorage: `setItem(key, value)`: Stores a key-value pair. Values are always stored as strings. `getItem(key)`: Retrieves the value associated with a key. Returns `null` if the key does not exist. `removeItem(key)`: Removes a key-value pair. `clear()`: Clears all key-value pairs in the storage. `key(index)`: Returns the name of the key at the given index. `length`: Returns the number of key-value pairs stored. Security Considerations: Data stored in web storage is not automatically encrypted and is accessible via JavaScript in the same origin. Avoid storing sensitive information directly in web storage. Be mindful of Cross-Site Scripting (XSS) vulnerabilities, as malicious scripts could access web storage data if your application is vulnerable. Web Storage API provides a convenient and efficient way to store client-side data, improving user experience and enabling offline capabilities in web applications.",
          "example": "// localStorage example\n// Storing data\n// localStorage.setItem('userName', 'JohnDoe');\n// localStorage.setItem('themePreference', 'dark');\n\n// Retrieving data\n// const userName = localStorage.getItem('userName');\n// const themePreference = localStorage.getItem('themePreference');\n// console.log('User Name (localStorage):', userName);\n// console.log('Theme Preference (localStorage):', themePreference);\n\n// Removing data\n// localStorage.removeItem('themePreference');\n// console.log('Theme Preference after removal:', localStorage.getItem('themePreference')); // Output: null\n\n// localStorage.clear(); // Clears all localStorage data for the origin\n\n// sessionStorage example\n// sessionStorage.setItem('sessionToken', 'xyz123sessionToken');\n// const sessionToken = sessionStorage.getItem('sessionToken');\n// console.log('Session Token (sessionStorage):', sessionToken);\n// sessionStorage.removeItem('sessionToken'); // Data is also cleared when tab/window is closed\n\n// Note: Web Storage data can be inspected in browser's developer tools (Application/Storage tab). Data persists in localStorage across sessions, but in sessionStorage only for the current session (tab/window)."
          ,
          "keyPoints": [
            "Web Storage API provides client-side storage in browsers: localStorage (persistent) and sessionStorage (session-based).",
            "localStorage: Persistent data storage, survives browser close/reopen, shared across origin.",
            "sessionStorage: Session-based data storage, cleared when tab/window closes, unique per tab/window.",
            "Common methods: `setItem`, `getItem`, `removeItem`, `clear`, `key`, `length`.",
            "Values are always stored as strings.",
            "Use cases: localStorage for user preferences, offline data; sessionStorage for temporary session data (form data, cart).",
            "Security: Data is not encrypted, be cautious with sensitive information, prevent XSS vulnerabilities."
          ],
          "quiz": [
            {
              "question": "What are the two main types of Web Storage API?",
              "options": ["cookies and localStorage", "localStorage and sessionStorage", "sessionStorage and indexedDB", "cookies and indexedDB"],
              "correctAnswer": 1
            },
            {
              "question": "Which type of Web Storage persists data even after the browser is closed?",
              "options": ["sessionStorage", "localStorage", "Both localStorage and sessionStorage", "Neither localStorage nor sessionStorage"],
              "correctAnswer": 1
            },
            {
              "question": "Which type of Web Storage is scoped to a single browser window or tab?",
              "options": ["localStorage", "sessionStorage", "Both localStorage and sessionStorage", "Neither localStorage nor sessionStorage"],
              "correctAnswer": 1
            },
            {
              "question": "What data type are values stored as in Web Storage API?",
              "options": ["Objects", "Numbers", "Strings", "Booleans"],
              "correctAnswer": 2
            },
            {
              "question": "Is data stored in Web Storage automatically encrypted?",
              "options": ["Yes, all data is encrypted by default", "No, data is not automatically encrypted", "Encryption is optional and needs to be manually enabled", "Only sessionStorage data is encrypted"],
              "correctAnswer": 1
            }
          ],
          "interactiveExamples": [
            {
              "title": "localStorage - Persistent Data Across Sessions",
              "code": "// localStorage example\nconst localStorageKey = 'visitCount';\nlet visitCount = localStorage.getItem(localStorageKey) || 0;\nvisitCount++;\nlocalStorage.setItem(localStorageKey, visitCount);\n\ndocument.getElementById('localStorageDemo').textContent = `You have visited this page ${visitCount} times (localStorage).`;\n\n// Open the page multiple times, close and reopen browser. Visit count persists due to localStorage."
            },
            {
              "title": "sessionStorage - Session-Based Data - Tab Isolation",
              "code": "// sessionStorage example\nconst sessionStorageKey = 'sessionCounter';\nlet sessionCounter = sessionStorage.getItem(sessionStorageKey) || 0;\nsessionCounter++;\nsessionStorage.setItem(sessionStorageKey, sessionCounter);\n\ndocument.getElementById('sessionStorageDemo').textContent = `Session visits: ${sessionCounter} (sessionStorage).`;\n\n// Open the page in multiple tabs. Each tab has its own session counter. Close and reopen a tab - counter resets for that tab, demonstrating session-based storage."
            }
          ]
        },
        {
          "id": "interview-js-concept-19",
          "title": "IndexedDB",
          "description": "Explain IndexedDB, its capabilities as a NoSQL database in the browser, use cases, key concepts (database, object stores, indexes, transactions), and when to use it.",
          "difficulty": "advanced",
          "category": "browser-api",
          "explanation": "IndexedDB is a powerful, low-level API for client-side storage of structured data in the browser. It's essentially a NoSQL, object-oriented database embedded in the browser, allowing you to store significant amounts of structured data, including files/blobs. IndexedDB is asynchronous and uses transactions to ensure data integrity. Key Concepts in IndexedDB: Database: Top-level container for object stores. Databases are versioned, and schema changes require version upgrades. Object Stores: Similar to tables in relational databases, but store JavaScript objects. Each object store has a key path to uniquely identify records. Indexes: Allow efficient retrieval of data from object stores based on properties other than the key path. Transactions: Operations in IndexedDB are performed within transactions, ensuring atomicity, consistency, isolation, and durability (ACID properties). Transactions are essential for maintaining data integrity. Asynchronous API: All IndexedDB operations are asynchronous, using request-based API and event handlers (like `onsuccess`, `onerror`). Key Operations: Opening a Database: Using `indexedDB.open(dbName, version)`. Requires handling `onupgradeneeded` event for database creation or schema upgrade. Creating Object Stores and Indexes: Done within `onupgradeneeded` event of database opening. Adding Data: Using transactions and object store `add()` or `put()` methods. Retrieving Data: Using transactions, object store `get()`, `getAll()`, `openCursor()`, and indexes `get()` or `openCursor()` methods. Deleting Data: Using transactions and object store `delete()` or `clear()` methods. Use Cases: Offline applications: Storing app data, assets, and user-generated content for offline functionality. Caching large datasets: Caching API responses, images, or other large data that exceeds localStorage limits. Complex data structures: Storing structured data that is not easily represented in simple key-value pairs of Web Storage. When to Use IndexedDB: When you need to store large amounts of structured data client-side, when you require indexing and complex queries, when you need transaction support for data integrity, and when Web Storage (localStorage/sessionStorage) is insufficient due to size limits or lack of structure. IndexedDB is suitable for applications needing robust client-side data storage, such as offline-first apps, complex web applications, and data-intensive web tools.",
          "example": "// IndexedDB Example - Opening database, creating object store, adding data\n// const dbName = 'myDatabase';\n// const dbVersion = 1;\n// let db;\n\n// const request = indexedDB.open(dbName, dbVersion);\n\n// request.onerror = function(event) {\n//   console.error('IndexedDB error:', event.target.errorCode);\n// };\n\n// request.onsuccess = function(event) {\n//   db = event.target.result;\n//   console.log('IndexedDB database opened successfully.');\n//   // Perform operations after database is open (e.g., add data, retrieve data)\n// };\n\n// request.onupgradeneeded = function(event) {\n//   const db = event.target.result;\n//   // Create an object store if it doesn't exist or during version upgrade\n//   if (!db.objectStoreNames.contains('myObjectStore')) {\n//     const objectStore = db.createObjectStore('myObjectStore', { keyPath: 'id', autoIncrement: true });\n//     objectStore.createIndex('nameIndex', 'name', { unique: false }); // Create an index\n//     console.log('IndexedDB object store created.');\n//   }\n// };\n\n// Function to add data (example - needs to be called after db is open in onsuccess)\n// function addData(dataObject) {\n//   const transaction = db.transaction(['myObjectStore'], 'readwrite');\n//   const objectStore = transaction.objectStore('myObjectStore');\n//   const addRequest = objectStore.add(dataObject);\n\n//   addRequest.onsuccess = function(event) {\n//     console.log('Data added successfully.');\n//   };\n\n//   addRequest.onerror = function(event) {\n//     console.error('Error adding data:', event.target.errorCode);\n//   };\n// }\n\n// Example data object:\n// const newData = { name: 'Example Item', value: 'Some value' };\n// Call addData(newData) after db is open (e.g., inside request.onsuccess)",
          "keyPoints": [
            "IndexedDB is a NoSQL, object-oriented database in the browser for structured client-side storage.",
            "Key concepts: Databases (versioned), Object Stores (like tables), Indexes (for querying), Transactions (ACID properties).",
            "Asynchronous API using requests and event handlers (`onsuccess`, `onerror`, `onupgradeneeded`).",
            "Operations within transactions for data integrity.",
            "Use cases: Offline apps, caching large datasets, complex data structures.",
            "When to use: Large structured data, indexing, transactions, exceeding Web Storage limits.",
            "Ideal for robust client-side data storage needs in web applications."
          ],
          "quiz": [
            {
              "question": "What type of database is IndexedDB?",
              "options": ["Relational database", "Document database", "NoSQL object-oriented database", "Graph database"],
              "correctAnswer": 2
            },
            {
              "question": "Are IndexedDB operations synchronous or asynchronous?",
              "options": ["Synchronous", "Asynchronous", "Both synchronous and asynchronous", "Depends on the operation"],
              "correctAnswer": 1
            },
            {
              "question": "What are 'object stores' in IndexedDB analogous to in relational databases?",
              "options": ["Databases", "Tables", "Rows", "Columns"],
              "correctAnswer": 1
            },
            {
              "question": "What is the purpose of 'transactions' in IndexedDB?",
              "options": ["To speed up database operations", "To encrypt database data", "To ensure ACID properties and data integrity", "To simplify database queries"],
              "correctAnswer": 2
            },
            {
              "question": "When is IndexedDB most appropriate to use for client-side storage?",
              "options": ["For storing small user preferences", "For caching website assets", "When you need to store large amounts of structured data and require indexing and transactions", "When you need server-side database functionality in the browser"],
              "correctAnswer": 2
            }
          ],
          "interactiveExamples": [
            {
              "title": "IndexedDB - Opening Database and Creating Object Store (Conceptual)",
              "code": "// Conceptual code - IndexedDB operations are browser-specific and asynchronous.\n// This is a simulation to understand database opening and object store creation steps.\n\nconst dbNameExample = 'myExampleDB';\nconst dbVersionExample = 1;\n\nconsole.log('Attempting to open IndexedDB:', dbNameExample, 'version:', dbVersionExample);\n\nconst openRequestSimulated = new Promise((resolve, reject) => {\n  // Simulate IndexedDB open request\n  setTimeout(() => {\n    const dbSimulated = { name: dbNameExample, version: dbVersionExample, objectStoreNames: [] }; // Simulate DB object\n    console.log('Simulated IndexedDB opened successfully:', dbSimulated.name);\n    resolve(dbSimulated);\n  }, 1000);\n});\n\nopenRequestSimulated.then(db => {\n  console.log('Simulating onupgradeneeded - checking object store...');\n  return new Promise(resolve => {\n    setTimeout(() => {\n      if (!db.objectStoreNames.includes('exampleObjectStore')) {\n        db.objectStoreNames.push('exampleObjectStore'); // Simulate object store creation\n        console.log('Simulated Object store 'exampleObjectStore' created.');\n      } else {\n        console.log('Object store 'exampleObjectStore' already exists.');\n      }\n      resolve(db);\n    }, 1000);\n  });\n}).then(db => {\n  console.log('Simulated IndexedDB setup complete. DB Info:', db);\n}).catch(error => {\n  console.error('Simulated IndexedDB error:', error);\n});\n\n// Note: This is a conceptual simulation. Real IndexedDB operations use browser's indexedDB API and event handlers."
            },
            {
              "title": "IndexedDB - Adding and Retrieving Data (Conceptual)",
              "code": "// Conceptual code - Continuing from previous example, simulating data add and retrieval.\n// (Assumes db object from previous example is available - conceptual continuation)\n\nconst dataToAddSimulated = { id: 1, itemName: 'Example Item', value: 'Sample Value' };\n\nfunction simulateAddData(db, data) {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      console.log('Simulating adding data to object store:', data);\n      // In real IndexedDB, transaction and objectStore.add() would be used.\n      resolve({ success: true, dataAdded: data });\n    }, 1000);\n  });\n}\n\nfunction simulateGetData(db, itemId) {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      console.log('Simulating retrieving data for item ID:', itemId);\n      // In real IndexedDB, transaction and objectStore.get() would be used.\n      const retrievedData = { id: itemId, itemName: 'Example Item', value: 'Sample Value' }; // Simulate retrieved data\n      resolve(retrievedData || null);\n    }, 1000);\n  });\n}\n\n// Example usage (conceptual - assumes db from previous example simulation)\nopenRequestSimulated.then(db => {\n  return simulateAddData(db, dataToAddSimulated);\n}).then(() => {\n  return simulateGetData(openRequestSimulated, 1);\n}).then(retrievedItem => {\n  console.log('Simulated Retrieved item:', retrievedItem);\n}).catch(error => {\n  console.error('Simulated Data operation error:', error);\n});\n\n// Note: This is a conceptual simulation. Real IndexedDB data operations use browser's indexedDB API within transaction contexts."
            }
          ]
        },
        {
          "id": "interview-js-concept-20",
          "title": "JSON (JavaScript Object Notation)",
          "description": "Explain JSON, its structure, data types, use cases for data interchange, and how to parse and stringify JSON in JavaScript.",
          "difficulty": "beginner",
          "category": "data-types",
          "explanation": "JSON (JavaScript Object Notation) is a lightweight format for data interchange. It is easy for humans to read and write and easy for machines to parse and generate. JSON is based on a subset of the JavaScript language (specifically, object literals and array literals) but is language-independent and used across many programming languages and platforms. JSON Structure: JSON data is built on two structures: Key-value pairs: A collection of key-value pairs, where keys are strings (enclosed in double quotes) and values can be JSON values. In JavaScript, this is similar to an object. Ordered lists of values: An ordered sequence of values. In JavaScript, this is similar to an array. JSON Data Types: JSON supports the following data types: String: Enclosed in double quotes. Number: Integer or floating-point number. Boolean: `true` or `false`. Array: Ordered list of JSON values, enclosed in square brackets `[]`. Object: Collection of key-value pairs, enclosed in curly braces `{}`. Null: `null`. Parsing and Stringifying JSON in JavaScript: `JSON.parse(jsonString)`: Parses a JSON string and converts it into a JavaScript object or array. If the JSON string is invalid, it throws a `SyntaxError`. `JSON.stringify(javascriptValue)`: Converts a JavaScript object or array into a JSON string. Useful for sending data to a server or storing it in text-based formats. Use Cases for JSON: Data interchange between a server and a web application (e.g., in AJAX requests). Configuration files. Data storage and serialization. API responses often use JSON format. JSON is a fundamental format for web development and data communication due to its simplicity, readability, and wide support.",
          "example": "// Example JSON string\nconst jsonString = '{\"name\":\"John Doe\",\"age\":30,\"isStudent\":false,\"courses\":[\"Math\",\"Science\"],\"address\":null}';\n\n// Parsing JSON string to JavaScript object\nconst jsObject = JSON.parse(jsonString);\nconsole.log('Parsed JavaScript Object:', jsObject);\nconsole.log('Name:', jsObject.name); // Accessing properties\nconsole.log('Courses:', jsObject.courses[0]); // Accessing array element\n\n// Stringifying JavaScript object to JSON string\nconst jsObjectToConvert = {\n  title: 'JavaScript Concepts',\n  author: 'Expert Dev',\n  year: 2023,\n  topics: ['Fundamentals', 'Async', 'DOM']\n};\nconst jsonOutputString = JSON.stringify(jsObjectToConvert);\nconsole.log('Stringified JSON:', jsonOutputString);\n\n// Stringify with formatting (using space and tab for indentation)\nconst formattedJsonString = JSON.stringify(jsObjectToConvert, null, 2); // 2 spaces indentation\nconsole.log('Formatted JSON (2 spaces):\\n', formattedJsonString);\nconst formattedJsonStringTab = JSON.stringify(jsObjectToConvert, null, '\\t'); // Tab indentation\nconsole.log('Formatted JSON (tab):\\n', formattedJsonStringTab);",
          "keyPoints": [
            "JSON (JavaScript Object Notation) is a lightweight, language-independent data interchange format.",
            "JSON is based on key-value pairs (objects) and ordered lists (arrays).",
            "JSON data types include string, number, boolean, array, object, and null.",
            "`JSON.parse(jsonString)` converts a JSON string to a JavaScript object/array.",
            "`JSON.stringify(javascriptValue)` converts a JavaScript object/array to a JSON string.",
            "Use cases: data interchange (web APIs), configuration files, data storage.",
            "Simple, readable, and widely supported format for web development."
          ],
          "quiz": [
            {
              "question": "What does JSON stand for?",
              "options": ["JavaScript Object Notation", "Java Super Object Name", "JavaScript Oriented Network", "JSON Object Network"],
              "correctAnswer": 0
            },
            {
              "question": "Which of the following is NOT a valid JSON data type?",
              "options": ["string", "number", "date", "boolean"],
              "correctAnswer": 2
            },
            {
              "question": "Which JavaScript method is used to parse a JSON string into a JavaScript object?",
              "options": ["`JSON.convert()`", "`JSON.parse()`", "`JSON.stringify()`", "`JSON.format()`"],
              "correctAnswer": 1
            },
            {
              "question": "In JSON, keys in key-value pairs must be enclosed in:",
              "options": ["Single quotes", "Double quotes", "Backticks", "No quotes"],
              "correctAnswer": 1
            },
            {
              "question": "What is the return value of `JSON.parse()` if the input string is not valid JSON?",
              "options": ["`null`", "`undefined`", "An empty object", "A `SyntaxError` is thrown"],
              "correctAnswer": 3
            }
          ],
          "interactiveExamples": [
            {
              "title": "Parsing JSON - Convert JSON String to JavaScript Object",
              "code": "// JSON string example\nconst jsonExampleString = '{\"name\":\"Interactive Example\",\"value\":123,\"isActive\":true,\"items\":[\"a\",\"b\",\"c\"]}';\n\n// Parse JSON string\nconst parsedObjectExample = JSON.parse(jsonExampleString);\n\nconsole.log('Parsed Object:', parsedObjectExample);\nconsole.log('Type of parsed object:', typeof parsedObjectExample);\nconsole.log('Accessing name property:', parsedObjectExample.name);\nconsole.log('Accessing items array:', parsedObjectExample.items);\n\n// Experiment by modifying jsonExampleString to invalid JSON and observe the error."
            },
            {
              "title": "Stringifying JavaScript Object - Convert Object to JSON String",
              "code": "// JavaScript object example\nconst objectExampleToStringify = {\n  title: 'Interactive JSON Example',\n  dataPoints: [10, 20, 30, 40],\n  config: { isEnabled: true, maxPoints: 50 }\n};\n\n// Stringify JavaScript object to JSON\nconst stringifiedJsonExample = JSON.stringify(objectExampleToStringify, null, 2); // Pretty print with 2 spaces\n\nconsole.log('Original Object:', objectExampleToStringify);\nconsole.log('JSON String:\\n', stringifiedJsonExample);\nconsole.log('Type of stringified JSON:', typeof stringifiedJsonExample);\n\n// Try changing the indentation level in JSON.stringify or remove it to see different JSON string formats."
            }
          ]
        },
        {
          "id": "interview-js-concept-21",
          "title": "Regular Expressions (RegExp)",
          "description": "Explain Regular Expressions in JavaScript, their syntax, patterns, use cases for string matching and manipulation, and common RegExp methods.",
          "difficulty": "intermediate",
          "category": "data-types",
          "explanation": "Regular Expressions (RegExp) are powerful patterns used to match character combinations in strings. They are essential for text processing, validation, search and replace operations, and data extraction in JavaScript and many other programming languages. RegExp Syntax and Patterns: Regular expressions are patterns composed of special symbols and characters. Some common elements include: Literal characters: Match themselves (e.g., `a`, `b`, `1`). Metacharacters: Special symbols with specific meanings (e.g., `.`, `^`, `$`, `*`, `+`, `?`, `[]`, `()`, `\\`, `|`). Character classes: `[abc]` (match a or b or c), `[^abc]` (match anything but a, b, c), `[0-9]` (match digits), `\\d` (digit), `\\w` (word character), `\\s` (whitespace). Anchors: `^` (start of string), `$` (end of string), `\\b` (word boundary). Quantifiers: `*` (0 or more), `+` (1 or more), `?` (0 or 1), `{n}` (exactly n), `{n,}` (n or more), `{n,m}` (between n and m). Grouping and capturing: `()` groups parts of a pattern, can also capture matched substrings. Flags: Modifiers that affect the search (e.g., `i` for case-insensitive, `g` for global match, `m` for multiline). Creating Regular Expressions: Using literal notation: `/pattern/flags` (e.g., `/hello/i`). Using constructor function: `new RegExp('pattern', 'flags')` (e.g., `new RegExp('hello', 'i')`). Common RegExp Methods: `test(string)`: Returns `true` if the pattern matches in the string, `false` otherwise. `exec(string)`: Returns an array with details of the match or `null` if no match is found. For global regexps, it finds the next match each time it's called. `String.prototype.match(regexp)`: Returns an array of matches or `null` if no match. Global flag `/g` affects the result. `String.prototype.replace(regexp|substr, newSubstr|function)`: Replaces matched substrings with a new substring or the result of a function. `String.prototype.search(regexp)`: Returns the index of the first match or `-1` if no match. `String.prototype.split(regexp|separator)`: Splits a string into an array of substrings using the regexp or separator. Use Cases for RegExp: Input validation (e.g., email, phone number formats). Searching and replacing text. Data extraction from strings. Parsing and tokenizing text. Regular expressions are a powerful tool for advanced string manipulation and pattern matching in JavaScript.",
          "example": "// Regular expression literal and constructor\nconst regexLiteral = /abc/i; // Literal, case-insensitive match for 'abc'\nconst regexConstructor = new RegExp('def', 'g'); // Constructor, global match for 'def'\n\n// test() method - check if pattern exists\nconsole.log('/abc/i.test(\"ABC\"):', /abc/i.test('ABC')); // Output: true (case-insensitive match)\nconsole.log('/abc/.test(\"ABC\"):', /abc/.test('ABC')); // Output: false (case-sensitive match fails)\n\n// exec() method - get match details\nconst execResult = /\\d+/.exec('Number is 123'); // Match one or more digits\nconsole.log('/\\\\d+/.exec(\"Number is 123\"):', execResult); // Output: ['123', index: 10, input: 'Number is 123', groups: undefined]\n\n// String.prototype.match() - get all matches\nconst matchResult = 'Find all digits 123 and 456'.match(/\\d+/g); // Global match for all digit sequences\nconsole.log('\"Find all digits 123 and 456\".match(/\\\\d+/g):', matchResult); // Output: ['123', '456']\n\n// String.prototype.replace() - replace matches\nconst replaceResult = 'Replace spaces with underscores'.replace(/\\s/g, '_'); // Global replace of whitespace with underscore\nconsole.log('\"Replace spaces with underscores\".replace(/\\\\s/g, \"_\"):', replaceResult); // Output: 'Replace_spaces_with_underscores'\n\n// String.prototype.search() - find index of match\nconst searchIndex = 'Search for word start'.search(/\\bstart\\b/); // Search for whole word 'start'\nconsole.log('\"Search for word start\".search(/\\\\bstart\\\\b/):', searchIndex); // Output: 15 (index of 'start')\n\n// String.prototype.split() - split string by regex\nconst splitArray = 'Split,by,comma,and,space'.split(/[,\\s]+/); // Split by comma or whitespace\nconsole.log('\"Split,by,comma,and,space\".split(/[,\\\\s]+/):', splitArray); // Output: ['Split', 'by', 'comma', 'and', 'space']",
          "keyPoints": [
            "Regular Expressions (RegExp) are patterns for matching character combinations in strings.",
            "Syntax includes literal characters, metacharacters, character classes, anchors, quantifiers, groups, and flags.",
            "Create RegExp using literal notation `/pattern/flags` or constructor `new RegExp('pattern', 'flags')`.",
            "Common RegExp methods: `test()`, `exec()`, `String.prototype.match()`, `replace()`, `search()`, `split()`. ",
            "Use cases: input validation, search/replace, data extraction, text parsing.",
            "Powerful tool for advanced string manipulation and pattern matching."
          ],
          "quiz": [
            {
              "question": "What are Regular Expressions primarily used for?",
              "options": ["Styling web pages", "Handling asynchronous operations", "Matching patterns in strings", "Managing browser history"],
              "correctAnswer": 2
            },
            {
              "question": "Which of the following is a metacharacter in Regular Expressions?",
              "options": ["`a`", "`b`", "`\\d`", "`W`"],
              "correctAnswer": 2
            },
            {
              "question": "Which RegExp method returns `true` if a pattern matches in a string, and `false` otherwise?",
              "options": ["`exec()`", "`match()`", "`test()`", "`search()`"],
              "correctAnswer": 2
            },
            {
              "question": "What does the quantifier `*` mean in Regular Expressions?",
              "options": ["Match exactly one occurrence", "Match zero or one occurrence", "Match one or more occurrences", "Match zero or more occurrences"],
              "correctAnswer": 3
            },
            {
              "question": "Which flag makes a regular expression case-insensitive?",
              "options": ["`g`", "`m`", "`i`", "`s`"],
              "correctAnswer": 2
            }
          ],
          "interactiveExamples": [
            {
              "title": "RegExp Test - Email Validation",
              "code": "// Regular expression for basic email validation\nconst emailRegex = /^[^@\\s]+@[^@\\s\\.]+\\.[^@\\s\\.]+$/;\n\nfunction validateEmail(email) {\n  return emailRegex.test(email);\n}\n\nconst email1 = 'test@example.com';\nconst email2 = 'invalid-email';\nconst email3 = 'another.test@sub.domain.net';\n\nconsole.log(`Email \"${email1}\" is valid:`, validateEmail(email1));\nconsole.log(`Email \"${email2}\" is valid:`, validateEmail(email2));\nconsole.log(`Email \"${email3}\" is valid:`, validateEmail(email3));\n\n// Experiment with different email formats to test the validation regex. Note: This is a basic validation, more robust email validation might be needed for production."
            },
            {
              "title": "RegExp Replace - String Formatting",
              "code": "// String with multiple spaces and tabs\nconst messyString = '  Leading and trailing spaces  \\t\\t  and multiple   spaces inside  ';\n\n// Regular expression to replace multiple whitespaces with a single space\nconst normalizeWhitespaceRegex = /\\s+/g;\n\n// Replace and trim\nconst normalizedString = messyString.replace(normalizeWhitespaceRegex, ' ').trim();\n\nconsole.log('Original string:', messyString);\nconsole.log('Normalized string:', normalizedString);\n\n// Modify the regex to experiment with different whitespace handling (e.g., replace with underscore, remove all whitespace)."
            }
          ]
        },
        {
          "id": "interview-js-concept-22",
          "title": "Error Handling Best Practices",
          "description": "Discuss best practices for error handling in JavaScript, including try-catch usage, error types, custom errors, and error logging.",
          "difficulty": "intermediate",
          "category": "best-practices",
          "explanation": "Effective error handling is crucial for robust and maintainable JavaScript applications. Best practices include: 1. Use `try-catch-finally` blocks appropriately: Wrap code blocks that might throw exceptions in `try` blocks. Handle errors gracefully in `catch` blocks. Use `finally` for cleanup code that should always run. Avoid excessive use of `try-catch` which can clutter code; use it strategically for potential error points. 2. Be specific with error types: Throw and catch specific error types (e.g., `TypeError`, `RangeError`, `CustomError`) to handle different error scenarios appropriately. Use `instanceof` to check error types in `catch` blocks for targeted error handling. 3. Create custom error classes: Extend the built-in `Error` class to create custom error types for application-specific errors. This improves error identification and handling relevant to your domain logic. 4. Provide informative error messages: Include clear and helpful error messages in `Error` objects to aid debugging and logging. Messages should be user-friendly where appropriate but also provide technical details for developers. 5. Implement error logging: Log errors (especially in server-side or background processes) to track issues, monitor application health, and facilitate debugging. Use logging libraries or services for structured and efficient error logging. 6. Fail gracefully: Design applications to handle errors gracefully without crashing or exposing sensitive information to users. Provide fallback mechanisms or user-friendly error pages/messages. 7. Avoid silent errors: Do not silently swallow errors (empty `catch` blocks without handling or logging). Always handle or log errors to ensure issues are not missed. 8. Consider asynchronous error handling: Use `.catch()` for Promises and `try-catch` inside `async` functions to handle asynchronous errors properly. 9. Centralize error handling: For larger applications, consider centralizing error handling logic (e.g., using error handler functions or middleware) for consistency and maintainability. 10. Test error handling: Include error scenarios in your testing to ensure error handling logic is effective and application behaves as expected under error conditions. By following these best practices, you can write more resilient, user-friendly, and maintainable JavaScript applications that handle errors effectively.",
          "example": "// Using try-catch-finally\nfunction safeOperation(value) {\n  try {\n    if (typeof value !== 'number') {\n      throw new TypeError('Input must be a number.');\n    }\n    return value * 2;\n  } catch (error) {\n    console.error('Error in safeOperation:', error.message);\n    // Handle error gracefully - e.g., return default value, notify user\n    return null; // Example: Return null on error\n  } finally {\n    console.log('safeOperation completed.'); // Cleanup or finalization\n  }\n}\n\nconsole.log('Result of safeOperation(10):', safeOperation(10));\nconsole.log('Result of safeOperation(\"abc\"):', safeOperation('abc'));\n\n// Custom Error Class\nclass ValidationError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = 'ValidationError';\n  }\n}\n\nfunction validateInput(input) {\n  if (!input) {\n    throw new ValidationError('Input cannot be empty.');\n  }\n  return 'Input validated: ' + input;\n}\n\ntry {\n  validateInput('');\n} catch (error) {\n  if (error instanceof ValidationError) {\n    console.error('Validation Error:', error.message);\n  } else {\n    console.error('Unexpected Error:', error);\n  }\n}\n\n// Asynchronous Error Handling (Async/Await)\nasync function fetchData() {\n  try {\n    const response = await fetch('https://api.example.com/data');\n    if (!response.ok) {\n      throw new Error(`HTTP error! status: ${response.status}`);\n    }\n    return await response.json();\n  } catch (error) {\n    console.error('Fetch data error:', error.message);\n    return null; // Handle fetch error\n  }\n}\n\nfetchData().then(data => console.log('Fetched data:', data));",
          "keyPoints": [
            "Use `try-catch-finally` for structured error handling.",
            "Throw and catch specific error types for targeted handling.",
            "Create custom error classes for application-specific errors.",
            "Provide informative error messages for debugging and user feedback.",
            "Implement error logging for tracking and monitoring.",
            "Design apps to fail gracefully and handle errors without crashing.",
            "Avoid silent errors; always handle or log exceptions.",
            "Handle asynchronous errors with `.catch()` and `try-catch` in `async` functions.",
            "Consider centralizing error handling for large applications.",
            "Test error handling logic to ensure effectiveness."
          ],
          "quiz": [
            {
              "question": "Which block in JavaScript is used to enclose code that might throw an exception?",
              "options": ["`error`", "`catch`", "`try`", "`finally`"],
              "correctAnswer": 2
            },
            {
              "question": "Why is it important to be specific with error types in error handling?",
              "options": ["To make code run faster", "To simplify error messages", "To handle different error scenarios appropriately", "To prevent errors from occurring"],
              "correctAnswer": 2
            },
            {
              "question": "What is a benefit of creating custom error classes?",
              "options": ["They make error handling automatic", "They improve error identification and handling for domain-specific errors", "They reduce the number of errors in code", "They simplify try-catch blocks"],
              "correctAnswer": 1
            },
            {
              "question": "What should informative error messages ideally include?",
              "options": ["Only technical details for developers", "Only user-friendly messages", "Both user-friendly messages and technical details for developers", "No messages are needed, error codes are sufficient"],
              "correctAnswer": 2
            },
            {
              "question": "What is a bad practice in error handling?",
              "options": ["Using `try-catch` blocks", "Logging errors", "Failing gracefully", "Silently swallowing errors"],
              "correctAnswer": 3
            }
          ],
          "interactiveExamples": [
            {
              "title": "Try-Catch-Finally - Interactive Error Handling",
              "code": "// Interactive example to demonstrate try-catch-finally\nfunction interactiveDivide(numeratorStr, denominatorStr) {\n  try {\n    const numerator = Number(numeratorStr);\n    const denominator = Number(denominatorStr);\n    if (isNaN(numerator) || isNaN(denominator)) {\n      throw new TypeError('Invalid input: Numerator and denominator must be numbers.');\n    }\n    if (denominator === 0) {\n      throw new Error('Cannot divide by zero.');\n    }\n    const result = numerator / denominator;\n    alert(`Result of division: ${result}`);\n  } catch (error) {\n    alert(`Error: ${error.message}`);\n    console.error('Error details:', error);\n  } finally {\n    console.log('Division attempt completed.');\n  }\n}\n\n// Get user inputs (using prompts for simplicity)\nconst numStr = prompt('Enter numerator:');\nconst denStr = prompt('Enter denominator:');\n\ninteractiveDivide(numStr, denStr);\n\n// Test with valid numbers, non-numbers, and zero denominator to see try-catch-finally in action."
            },
            {
              "title": "Custom Error Class - Validation Example",
              "code": "// Custom Validation Error class\nclass CustomValidationError extends Error {\n  constructor(message, fieldName) {\n    super(message);\n    this.name = 'CustomValidationError';\n    this.fieldName = fieldName;\n  }\n}\n\nfunction validateFormInput(inputData) {\n  if (!inputData.name) {\n    throw new CustomValidationError('Name is required', 'name');\n  } else if (inputData.age <= 0) {\n    throw new CustomValidationError('Age must be positive', 'age');\n  }\n  return 'Input valid';\n}\n\nconst formInput = { name: '', age: -5 }; // Example invalid input\n\ntry {\n  validateFormInput(formInput);\n} catch (error) {\n  if (error instanceof CustomValidationError) {\n    alert(`Validation Error in field '${error.fieldName}': ${error.message}`);\n    console.warn('Validation error details:', error);\n  } else {\n    alert('An unexpected error occurred.');\n    console.error('Unexpected error:', error);\n  }\n}\n\n// Modify formInput to test different validation errors and see custom error handling."
            }
          ]
        },
        {
          "id": "interview-js-concept-23",
          "title": "JavaScript Performance Optimization Techniques",
          "description": "Discuss JavaScript performance optimization techniques, including code optimization, DOM manipulation optimization, and memory management.",
          "difficulty": "advanced",
          "category": "performance",
          "explanation": "Optimizing JavaScript performance is crucial for creating fast and responsive web applications. Key techniques include: 1. Code Optimization: Minimize JavaScript execution time: Reduce complexity of algorithms, optimize loops, avoid unnecessary computations. Use efficient data structures and algorithms. Debounce and throttle functions to limit function execution frequency, especially for event handlers. Lazy loading: Load resources (images, scripts, modules) only when needed to reduce initial load time. Code splitting: Break down large JavaScript bundles into smaller chunks that can be loaded on demand. Minification and compression: Reduce code size by removing whitespace, comments, and shortening variable names (minification) and using compression algorithms (gzip, Brotli) for server responses. 2. DOM Manipulation Optimization: Minimize DOM operations: DOM manipulations are expensive. Batch DOM updates to reduce reflows and repaints. Use document fragments for batch DOM changes before appending to the document. Cache DOM element references to avoid repeated lookups. Optimize CSS selectors: Use efficient CSS selectors (class-based selectors are generally faster than tag or ID selectors in complex stylesheets). Reduce CSS reflows and repaints: Avoid forced synchronous layout, minimize layout thrashing, and optimize CSS for rendering performance. 3. Memory Management: Optimize memory usage and prevent leaks: Understand JavaScript memory management and garbage collection. Avoid accidental global variables. Clear timers and event listeners when not needed to prevent memory leaks. Manage closures carefully to avoid unintentional variable retention. Use Web Workers for CPU-intensive tasks: Offload heavy computations to background threads to keep the main thread responsive. 4. Asynchronous Operations Optimization: Optimize asynchronous code: Use Promises and Async/Await for cleaner and more efficient asynchronous code. Optimize network requests: Reduce number of requests, minimize request size, use caching strategies (browser cache, Service Worker caching), use CDN for static assets. 5. Profiling and Performance Monitoring: Use browser developer tools (Performance tab, Profiler) to identify performance bottlenecks. Regularly profile your code to detect and address performance issues. Monitor application performance in production using performance monitoring tools. By applying these optimization techniques, you can significantly improve the performance and responsiveness of your JavaScript applications, leading to a better user experience.",
          "example": "// Code Optimization - Loop optimization\n// Inefficient loop\n// console.time('inefficientLoop');\n// const array = new Array(1000000).fill(0);\n// for (let i = 0; i < array.length; i++) { /* ... */ }\n// console.timeEnd('inefficientLoop');\n\n// Efficient loop - caching array length\n// console.time('efficientLoop');\n// const arrayEfficient = new Array(1000000).fill(0);\n// for (let i = 0, length = arrayEfficient.length; i < length; i++) { /* ... */ }\n// console.timeEnd('efficientLoop');\n\n// DOM Manipulation Optimization - Document Fragment\n// const list = document.getElementById('performanceList');\n// const fragment = document.createDocumentFragment(); // Create document fragment\n// console.time('fragmentDOM');\n// for (let i = 0; i < 1000; i++) {\n//   const listItem = document.createElement('li');\n//   listItem.textContent = `Item ${i + 1}`;\n//   fragment.appendChild(listItem); // Append to fragment\n// }\n// list.appendChild(fragment); // Append fragment to DOM once\n// console.timeEnd('fragmentDOM');\n\n// Memory Management - Clearing Timers\n// let timerIdExample;\n// function startTimerExample() {\n//   timerIdExample = setInterval(() => {\n//     console.log('Timer ticking...');\n//   }, 1000);\n// }\n// function stopTimerExample() {\n//   clearInterval(timerIdExample); // Clear timer to prevent memory leak\n//   console.log('Timer cleared.');\n// }\n// startTimerExample();\n// setTimeout(stopTimerExample, 5000); // Stop timer after 5 seconds",
          "keyPoints": [
            "Optimize JavaScript code: efficient algorithms, loops, lazy loading, code splitting, minification.",
            "Minimize DOM operations: batch updates, document fragments, cache element references, efficient CSS selectors.",
            "Optimize memory management: avoid global variables, clear timers, manage closures, use Web Workers for heavy tasks.",
            "Optimize asynchronous operations: Promises/AsyncAwait, reduce network requests, caching, CDN.",
            "Use browser developer tools for profiling and performance monitoring.",
            "Regularly profile and test to identify and address performance bottlenecks."
          ],
          "quiz": [
            {
              "question": "Which of the following is a JavaScript performance optimization technique?",
              "options": ["Increasing code verbosity", "Using synchronous operations for everything", "Minimizing DOM manipulations", "Ignoring error handling for speed"],
              "correctAnswer": 2
            },
            {
              "question": "What is the benefit of using document fragments for DOM manipulation?",
              "options": ["They make DOM operations synchronous", "They reduce the number of reflows and repaints", "They automatically optimize JavaScript code", "They simplify CSS styling"],
              "correctAnswer": 1
            },
            {
              "question": "Why is caching DOM element references considered a performance optimization?",
              "options": ["It reduces memory usage", "It avoids repeated DOM lookups, which can be slow", "It makes code more readable", "It automatically updates the DOM"],
              "correctAnswer": 1
            },
            {
              "question": "What is 'code splitting' in the context of JavaScript performance optimization?",
              "options": ["Splitting code into multiple files for better organization", "Breaking down large JavaScript bundles into smaller, on-demand chunks", "Splitting code into synchronous and asynchronous parts", "Splitting code for different browsers"],
              "correctAnswer": 1
            },
            {
              "question": "Which browser tool is most useful for identifying JavaScript performance bottlenecks?",
              "options": ["Console", "Elements inspector", "Performance tab/Profiler", "Sources tab"],
              "correctAnswer": 2
            }
          ],
          "interactiveExamples": [
            {
              "title": "DOM Manipulation Optimization - Document Fragment vs Direct DOM",
              "code": "// HTML (add an empty ul with id 'listContainer' to body)\nconst listContainer = document.getElementById('listContainer');\nconst itemCount = 1000; // Number of list items to create\n\n// Method 1: Direct DOM manipulation (less efficient)\nconsole.time('directDOM');\nfor (let i = 0; i < itemCount; i++) {\n  const listItem = document.createElement('li');\n  listItem.textContent = `Item ${i + 1}`;\n  listContainer.appendChild(listItem); // Direct DOM append in each iteration\n}\nconsole.timeEnd('directDOM');\n\n// Clear list for next test\nlistContainer.innerHTML = '';\n\n// Method 2: Document Fragment (more efficient)\nconst fragmentExample = document.createDocumentFragment();\nconsole.time('fragmentDOM');\nfor (let i = 0; i < itemCount; i++) {\n  const listItem = document.createElement('li');\n  listItem.textContent = `Item ${i + 1}`;\n  fragmentExample.appendChild(listItem); // Append to fragment\n}\nlistContainer.appendChild(fragmentExample); // Append fragment once to DOM\nconsole.timeEnd('fragmentDOM');\n\n// Compare 'directDOM' and 'fragmentDOM' timings in console - fragment method should be significantly faster, especially for larger itemCount."
            },
            {
              "title": "Code Optimization - Loop Efficiency",
              "code": "// Example: Loop with array length cached vs. uncached\nconst largeArray = new Array(1000000).fill(0);\n\n// Uncached length - recalculated in each iteration\nconsole.time('loopUncachedLength');\nfor (let i = 0; i < largeArray.length; i++) { /* Empty loop body */ }\nconsole.timeEnd('loopUncachedLength');\n\n// Cached length - length is stored in a variable before loop\nconsole.time('loopCachedLength');\nconst arrayLength = largeArray.length;\nfor (let i = 0; i < arrayLength; i++) { /* Empty loop body */ }\nconsole.timeEnd('loopCachedLength');\n\n// Compare 'loopUncachedLength' and 'loopCachedLength' timings in console. Cached length loop is generally faster because it avoids repeated .length property access in each iteration."
            }
          ]
        },
        {
          "id": "interview-js-concept-24",
          "title": "Cross-Origin Resource Sharing (CORS)",
          "description": "Explain CORS, its purpose for web security, how it works, common CORS headers, and how to handle CORS issues in JavaScript.",
          "difficulty": "intermediate",
          "category": "browser-api",
          "explanation": "Cross-Origin Resource Sharing (CORS) is a browser security feature that restricts web pages from making requests to a different domain than the one that served the web page. This mechanism is in place to prevent malicious scripts on one page from accessing sensitive data on another domain without permission, enhancing web security. Same-Origin Policy (SOP): CORS is a relaxation of the Same-Origin Policy, which is a fundamental security policy in browsers. SOP restricts JavaScript code running from one origin from making requests to a different origin. Origin is defined by protocol, domain, and port. CORS allows controlled cross-origin requests under specific conditions. How CORS Works: When a browser makes a cross-origin request (e.g., from `http://domain-a.com` to `http://domain-b.com`), the browser automatically adds the `Origin` header to the request, indicating the origin of the requesting page (`http://domain-a.com`). The server at `http://domain-b.com` can then decide whether to allow the request based on the `Origin` header. Server-Side CORS Headers: To allow cross-origin requests, the server at `http://domain-b.com` needs to include specific CORS headers in its HTTP responses: `Access-Control-Allow-Origin`: Specifies the origin(s) that are allowed to access the resource. Can be a specific origin or `*` (allow all origins - generally not recommended for production). `Access-Control-Allow-Methods`: Specifies the HTTP methods allowed for cross-origin requests (e.g., `GET`, `POST`, `PUT`, `DELETE`, `OPTIONS`). `Access-Control-Allow-Headers`: Specifies which headers are allowed in the actual request when making a 'preflight' request. `Access-Control-Expose-Headers`: Specifies which response headers can be exposed to the client-side JavaScript code. `Access-Control-Allow-Credentials`: Indicates if the browser should include credentials (cookies, HTTP authentication) in cross-origin requests. Preflight Requests (OPTIONS): For 'complex' cross-origin requests (e.g., `POST` with Content-Type `application/json` or custom headers), browsers send a 'preflight' `OPTIONS` request first to check if the actual request is allowed by the server. Handling CORS Issues in JavaScript: Client-Side: If you encounter CORS errors in JavaScript (e.g., fetch API failing with CORS error), it means the server you are requesting data from has not configured CORS headers to allow your origin. You typically cannot bypass CORS restrictions from client-side JavaScript due to browser security policies. Server-Side: CORS is primarily configured and handled on the server-side. If you control the server, you need to configure it to send appropriate `Access-Control-Allow-Origin` and other CORS headers in responses to allow cross-origin requests from your client application. Common CORS Error: \"No 'Access-Control-Allow-Origin' header is present on the requested resource\". This indicates that the server did not include the necessary CORS headers to allow cross-origin access from your web page's origin.",
          "example": "// Example of a cross-origin fetch request (potential CORS issue)\n// fetch('https://api.another-domain.com/data') // Request to a different domain\n//   .then(response => {\n//     if (!response.ok) {\n//       throw new Error(`HTTP error! status: ${response.status}`);\n//     }\n//     return response.json();\n//   })\n//   .then(data => {\n//     console.log('Data from cross-origin API:', data);\n//   }) .catch(error => {\n//     console.error('Fetch error:', error);\n//     // If you see a CORS error in console here, it means the server at 'https://api.another-domain.com/data' is not sending appropriate CORS headers to allow cross-origin requests from your domain.\n//   });\n\n// Note: To fix CORS issues, you need to configure the server at 'https://api.another-domain.com/data' to send CORS headers like 'Access-Control-Allow-Origin' in its responses. Client-side JavaScript cannot bypass CORS restrictions enforced by browsers for security reasons."
              ,
              "keyPoints": [
                "CORS (Cross-Origin Resource Sharing) is a browser security feature to restrict cross-origin requests.",
                "Prevents malicious scripts from accessing data on different domains without permission (Same-Origin Policy relaxation).",
                "Browser adds 'Origin' header to cross-origin requests.",
                "Server must send CORS headers in responses to allow cross-origin access.",
                "Key CORS headers: `Access-Control-Allow-Origin`, `Methods`, `Headers`, `Expose-Headers`, `Credentials`.",
                "Preflight `OPTIONS` requests for 'complex' cross-origin requests.",
                "CORS errors indicate server-side misconfiguration; client-side JavaScript cannot bypass CORS.",
                "Configure server to send `Access-Control-Allow-Origin` and other headers to resolve CORS issues."
              ],
              "quiz": [
                {
                  "question": "What is the primary purpose of CORS (Cross-Origin Resource Sharing)?",
                  "options": ["To improve website performance", "To enable server-side rendering", "To enhance web security by controlling cross-origin requests", "To simplify JavaScript code"],
                  "correctAnswer": 2
                },
                {
                  "question": "Which HTTP header is used by the browser to indicate the origin of a cross-origin request?",
                  "options": ["`Content-Type`", "`Origin`", "`Referer`", "`Host`"],
                  "correctAnswer": 1
                },
                {
                  "question": "Which CORS header does the server use to specify the allowed origins for cross-origin requests?",
                  "options": ["`Access-Control-Request-Origin`", "`Origin-Allow-Control-Access`", "`Access-Control-Allow-Origin`", "`Allow-Origin-Access-Control`"],
                  "correctAnswer": 2
                },
                {
                  "question": "What type of HTTP request is sent by the browser as a 'preflight' request in CORS?",
                  "options": ["`GET`", "`POST`", "`PUT`", "`OPTIONS`"],
                  "correctAnswer": 3
                },
                {
                  "question": "Can client-side JavaScript bypass CORS restrictions enforced by browsers?",
                  "options": ["Yes, using specific JavaScript techniques", "Yes, but only for simple GET requests", "No, CORS is a browser security feature and cannot be bypassed client-side", "Only in development mode"],
                  "correctAnswer": 2
                }
              ],
              "interactiveExamples": [
                {
                  "title": "Simulating CORS Request - Observe Browser Behavior (Conceptual)",
                  "code": "// Conceptual code - CORS behavior is browser-enforced and server-dependent.\n// This is a simulation to observe the concept.\n\nconst targetOrigin = 'https://api.example-cors-protected.com'; // Replace with a real CORS-protected API if testing live\nconst requestURL = `${targetOrigin}/data`;\n\nconsole.log('Attempting cross-origin fetch to:', requestURL);\n\nfetch(requestURL, { mode: 'cors' }) // mode: 'cors' is default for cross-origin fetches\n  .then(response => {\n    if (response.ok) {\n      console.log('CORS Request successful (if server is properly configured).');\n      return response.json();\n    } else {\n      console.error('CORS Request failed - HTTP status:', response.status);\n      return null;\n    }\n  })\n  .then(data => {\n    if (data) {\n      console.log('Data received:', data);\n    }\n  }.catch(error => {\n    console.error('CORS Fetch error:', error); // CORS error will be logged here if server does not allow origin.\n    console.error('Check browser console for detailed CORS error message.');\n  });\n\n// Note: This is a conceptual example. To actually demonstrate CORS, you would need a server at 'https://api.example-cors-protected.com' configured to either allow or deny cross-origin requests from your domain and observe the browser's behavior in network requests and console errors."
                },
                {
                  "title": "CORS Preflight Request - Observing OPTIONS Request in Network Tab (Conceptual)",
                  "code": "// Conceptual example - CORS preflight is browser-initiated, observe in Network tab.\n// To observe preflight, you'd typically make a 'complex' cross-origin request (e.g., POST with JSON).\n\nconst targetOriginComplex = 'https://api.example-cors-protected-complex.com'; // Replace with a real CORS-protected API for complex requests\nconst complexRequestURL = `${targetOriginComplex}/submit-data`;\n\nconsole.log('Attempting complex cross-origin POST request (expecting preflight)...');\n\nfetch(complexRequestURL, {\n  method: 'POST',\n  mode: 'cors',\n  headers: {\n    'Content-Type': 'application/json' // Complex request due to Content-Type\n  },\n  body: JSON.stringify({ key: 'value', data: 'complex data' })\n})\n  .then(response => {\n    if (response.ok) {\n      console.log('Complex CORS POST Request successful (if server handles preflight).');\n      return response.json();\n    } else {\n      console.error('Complex CORS POST Request failed - HTTP status:', response.status);\n      return null;\n    }\n  })\n  .then(data => {\n    if (data) {\n      console.log('Data received from complex request:', data);\n    }\n  })\n  .catch(error => {\n    console.error('Complex CORS Fetch error:', error);\n    console.error('Check browser Network tab to see OPTIONS preflight request and server responses.'); // Key observation point\n  });\n\n// Note: Run this code and open browser's developer tools, Network tab. You should observe an initial OPTIONS request (preflight) before the actual POST request if the request is considered 'complex' by CORS. The server's response to OPTIONS determines if the POST request will proceed."
                }
              ]
            },
            
{
  "id": "interview-js-concept-25",
  "title": "Progressive Web Apps (PWAs)",
  "description": "Explain Progressive Web Apps (PWAs), their key characteristics, benefits, and core technologies (Service Workers, Manifest, HTTPS).",
  "difficulty": "intermediate",
  "category": "browser-api",
  "explanation": "Progressive Web Apps (PWAs) are web applications that are designed to provide an enhanced user experience by leveraging modern web capabilities to deliver app-like features. PWAs aim to bridge the gap between traditional websites and native mobile applications, offering a user experience that is fast, reliable, and engaging. Key Characteristics of PWAs: Progressive: Work for every user, regardless of browser choice, as they are built with progressive enhancement as a core principle. Reliable: Load instantly and work reliably regardless of the network conditions (offline, on slow networks) thanks to Service Workers. Fast: Respond quickly to user interactions with smooth animations and no janky scrolling. Engaging: Offer an immersive user experience, feeling like a natural app on the device with features like home screen install and push notifications. Responsive: Fit any form factor: desktop, mobile, tablet, or whatever is next. Connectivity independent: Enhanced with service workers to work offline or on low quality networks. App-like: Use app-style interactions and navigation. Fresh: Always up-to-date thanks to the service worker update process. Safe: Served via HTTPS to prevent snooping and ensure content hasn't been tampered with. Discoverable: Are identifiable as 'applications' thanks to W3C manifests and Service Worker registration scope, allowing search engines to find them. Re-engageable: Features like push notifications make re-engagement easy. Installable: Allow users to 'install' apps on their home screen without going through an app store. Core Technologies for PWAs: Service Workers: Enable offline capabilities, caching, push notifications, background sync, and more. Web App Manifest: JSON file that provides metadata about the application (name, icons, theme color, display mode), allowing the browser to treat the web app like a native app when installed. HTTPS: Required for security, especially for Service Workers and installability. Benefits of PWAs: Improved User Experience: Fast loading, offline access, app-like interactions. Increased Engagement: Home screen install, push notifications for re-engagement. Broader Reach: Work on any device with a modern browser, no need for separate app development for different platforms. Cost-Effective Development: Single codebase for web and app experience, reducing development and maintenance costs. Discoverability: PWAs are still websites, making them discoverable via search engines. PWAs represent a significant evolution in web development, offering a compelling alternative to native apps for many use cases.",
  "example": "// Example of a Web App Manifest file (manifest.json)\n// {\n//   \"name\": \"My Awesome PWA\",\n//   \"short_name\": \"AwesomePWA\",\n//   \"icons\": [\n//     {\n//       \"src\": \"/icons/icon-192x192.png\",\n//       \"sizes\": \"192x192\",\n//       \"type\": \"image/png\"\n//     },\n//     {\n//       \"src\": \"/icons/icon-512x512.png\",\n//       \"sizes\": \"512x512\",\n//       \"type\": \"image/png\"\n//     }\n//   ],\n//   \"theme_color\": \"#ffffff\",\n//   \"background_color\": \"#ffffff\",\n//   \"display\": \"standalone\",\n//   \"start_url\": \".\",\n//   \"scope\": \".\",\n//   \"orientation\": \"portrait\"\n// }\n\n// Example of registering Service Worker (in main JavaScript file)\n// if ('serviceWorker' in navigator) {\n//   window.addEventListener('load', () => {\n//     navigator.serviceWorker.register('/service-worker.js')\n//       .then(registration => {\n//         console.log('ServiceWorker registration successful with scope: ', registration.scope);\n//       },\n//       error => {\n//         console.error('ServiceWorker registration failed: ', error);\n//       });\n//   });\n// }\n\n// Note: PWA example involves multiple components (manifest.json, service-worker.js, HTTPS setup) and needs to be deployed in a web server environment to fully demonstrate PWA features like installability and offline capability.",
  "keyPoints": [
    "PWAs (Progressive Web Apps) aim to provide app-like experiences on the web.",
    "Key characteristics: Progressive, Reliable, Fast, Engaging, Responsive, Connectivity independent, App-like, Fresh, Safe, Discoverable, Re-engageable, Installable.",
    "Core technologies: Service Workers (offline, push, sync), Web App Manifest (metadata, installability), HTTPS (security).",
    "Service Workers enable offline functionality, caching, push notifications.",
    "Web App Manifest makes web apps installable on home screens, defines app appearance.",
    "HTTPS is essential for security and enabling PWA features.",
    "Benefits: Improved UX, increased engagement, broader reach, cost-effective development, discoverability.",
    "PWAs bridge the gap between web and native apps, offering a compelling web application model."
  ],
  "quiz": [
    {
      "question": "What is the primary goal of Progressive Web Apps (PWAs)?",
      "options": ["To replace native mobile applications completely", "To make websites faster for developers to code", "To provide an enhanced, app-like user experience on the web", "To remove the need for web servers"],
      "correctAnswer": 2
    },
    {
      "question": "Which technology enables offline capabilities in PWAs?",
      "options": ["Web Storage API", "Web Workers", "Service Workers", "IndexedDB"],
      "correctAnswer": 2
    },
    {
      "question": "What is the purpose of the Web App Manifest file in PWAs?",
      "options": ["To define the server-side logic of the PWA", "To specify the offline caching strategy", "To provide metadata about the app and enable installability", "To handle push notifications"],
      "correctAnswer": 2
    },
    {
      "question": "Is HTTPS required for PWAs, and if so, why?",
      "options": ["No, PWAs can work over HTTP", "Yes, HTTPS is required for performance reasons", "Yes, HTTPS is required for security and to enable Service Workers and installability", "HTTPS is recommended but not mandatory"],
      "correctAnswer": 2
    },
    {
      "question": "Which of the following is NOT a key characteristic of a PWA?",
      "options": ["Reliable", "Fast", "Installable", "Requires app store distribution"],
      "correctAnswer": 3
    }
  ],
  "interactiveExamples": [
    {
      "title": "PWA Manifest - Simulate PWA Install Prompt (Conceptual)",
      "code": "// Conceptual code - Browser PWA install prompt is browser-driven.\n// This simulates the conditions and checks for installability.\n\nconsole.log('Checking if PWA is installable...');\n\nconst isManifestPresent = true; // Simulate manifest file presence (check for manifest.json in <head><link rel=\"manifest\" ... >)\nconst isServiceWorkerRegistered = true; // Simulate Service Worker registration (navigator.serviceWorker.register() success)\nconst isHTTPS = (window.location.protocol === 'https:' || window.location.hostname === 'localhost'); // HTTPS or localhost\n\nif (isManifestPresent && isServiceWorkerRegistered && isHTTPS) {\n  console.log('PWA install criteria met. Install prompt might be shown by browser.');\n  // In a real PWA, browser automatically detects manifest and SW and prompts for install based on heuristics (e.g., user engagement).\n  alert('PWA installable! (Conceptual Demo)'); // Simulate install prompt\n} else {\n  console.log('PWA install criteria NOT met.');\n  if (!isManifestPresent) console.log('- Manifest file missing or not linked.');\n  if (!isServiceWorkerRegistered) console.log('- Service Worker not registered.');\n  if (!isHTTPS) console.log('- Not served over HTTPS (or localhost).');\n}\n\n// Note: This is a conceptual simulation. PWA install prompt appearance is browser-controlled and depends on various factors beyond just manifest and SW presence."
    },
    {
      "title": "Service Worker Caching - Offline Simulation (Conceptual)",
      "code": "// Conceptual code - Offline behavior is Service Worker-driven, simulate network status.\n// For real offline testing, disconnect network or use browser's offline mode in DevTools.\n\nlet isOnline = navigator.onLine; // Check initial online status\n\nfunction updateOnlineStatus() {\n  isOnline = navigator.onLine;\n  console.log('Online status changed:', isOnline ? 'Online' : 'Offline');\n  document.getElementById('onlineStatus').textContent = isOnline ? 'Online' : 'Offline (Simulated)';\n}\n\nwindow.addEventListener('online',  updateOnlineStatus);\nwindow.addEventListener('offline', updateOnlineStatus);\n\nupdateOnlineStatus(); // Initial status\n\nfunction simulateFetchResource(resourceURL) {\n  console.log(`Simulating fetch for: ${resourceURL}, Online: ${isOnline}`);\n  if (isOnline) {\n    console.log(`- Simulating network fetch for ${resourceURL} (Online mode).`);\n    return Promise.resolve({ status: 200, data: `Data from network for ${resourceURL}` }); // Simulate network response\n  } else {console.log(`- Simulating cache fetch for ${resourceURL} (Offline mode).`);\n    return Promise.resolve({ status: 200, data: `Data from cache (simulated) for ${resourceURL}` }); // Simulate cache response\n  }\n}\n\n// Example fetch simulation\nsimulateFetchResource('/api/data').then(response => {\n  if (response.status === 200) {\n    console.log('Fetch result:', response.data);\n    document.getElementById('fetchResult').textContent = response.data;\n  }\n});\n\n// Toggle browser's online/offline mode in DevTools (Network tab) to see different behavior (real PWAs use Service Worker caching, this is a simplified simulation).\n\n// HTML (add to body):\n// <div id='onlineStatus'></div>\n// <div id='fetchResult'></div>\n// <p>Toggle browser's offline mode in DevTools (Network tab) to simulate offline/online behavior.</p>"
        }
      ]
    },
    {
      "id": "interview-js-concept-26",
      "title": "WebSockets",
      "description": "Explain WebSockets, their difference from HTTP, use cases for real-time communication, and how to implement WebSockets in JavaScript.",
      "difficulty": "intermediate",
      "category": "browser-api",
      "explanation": "WebSockets are a communication protocol that provides full-duplex communication channels over a single TCP connection. Unlike HTTP, which is request-response based and typically stateless, WebSockets enable persistent, bidirectional communication between a client and a server in real-time. Key Differences from HTTP: HTTP: Request-response protocol: Client sends a request, server sends a response. Stateless: Each request is independent; the server does not maintain connection state between requests (in typical scenarios). Half-duplex (or simplex in older HTTP/1.0): Communication is primarily unidirectional or request-response oriented. Overhead: HTTP headers are sent with each request/response, adding overhead for frequent small data exchanges. WebSocket: Full-duplex protocol: Allows bidirectional, simultaneous communication between client and server. Stateful: Maintains a persistent connection between client and server, allowing for continuous data exchange. Real-time: Designed for real-time applications, enabling instant data updates and interactions. Lower overhead: After initial handshake, data transfer is more efficient with less header overhead compared to HTTP for continuous communication. Use Cases for WebSockets: Real-time chat applications. Online gaming (real-time multiplayer interactions). Real-time dashboards and analytics. Collaborative editing and applications. Live sports updates, stock tickers, and social media feeds. Implementing WebSockets in JavaScript: Creating a WebSocket Connection: `const websocket = new WebSocket('ws://example.com/socketserver');` (or `wss://` for secure WebSocket). WebSocket Events: `onopen`: Triggered when the connection is successfully opened. `onmessage`: Triggered when a message is received from the server. `onerror`: Triggered when an error occurs during communication. `onclose`: Triggered when the connection is closed. Sending and Receiving Data: `websocket.send(data)`: Sends data to the server. Data is typically a string, but can also be Blob, ArrayBuffer, or ArrayBufferView. `event.data` in `onmessage` handler: Contains the received message data from the server. Closing the Connection: `websocket.close()`: Closes the WebSocket connection. WebSockets are ideal for applications requiring real-time, bidirectional communication, offering a significant advantage over traditional HTTP for such scenarios.",
      "example": "// JavaScript WebSocket Client Example\n// const websocket = new WebSocket('ws://echo.websocket.events'); // Example echo server for testing\n\n// websocket.onopen = function(event) {\n//   console.log('WebSocket connection opened.');\n//   websocket.send('Hello WebSocket Server!'); // Send initial message to server\n// };\n\n// websocket.onmessage = function(event) {\n//   console.log('Message from server:', event.data);\n//   // Handle incoming message, e.g., update UI, process data\n// };\n\n// websocket.onerror = function(error) {\n//   console.error('WebSocket error:', error);\n// };\n\n// websocket.onclose = function() {\n//   console.log('WebSocket connection closed.');\n// };\n\n// Function to send message to server\n// function sendMessageToServer(message) {\n//   if (websocket.readyState === WebSocket.OPEN) {\n//     websocket.send(message);\n//   } else {\n//     console.error('WebSocket is not open. Cannot send message.');\n//   }\n// }\n\n// Example usage: setTimeout(() => sendMessageToServer('Another message after 3 seconds'), 3000);",
      "keyPoints": [
        "WebSockets enable full-duplex, real-time, bidirectional communication over a single TCP connection.",
        "Unlike HTTP (request-response, stateless), WebSockets are stateful and persistent.",
        "Lower overhead than HTTP for continuous data exchange after initial handshake.",
        "Use cases: real-time chat, online gaming, live dashboards, collaborative apps, live updates.",
        "Implement in JavaScript using `new WebSocket('ws://...')` or `wss://...` (secure).",
        "Key WebSocket events: `onopen`, `onmessage`, `onerror`, `onclose`.",
        "Send data using `websocket.send(data)`, receive data in `onmessage` event handler (`event.data`).",
        "`websocket.close()` to close connection."
      ],
      "quiz": [
        {
          "question": "What type of communication does WebSocket primarily enable?",
          "options": ["Request-response", "Unidirectional", "Full-duplex, bidirectional", "Broadcast"],
          "correctAnswer": 2
        },
        {
          "question": "How does WebSocket communication differ from traditional HTTP communication?",
          "options": ["HTTP is full-duplex, WebSocket is request-response", "HTTP is stateful, WebSocket is stateless", "HTTP is request-response and stateless, WebSocket is full-duplex and stateful", "There is no significant difference"],
          "correctAnswer": 2
        },
        {
          "question": "Which event is triggered when a WebSocket connection is successfully established?",
          "options": ["`onmessage`", "`onerror`", "`onclose`", "`onopen`"],
          "correctAnswer": 3
        },
        {
          "question": "How do you send data to a WebSocket server from a JavaScript client?",
          "options": ["Using `websocket.receive(data)`", "Using `websocket.send(data)`", "Using `websocket.write(data)`", "Using `websocket.transmit(data)`"],
          "correctAnswer": 1
        },
        {
          "question": "For applications requiring real-time, bidirectional data flow, which communication protocol is more suitable?",
          "options": ["HTTP", "HTTPS", "WebSocket", "AJAX"],
          "correctAnswer": 2
        }
      ],
      "interactiveExamples": [
        {
          "title": "Basic WebSocket Connection - Echo Test (Client-Side)",
          "code": "// HTML (add a div for output to body): <div id='websocketOutput'></div>\nconst websocketOutputDiv = document.getElementById('websocketOutput');\nconst websocketExample = new WebSocket('wss://echo.websocket.events'); // Using a public WebSocket echo server\n\nwebsocketExample.onopen = function(event) {\n  websocketOutputDiv.innerHTML += '<p>WebSocket connection opened.</p>';\n  websocketExample.send('Hello, WebSocket echo server!');\n};\n\nwebsocketExample.onmessage = function(event) {\n  websocketOutputDiv.innerHTML += '<p>Server echoed: ' + event.data + '</p>';\n};\n\nwebsocketExample.onerror = function(error) {\n  websocketOutputDiv.innerHTML += '<p style=\"color: red;\">WebSocket error: ' + error + '</p>';\n};\n\nwebsocketExample.onclose = function() {\n  websocketOutputDiv.innerHTML += '<p>WebSocket connection closed.</p>';\n};\n\n// Open this HTML in a browser. It connects to a public WebSocket echo server, sends a message, and displays the echoed response in the div."
        },
        {
          "title": "WebSocket Send and Receive - Interactive Messaging (Client-Side)",
          "code": "// HTML (add input, button, and output div to body):\n// <input type='text' id='messageInput' placeholder='Enter message'>\n// <button id='sendMessageButton'>Send Message</button>\n// <div id='websocketMessages'></div>\n\nconst messageInput = document.getElementById('messageInput');\nconst sendMessageButton = document.getElementById('sendMessageButton');\nconst websocketMessagesDiv = document.getElementById('websocketMessages');\nconst interactiveWebSocket = new WebSocket('wss://echo.websocket.events');\n\ninteractiveWebSocket.onopen = function(event) {\n  websocketMessagesDiv.innerHTML += '<p>WebSocket connection opened.</p>';\n};\n\ninteractiveWebSocket.onmessage = function(event) {\n  websocketMessagesDiv.innerHTML += '<p>Server Message: ' + event.data + '</p>';\n};\n\nsendMessageButton.onclick = function() {\n  const message = messageInput.value;\n  if (interactiveWebSocket.readyState === WebSocket.OPEN && message) {\n    interactiveWebSocket.send(message);\n    websocketMessagesDiv.innerHTML += '<p>Client Message Sent: ' + message + '</p>';\n    messageInput.value = ''; // Clear input field\n  } else {\n    alert('WebSocket not open or message empty.');\n  }\n};\n\ninteractiveWebSocket.onclose = function() {\n  websocketMessagesDiv.innerHTML += '<p>WebSocket connection closed.</p>';\n};\n\n// Open HTML in browser. Type a message in the input and click 'Send Message'. Messages sent and echoed back from the server are displayed in the output div, demonstrating interactive WebSocket messaging."
        }
      ]
    },
    {
      "id": "interview-js-concept-27",
      "title": "Long Polling vs WebSockets vs Server-Sent Events (SSE)",
      "description": "Compare and contrast Long Polling, WebSockets, and Server-Sent Events (SSE) for real-time web communication, highlighting their differences, use cases, and overhead.",
      "difficulty": "advanced",
      "category": "browser-api",
      "explanation": "For real-time web communication, several technologies exist, each with different characteristics and use cases. Comparing Long Polling, WebSockets, and Server-Sent Events (SSE) is crucial for choosing the right approach. Long Polling: Technique for simulating push notifications over HTTP. Client makes an HTTP request to the server and keeps the connection open. Server holds the request open until new data is available or a timeout occurs, then sends a response. Client immediately sends a new request to repeat the process. Simulates real-time updates but is less efficient than true push technologies. Overhead: High, especially under low update frequency or high concurrency. Server and client resources are tied up while connections are kept open. Latency: Can introduce latency as updates are not truly instant push; there's always a delay until the next poll. Use Cases: Simpler real-time updates where true low-latency, bidirectional communication is not essential. Suitable for applications that need to work in environments where WebSockets are not fully supported. Server-Sent Events (SSE): Server push technology over HTTP. Unidirectional, server-to-client communication channel. Client establishes a persistent, read-only connection to the server using HTTP. Server can then push data updates to the client as events over this connection. Standard HTTP protocol, easy to implement on server-side. Overhead: Lower than Long Polling as it's a single persistent connection for server push. Latency: Low latency for server-to-client push, but client-to-server communication still needs separate HTTP requests. Use Cases: Real-time updates from server to client, like news feeds, social updates, stock tickers, live streaming of data. Not suitable for bidirectional communication or client-initiated real-time actions. WebSockets: True bidirectional, full-duplex communication over a single TCP connection. Persistent connection for real-time, two-way data exchange. Lower overhead than HTTP for continuous communication after handshake. Lowest latency for real-time interactions. Use Cases: Real-time applications requiring bidirectional, low-latency communication, such as chat applications, online gaming, collaborative tools, real-time dashboards. Comparison Table: Feature | Long Polling | SSE | WebSockets --------|------------------|--------------------------|----------------------- Communication | Simulated Push (HTTP) | Server-to-Client (HTTP) | Bidirectional (WebSocket) Protocol | HTTP | HTTP | WebSocket Connection | Multiple HTTP Requests | Single Persistent HTTP | Single Persistent TCP Overhead | High | Medium | Low Latency | Higher | Low (Server Push) | Lowest Bidirectional | No (Simulated) | No | Yes Server Push | Simulated | Yes | Yes Complexity | Simple to Implement | Simple to Implement | More Complex Use Cases | Simple Real-time Updates | Server Updates to Client | Real-time, Interactive Apps Choosing the Right Technology: Choose WebSockets for true real-time, bidirectional communication and lowest latency. Choose SSE for efficient server-to-client push updates with lower overhead than Long Polling and simpler implementation than WebSockets. Choose Long Polling only when server push is not feasible or for simpler applications where simulated real-time updates are sufficient and compatibility with older environments is a concern.",
      "example": "// Conceptual comparison - No runnable code, illustrating differences\n\n// Long Polling (Conceptual - Client-side simulation)\n// function longPoll() {\n//   fetch('/long-polling-endpoint') // HTTP request\n//     .then(response => response.json())\n//     .then(data => {\n//       console.log('Long Polling Data:', data);\n//       longPoll(); // Immediately initiate next poll\n//     })\n//     .catch(error => {\n//       console.error('Long Polling Error:', error);\n//       setTimeout(longPoll, 5000); // Retry after delay on error\n//     });\n// }\n// longPoll();\n\n// Server-Sent Events (SSE - Client-side listener)\n// const eventSource = new EventSource('/sse-endpoint');\n// eventSource.onmessage = function(event) {\n//   console.log('SSE Event Data:', event.data);\n// };\n// eventSource.onerror = function(error) {\n//   console.error('SSE Error:', error);\n//   eventSource.close();\n// };\n\n// WebSockets (Example from previous concept - Bidirectional)\n// const websocketExampleComparison = new WebSocket('wss://echo.websocket.events');\n// websocketExampleComparison.onmessage = function(event) {\n//   console.log('WebSocket Message:', event.data);\n// };\n// websocketExampleComparison.onopen = function() {\n//   websocketExampleComparison.send('WebSocket message');\n// };\n\n// Note: These are conceptual examples. Actual implementation requires server-side endpoints for each technology (/long-polling-endpoint, /sse-endpoint, WebSocket server for wss://...). Observe the differences in setup and communication patterns for each approach."
      ,
      "keyPoints": [
        "Long Polling, SSE, and WebSockets are real-time web communication technologies with different characteristics.",
        "Long Polling: Simulated push over HTTP, high overhead, higher latency, simple to implement, for basic real-time needs.",
        "SSE (Server-Sent Events): Server-to-client push over HTTP, lower overhead than Long Polling, low latency for server push, unidirectional, simple to implement, for server updates.",
        "WebSockets: True bidirectional, full-duplex, persistent TCP connection, lowest latency, lowest overhead for continuous comms, more complex, for interactive real-time apps.",
        "Choose WebSockets for bidirectional, low-latency needs (chat, games).",
        "Choose SSE for efficient server push (feeds, updates).",
        "Choose Long Polling for simple updates or when server push is not feasible, considering its limitations."
      ],
      "quiz": [
        {
          "question": "Which real-time web communication technology provides true bidirectional communication?",
          "options": ["Long Polling", "Server-Sent Events (SSE)", "WebSockets", "AJAX"],
          "correctAnswer": 2
        },
        {
          "question": "Which technology simulates server push over HTTP by keeping connections open and polling?",
          "options": ["WebSockets", "SSE", "Long Polling", "HTTP/2 Push"],
          "correctAnswer": 2
        },
        {
          "question": "Which technology is best suited for applications requiring efficient server-to-client push for updates like news feeds?",
          "options": ["Long Polling", "WebSockets", "Server-Sent Events (SSE)", "AJAX"],
          "correctAnswer": 2
        },
        {
          "question": "Which technology generally has the lowest overhead for continuous, bidirectional real-time communication?",
          "options": ["Long Polling", "SSE", "WebSockets", "All have similar overhead"],
          "correctAnswer": 2
        },
        {
          "question": "Which technology is the simplest to implement for basic server-to-client real-time updates?",
          "options": ["WebSockets", "Long Polling", "Server-Sent Events (SSE)", "They are all equally complex"],
          "correctAnswer": 2
        }
      ],
      "interactiveExamples": [
        {
          "title": "SSE (Server-Sent Events) - Client-Side Listener Demo",
          "code": "// HTML (add a div for SSE output to body): <div id='sseOutput'></div>\nconst sseOutputDiv = document.getElementById('sseOutput');\nconst sseSource = new EventSource('/sse-stream'); // Replace '/sse-stream' with your SSE endpoint URL\n\nsseSource.onopen = function() {\n  sseOutputDiv.innerHTML += '<p>SSE connection opened.</p>';\n};\n\nsseSource.onmessage = function(event) {\n  sseOutputDiv.innerHTML += '<p>SSE Message: ' + event.data + '</p>'; // Display server-sent data\n};\n\nsseSource.onerror = function(error) {\n  sseOutputDiv.innerHTML += '<p style=\"color: red;\">SSE error occurred.</p>';\n  eventSource.close(); // Close connection on error\n};\n\n// Note: This is client-side code. To run, you need a server sending SSE events at '/sse-stream' endpoint. For testing, you might need to set up a simple server that pushes data as 'data: your_data\\n\\n' in 'text/event-stream' content type."
        },
        {
          "title": "Long Polling - Conceptual Client-Side Simulation",
          "code": "// HTML (add a div for Long Polling output to body): <div id='longPollingOutput'></div>\nconst longPollingOutputDiv = document.getElementById('longPollingOutput');\n\nfunction startLongPolling() {\n  fetch('/long-poll-data') // Replace '/long-poll-data' with your long-polling endpoint URL\n    .then(response => response.json())\n    .then(data => {\n      longPollingOutputDiv.innerHTML += '<p>Long Polling Data: ' + JSON.stringify(data) + '</p>'; // Display data\n      startLongPolling(); // Initiate next long poll\n    })\n    .catch(error => {\n      longPollingOutputDiv.innerHTML += '<p style=\"color: orange;\">Long Polling Request Error. Retrying...</p>';\n      setTimeout(startLongPolling, 5000); // Retry after 5 seconds\n    });\n}\n\nstartLongPolling();\n\n// Note: This is client-side simulation. To run, you need a server endpoint '/long-poll-data' that handles long-polling requests (holds connection, responds when data is available or timeout). This example simulates client-side behavior of initiating and retrying long poll requests."
        }
      ]
    },
    {
      "id": "interview-js-concept-28",
      "title": "Request Animation Frame (requestAnimationFrame)",
      "description": "Explain `requestAnimationFrame`, its benefits for smooth animations and performance, and how to use it for browser-based animations.",
      "difficulty": "intermediate",
      "category": "browser-api",
      "explanation": "`requestAnimationFrame` (rAF) is a browser API for scheduling animations. It tells the browser that you wish to perform an animation and requests that the browser calls a specified function to update an animation before the next repaint. This is a more efficient and performant way to create animations in the browser compared to using `setTimeout` or `setInterval`. Benefits of `requestAnimationFrame`: Performance Optimization: rAF callbacks are executed right before the browser's repaint, typically around 60 times per second (matching most screen refresh rates). This synchronizes animations with the browser's rendering pipeline, leading to smoother animations and better performance. Reduced Jank: By synchronizing with the repaint cycle, rAF helps avoid animation jank and stutter, providing a more fluid visual experience. Battery Efficiency: When animations are not needed (e.g., tab is in background), browsers can optimize rAF callbacks, reducing CPU and battery usage compared to continuously running timers. Best Practice for Browser Animations: rAF is the recommended way to create animations in modern browsers. It replaces older methods like `setInterval` and `setTimeout` for animation loops because it is designed specifically for animation timing and browser rendering optimizations. How to Use `requestAnimationFrame`: Basic Usage: Call `requestAnimationFrame(callback)` where `callback` is a function to be executed before the next repaint. The callback function is passed a `timestamp` argument, representing the time when rAF callback starts to execute. Animation Loop: To create a continuous animation, the callback function typically updates animation properties (e.g., element position, style) and then calls `requestAnimationFrame` again to schedule the next animation frame. Canceling Animation Frame: Use `cancelAnimationFrame(requestID)` to stop a scheduled animation frame, where `requestID` is the value returned by `requestAnimationFrame`. Example Use Cases: Smooth animations and transitions. Game animations and rendering loops. Interactive visual effects. Any scenario where you need to update visual elements in the browser smoothly and efficiently.",
      "example": "// Basic requestAnimationFrame example - simple animation\n// const elementToAnimate = document.getElementById('animateElement');\n// let position = 0;\n// const speed = 1; // pixels per frame\n\n// function animateElement() {\n//   position += speed;\n//   elementToAnimate.style.transform = `translateX(${position}px)`;\n//   if (position < 300) { // Animation stop condition\n//     requestAnimationFrame(animateElement); // Schedule next frame\n//   }\n// }\n\n// requestAnimationFrame(animateElement); // Start animation loop\n\n// Canceling requestAnimationFrame example\n// let animationRequestId;\n// function startAnimationWithCancel() {\n//   let positionCancel = 0;\n//   function animateCancelElement() {\n//     positionCancel += speed;\n//     elementToAnimate.style.transform = `translateX(${positionCancel}px)`;\n//     if (positionCancel < 300) {\n//       animationRequestId = requestAnimationFrame(animateCancelElement);\n//     } else {\n//       cancelAnimationFrame(animationRequestId); // Stop animation after reaching 300px\n//       console.log('Animation stopped.');\n//     }\n//   }\n//   animationRequestId = requestAnimationFrame(animateCancelElement);\n// }\n\n// startAnimationWithCancel();\n\n// HTML (add a div to body with id='animateElement' and some inline style for visibility):\n// <div id='animateElement' style='width: 50px; height: 50px; background-color: coral; position: absolute;'></div>",
      "keyPoints": [
        "`requestAnimationFrame` (rAF) is a browser API for efficient, smooth animations.",
        "Synchronizes animations with browser repaint cycle (typically 60fps).",
        "Benefits: Performance optimization, reduced jank, battery efficiency.",
        "rAF callback is executed right before browser repaint.",
        "Use `requestAnimationFrame(callback)` to schedule animation frame.",
        "Create animation loops by calling `requestAnimationFrame` again within the callback.",
        "`cancelAnimationFrame(requestID)` to stop animation.",
        "Recommended for browser-based animations, replacing `setTimeout`/`setInterval` for animation loops."
      ],
      "quiz": [
        {
          "question": "What is the primary purpose of `requestAnimationFrame` in JavaScript?",
          "options": ["To execute code repeatedly at fixed intervals", "To handle user input events for animations", "To schedule animation updates synchronized with the browser's repaint cycle", "To replace CSS animations"],
          "correctAnswer": 2
        },
        {
          "question": "How many times per second does `requestAnimationFrame` typically try to execute callbacks?",
          "options": ["10 times per second", "30 times per second", "60 times per second (matching typical screen refresh rate)", "120 times per second"],
          "correctAnswer": 2
        },
        {
          "question": "What is a key performance benefit of using `requestAnimationFrame` over `setInterval` for animations?",
          "options": ["`requestAnimationFrame` always runs faster", "`requestAnimationFrame` is easier to code", "`requestAnimationFrame` synchronizes with the browser's rendering pipeline, reducing jank", "`setInterval` is not meant for animations"],
          "correctAnswer": 2
        },
        {
          "question": "How do you create a continuous animation loop using `requestAnimationFrame`?",
          "options": ["By calling `requestAnimationFrame` once at the beginning", "By using a `for` loop with `requestAnimationFrame`", "By calling `requestAnimationFrame` repeatedly inside the callback function", "By setting a delay in `requestAnimationFrame`"],
          "correctAnswer": 2
        },
        {
          "question": "How do you stop a `requestAnimationFrame` animation loop?",
          "options": ["Using `clearInterval()`", "Using `clearTimeout()`", "Using `cancelAnimationFrame()`", "Animations started with `requestAnimationFrame` cannot be stopped"],
          "correctAnswer": 2
        }
      ],
      "interactiveExamples": [
        {
          "title": "Basic requestAnimationFrame Animation - Moving Box",
          "code": "// HTML (add to body): <div id='box' style='width:50px; height:50px; background:coral; position:absolute; top:50px; left:0;'></div>\nconst boxElement = document.getElementById('box');\nlet boxPosition = 0;\nconst animationSpeed = 2; // pixels per frame\n\nfunction animateBox() {\n  boxPosition += animationSpeed;\n  boxElement.style.left = boxPosition + 'px';\n  if (boxPosition < 500) { // Stop condition for animation\n    requestAnimationFrame(animateBox); // Schedule next frame\n  }\n}\n\nrequestAnimationFrame(animateBox); // Start animation\n\n// Open HTML in browser. A coral box will smoothly move from left to right using requestAnimationFrame for animation."
        },
        {
          "title": "requestAnimationFrame - Smooth Rotation Animation",
          "code": "// HTML (add to body): <div id='spinner' style='width:50px; height:50px; border:5px solid blue; border-radius:50%; position:relative;'></div>\nconst spinnerElement = document.getElementById('spinner');\nlet rotationAngle = 0;\n\nfunction animateSpinner() {\n  rotationAngle += 2; // Degrees to rotate per frame\n  spinnerElement.style.transform = `rotate(${rotationAngle}deg)`;\n  requestAnimationFrame(animateSpinner); // Continue animation loop\n}\n\nanimateSpinner(); // Start rotation animation\n\n// Open HTML in browser. A blue bordered div will smoothly rotate continuously using requestAnimationFrame for animation loop."
        }
      ]
    },
    {
      "id": "interview-js-concept-29",
      "title": "Canvas API Basics",
      "description": "Introduce the Canvas API in HTML5, its capabilities for 2D graphics, basic drawing operations (shapes, paths, text, images), and use cases.",
      "difficulty": "beginner",
      "category": "browser-api",
      "explanation": "The HTML5 Canvas API provides a powerful way to draw graphics, animations, games, and visualizations directly in the browser using JavaScript. It offers a bitmap canvas (a drawing surface) that you can control pixel by pixel using JavaScript. Key Concepts of Canvas API: `<canvas>` Element: HTML element that acts as a container for graphics. You use JavaScript to draw on it. Rendering Context: To draw on a canvas, you first need to get its 2D rendering context using `canvas.getContext('2d')`. This context object provides methods and properties for drawing shapes, paths, text, images, and more. Basic Drawing Operations: Shapes: `fillRect(x, y, width, height)`: Draws a filled rectangle. `strokeRect(x, y, width, height)`: Draws a rectangle outline. `clearRect(x, y, width, height)`: Clears a rectangular area. Paths: Drawing complex shapes involves paths. `beginPath()`, `moveTo(x, y)`, `lineTo(x, y)`, `arc()`, `closePath()`, `fill()`, `stroke()`. Styles and Colors: `fillStyle = color`: Sets the fill color for shapes. `strokeStyle = color`: Sets the stroke color for paths and outlines. `lineWidth = number`: Sets the line width for strokes. Text: `fillText(text, x, y)`: Draws filled text. `strokeText(text, x, y)`: Draws text outline. `font = CSS font`: Sets the font style, size, and family. Images: `drawImage(image, dx, dy)` or `drawImage(image, dx, dy, dWidth, dHeight)` or more parameters for slicing and scaling. Transformations: `translate(x, y)`, `rotate(angle)`, `scale(xScale, yScale)`: Transform the canvas coordinate system. Use Cases for Canvas API: 2D Games: Creating game graphics, animations, and interactive game elements. Data Visualization: Charts, graphs, and infographics. Image Editing and Manipulation: Basic image processing, filters, and effects. Interactive Graphics: Drawing applications, dynamic graphics, and custom UI components. Canvas API is a fundamental technology for creating rich visual content directly in the browser, offering a wide range of possibilities for graphics and interactive experiences.",
      "example": "// HTML (add <canvas> element to body): <canvas id='myCanvas' width='200' height='100' style='border:1px solid #d3d3d3;'>Your browser does not support the HTML5 canvas tag.</canvas>\nconst canvas = document.getElementById('myCanvas');\nconst ctx = canvas.getContext('2d'); // Get 2D rendering context\n\n// Drawing a rectangle\nctx.fillStyle = 'green';\nctx.fillRect(10, 10, 50, 50); // Fill rectangle at (10,10) with size 50x50\n\n// Drawing a line (path)\nctx.beginPath();\nctx.moveTo(80, 10);\nctx.lineTo(150, 50);\nctx.lineTo(80, 90);\nctx.strokeStyle = 'blue';\nctx.stroke(); // Stroke the path outline\n\n// Drawing text\nctx.font = '20px Arial';\nctx.fillStyle = 'black';\nctx.fillText('Hello Canvas', 10, 90); // Filled text at (10, 90)\n\n// Drawing a circle (arc)\nctx.beginPath();\nctx.arc(150, 35, 20, 0, 2 * Math.PI); // Arc at (150, 35), radius 20, full circle\nctx.fillStyle = 'red';\nctx.fill(); // Fill the circle\n\n// Note: Run this HTML in a browser to see basic drawings on the canvas element. Experiment with different drawing methods, styles, and shapes using Canvas API."
      ,
      "keyPoints": [
        "HTML5 Canvas API provides a bitmap canvas for 2D graphics in browsers.",
        "`<canvas>` element is the container, JavaScript Canvas API draws on it.",
        "Get 2D rendering context using `canvas.getContext('2d')` to access drawing methods.",
        "Basic drawing: shapes (`fillRect`, `strokeRect`, `clearRect`), paths (`beginPath`, `moveTo`, `lineTo`, `arc`, `closePath`, `fill`, `stroke`), text (`fillText`, `strokeText`), images (`drawImage`).",
        "Styles and colors: `fillStyle`, `strokeStyle`, `lineWidth`, `font`.",
        "Transformations: `translate`, `rotate`, `scale` to manipulate canvas coordinate system.",
        "Use cases: 2D games, data visualization, image editing, interactive graphics."
      ],
      "quiz": [
        {
          "question": "What type of graphics does the HTML5 Canvas API primarily render?",
          "options": ["3D vector graphics", "2D bitmap graphics", "SVG vector graphics", "WebGL 3D graphics"],
          "correctAnswer": 1
        },
        {
          "question": "Which HTML element is used as a container for Canvas graphics?",
          "options": ["`<svg>`", "`<graphics>`", "`<canvas>`", "`<div>`"],
          "correctAnswer": 2
        },
        {
          "question": "How do you get the 2D rendering context to draw on a canvas in JavaScript?",
          "options": ["`canvas.getContext('3d')`", "`canvas.getContext('webgl')`", "`canvas.getContext('2d')`", "`canvas.getRenderContext()`"],
          "correctAnswer": 2
        },
        {
          "question": "Which Canvas API method is used to draw a filled rectangle?",
          "options": ["`drawRect()`", "`fillRect()`", "`strokeRect()`", "`createRect()`"],
          "correctAnswer": 1
        },
        {
          "question": "What is the purpose of `beginPath()` and `closePath()` methods in Canvas API paths?",
          "options": ["To set colors for paths", "To begin and close a path definition for complex shapes", "To clear the canvas", "To load images onto the canvas"],
          "correctAnswer": 1
        }
      ],
      "interactiveExamples": [
        {
          "title": "Canvas - Basic Shapes Drawing",
          "code": "// HTML (add <canvas id='basicShapesCanvas' width=200 height=150 style='border:1px solid'>)\nconst basicShapesCanvas = document.getElementById('basicShapesCanvas');\nconst shapesCtx = basicShapesCanvas.getContext('2d');\n\n// Rectangle\nshapesCtx.fillStyle = 'lightblue';\nshapesCtx.fillRect(10, 10, 60, 40);\n\n// Circle\nshapesCtx.beginPath();\nshapesCtx.arc(100, 30, 25, 0, 2 * Math.PI);\nshapesCtx.fillStyle = 'lightgreen';\nshapesCtx.fill();\n\n// Triangle (using paths)\nshapesCtx.beginPath();\nshapesCtx.moveTo(10, 100);\nshapesCtx.lineTo(60, 100);\nshapesCtx.lineTo(35, 60);\nshapesCtx.closePath();\nshapesCtx.fillStyle = 'lightcoral';\nshapesCtx.fill();\n\n// Text\nshapesCtx.font = '16px Arial';\nshapesCtx.fillStyle = 'black';\nshapesCtx.fillText('Shapes Demo', 10, 140);\n\n// Open HTML, see different shapes drawn on canvas. Experiment with colors, positions, sizes, and shapes."
        },
        {
          "title": "Canvas - Interactive Drawing - Simple Line Drawing",
          "code": "// HTML (add <canvas id='interactiveCanvas' width=250 height=150 style='border:1px solid'>)\nconst interactiveCanvas = document.getElementById('interactiveCanvas');\nconst interactiveCtx = interactiveCanvas.getContext('2d');\nlet isDrawing = false;\n\ninteractiveCanvas.addEventListener('mousedown', (e) => {\n  isDrawing = true;\n  interactiveCtx.beginPath();\n  interactiveCtx.moveTo(e.offsetX, e.offsetY);\n});\n\ninteractiveCanvas.addEventListener('mousemove', (e) => {\n  if (!isDrawing) return;\n  interactiveCtx.lineTo(e.offsetX, e.offsetY);\n  interactiveCtx.stroke();\n});\n\ninteractiveCanvas.addEventListener('mouseup', () => {\n  isDrawing = false;\n});\n\ninteractiveCanvas.addEventListener('mouseout', () => {\n  isDrawing = false;\n});\n\n// Open HTML, click and drag on canvas to draw lines. Simple interactive drawing example using canvas mouse events."
        }
      ]
    },
    {
      "id": "interview-js-concept-30",
      "title": "SVG (Scalable Vector Graphics) Basics",
      "description": "Introduce SVG, its vector graphics nature, advantages over raster images, basic SVG shapes, and embedding SVG in HTML.",
      "difficulty": "beginner",
      "category": "browser-api",
      "explanation": "SVG (Scalable Vector Graphics) is an XML-based vector image format for defining two-dimensional graphics. Unlike raster image formats like JPEG or PNG that store images as a grid of pixels, SVG images are defined using XML markup that describes shapes, paths, text, and other graphic elements as vectors. Key Characteristics of SVG: Vector Graphics: SVG images are vector-based, meaning they are defined by mathematical formulas (paths, shapes) rather than pixels. This makes them resolution-independent and scalable without loss of quality. Scalability: SVG images can be scaled up or down without becoming pixelated or blurry, making them ideal for responsive designs and different screen resolutions. XML-Based Format: SVG is written in XML, making it accessible and manipulable via code (JavaScript, CSS). You can directly edit SVG code, style SVG elements with CSS, and interact with them using JavaScript. Text-Based: As a text-based format, SVG files are typically smaller than equivalent raster images, especially for graphics with large areas of solid color or simple shapes. Interactivity and Animation: SVG elements can be styled, animated, and made interactive using CSS and JavaScript. Accessibility: SVG is inherently more accessible than raster images because text within SVG images is selectable and searchable, and SVG elements can be semantically structured. Basic SVG Shapes: `<rect>`: Rectangle. `<circle>`: Circle. `<ellipse>`: Ellipse. `<line>`: Line. `<polyline>`: Series of connected lines. `<polygon>`: Closed shape with multiple sides. `<path>`: Most versatile, for complex paths and curves. Embedding SVG in HTML: Inline SVG: Embed SVG code directly within HTML markup. `<svg width=\"100\" height=\"100\"> <circle cx=\"50\" cy=\"50\" r=\"40\" stroke=\"green\" stroke-width=\"4\" fill=\"yellow\" /> </svg>` Image tag: Use SVG files as image sources in `<img>` tags: `<img src=\"image.svg\" alt=\"SVG Image\">` CSS Background Images: Use SVG files as background images in CSS: `background-image: url('image.svg');` SVG is well-suited for logos, icons, illustrations, charts, and any graphics that need to be scalable, interactive, and maintain visual quality across different sizes and devices.",
      "example": "// Inline SVG example in HTML (add to body)\n// <svg width=\"200\" height=\"150\" style=\"border:1px solid #d3d3d3;\">\n//   <rect width=\"100\" height=\"50\" x=\"10\" y=\"10\" style=\"fill:red;stroke:black;stroke-width:2;\" />\n//   <circle cx=\"150\" cy=\"80\" r=\"30\" fill=\"lightblue\" />\n//   <text x=\"10\" y=\"140\" font-size=\"20\">SVG Text</text>\n// </svg>\n\n// JavaScript manipulation of SVG (example - change circle color on click)\n// const svgCircle = document.querySelector('circle');\n// svgCircle.addEventListener('click', function() {\n//   svgCircle.setAttribute('fill', 'orange'); // Change fill color to orange on click\n// });\n\n// Note: Run this HTML in a browser. You will see basic SVG shapes rendered. Click on the circle to see JavaScript manipulation of SVG attributes. Inspect the SVG code in browser's Elements tab to understand SVG XML structure."
      ,
      "keyPoints": [
        "SVG (Scalable Vector Graphics) is an XML-based vector image format.",
        "Vector graphics: resolution-independent, scalable without quality loss.",
        "XML-based: text format, accessible, manipulable via code (JS, CSS).",
        "Advantages over raster: scalability, smaller file size (often), interactivity, accessibility.",
        "Basic SVG shapes: `<rect>`, `<circle>`, `<ellipse>`, `<line>`, `<polyline>`, `<polygon>`, `<path>`.",
        "Embed SVG in HTML: inline SVG, `<img>` tag, CSS background images.",
        "Well-suited for logos, icons, illustrations, charts, scalable graphics."
      ],
      "quiz": [
        {
          "question": "What type of graphics are SVG images?",
          "options": ["Raster graphics", "Bitmap graphics", "Vector graphics", "Pixel-based graphics"],
          "correctAnswer": 2
        },
        {
          "question": "What is the primary advantage of SVG over raster image formats like JPEG or PNG?",
          "options": ["Smaller file sizes for complex images", "Better color depth", "Scalability without loss of quality", "Faster loading times in all browsers"],
          "correctAnswer": 2
        },
        {
          "question": "In what format is SVG code written?",
          "options": ["JSON", "HTML", "XML", "CSS"],
          "correctAnswer": 2
        },
        {
          "question": "Which SVG shape is used to draw rectangles?",
          "options": ["`<circle>`", "`<rect>`", "`<polygon>`", "`<path>`"],
          "correctAnswer": 1
        },
        {
          "question": "Can SVG elements be styled and animated using CSS and JavaScript?",
          "options": ["No, SVG is static and cannot be styled or animated", "Yes, SVG elements can be styled with CSS and manipulated with JavaScript", "Only basic styling is possible with inline styles", "Only animations are possible, styling is not supported"],
          "correctAnswer": 1
        }
      ],
      "interactiveExamples": [
        {
          "title": "SVG Basic Shapes - Displaying Common Shapes",
          "code": "// HTML (add to body):\n// <svg id='svgShapes' width='250' height='150' style='border:1px solid #d3d3d3;'></svg>\nconst svgShapesElement = document.getElementById('svgShapes');\n\n// Rectangle\nconst rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');\nrect.setAttribute('width', 80); rect.setAttribute('height', 40); rect.setAttribute('x', 10); rect.setAttribute('y', 10); rect.setAttribute('style', 'fill:yellow;stroke:black;stroke-width:1;');\nsvgShapesElement.appendChild(rect);\n\n// Circle\nconst circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');\ncircle.setAttribute('cx', 150); circle.setAttribute('cy', 60); circle.setAttribute('r', 30); circle.setAttribute('fill', 'lightblue');\nsvgShapesElement.appendChild(circle);\n\n// Line\nconst line = document.createElementNS('http://www.w3.org/2000/svg', 'line');\nline.setAttribute('x1', 10); line.setAttribute('y1', 100); line.setAttribute('x2', 80); line.setAttribute('y2', 140); line.setAttribute('style', 'stroke:rgb(0,0,0);stroke-width:2');\nsvgShapesElement.appendChild(line);\n\n// Text\nconst text = document.createElementNS('http://www.w3.org/2000/svg', 'text');\ntext.setAttribute('x', 100); text.setAttribute('y', 140); text.textContent = 'SVG Shapes'; text.setAttribute('font-size', '18');\nsvgShapesElement.appendChild(text);\n\n// Open HTML in browser, see basic SVG shapes rendered. Inspect SVG code in Elements tab."
        },
        {
          "title": "Interactive SVG - Changing Circle Color on Click with JavaScript",
          "code": "// HTML (add to body): <svg id='interactiveSVG' width='150' height='150' style='border:1px solid #d3d3d3;'><circle id='interactiveCircle' cx='75' cy='75' r='50' fill='coral' style='cursor:pointer;' /></svg>\nconst interactiveSVGElement = document.getElementById('interactiveSVG');\nconst interactiveCircleElement = document.getElementById('interactiveCircle');\n\ninteractiveCircleElement.addEventListener('click', function() {\n  const currentColor = interactiveCircleElement.getAttribute('fill');\n  interactiveCircleElement.setAttribute('fill', currentColor === 'coral' ? 'lightgreen' : 'coral'); // Toggle color\n});\n\n// Open HTML in browser. Click on the coral circle to change its color to lightgreen and back on subsequent clicks. Demonstrates basic SVG interactivity with JavaScript."
        }
      ]
    }
  ]
}





